
## 📌 프로세스 동기화(Synchronization)란 무엇인가요?
프로세스 동기화는 여러 프로세스가 공유 데이터를 동시에 접근할 때 발생할 수 있는 데이터 불일치(Race Condition) 문제를 해결하기 위해, <mark>특정 시간에 오직 하나의 프로세스만 공유 데이터에 접근하도록 제어하는 방법</mark><mark> </mark>입니다. 
##### 💡 프로세스 동기화의 목표 요구사항 3가지는 무엇인가요?
- **상호 배제(Mutual Exclusion)**: 어떤 프로세스가 임계 구역(Critical Section)에서 실행 중일 때 다른 프로세스는 해당 임계 구역에 진입할 수 없어야 합니다. 
- **진행(Progress)**: 임계 구역에 진입하려는 프로세스가 있을 때, 아무도 진입하지 못하고 무한정 대기하는 상황(데드락)이 발생하지 않아야 합니다. 
- **한정된 대기(Bounded Waiting)**: 프로세스가 임계 구역에 진입하기 위해 기다리는 시간이 한정되어야 하며, 기아(Starvation) 상태가 발생하지 않아야 합니다. 


이 콘텐츠는 **운영체제에서 발생하는 프로세스 동기화 문제**의 본질을 깊이 있게 파헤칩니다. 여러 프로세스가 공유 데이터에 동시에 접근할 때 발생하는 **'경쟁 상태(Race Condition)'**가 왜 데이터 무결성을 깨뜨리는지, 그리고 카운트++와 같은 단순한 연산조차 기계어 레벨에서 어떻게 문제를 일으키는지 구체적인 예시를 통해 명확히 설명합니다. 이 강의를 통해 여러분은 복잡한 시스템에서 **데이터 일관성을 유지하는 것의 중요성**을 이해하고, 앞으로 다룰 동기화 해결책들이 왜 필요한지에 대한 **탄탄한 개념적 기반**을 다질 수 있을 것입니다.
## 1. 프로세스 동기화 (Synchronization) 개요 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/0.jpg)
1. **협력 프로세스(Cooperating Process)의 문제점** 
  1. 프로세스들이 논리적 주소 공간(Logical Address Space)이나 데이터를 공유할 때 발생한다. 
  2. 공유 데이터에 동시 접근 시 **데이터 불일치(Data Inconsistency)** 문제가 발생할 수 있다. 
  3. 이는 데이터의 **무결성(Integrity)**을 해치는 결과를 초래한다. 

2. **동기화의 필요성** 
  1. 협력 프로세스들이 공유 데이터에 동시 접근할 때, 실행 순서가 순차적으로 보장되도록 해야 한다. 
  2. **컨텍스트 스위치(Context Switch)**: 프로세스가 언제 어디서든 인터럽트(Interrupt)에 의해 선점(Preemption)될 수 있으므로, 명령어 스트림이 어디서 끊길지 예측할 수 없다. 
  3. **병렬 실행(Parallel Execution)**: 여러 프로세스가 동시에 CPU에서 실행될 때도 동기화 문제가 발생한다. 
  4. 이러한 상황에서 공유 데이터를 다루지 않으면 문제가 없지만, 공유 데이터를 다루면 항상 **데이터 불일치 문제**가 발생한다. 


## 2. 경쟁 상태(Race Condition)의 이해 


### 2.1. 생산자-소비자 문제 예시를 통한 경쟁 상태 설명 
![image]()
1. **생산자-소비자 문제 복습** 
  1. 생산자(Producer)와 소비자(Consumer)는 중간 버퍼(Buffer)를 통해 데이터를 주고받는다. 
  2. 버퍼는 공유 메모리(Shared Memory)나 메시지 큐(Message Queue)로 구현될 수 있다. 
  3. 이들은 비동기적(Asynchronous)으로 동작한다. 즉, 생산자는 쓰고 싶을 때 쓰고, 소비자는 읽고 싶을 때 읽는다. 

2. **동시성(Concurrency) 및 병렬성(Parallelism) 환경에서의 문제** 
  1. **동시성**: 단일 코어에서 컨텍스트 스위치를 통해 번갈아 실행될 때도 문제가 발생한다. 
  2. **병렬성**: 여러 코어에서 동시에 실행될 때는 문제가 더 쉽게 이해된다. (예: 생산자와 소비자가 동시에 버퍼에 접근) 

3. **카운트 변수 예시** 
  1. 버퍼에 현재 몇 개의 아이템이 있는지 나타내는 count 변수를 사용한다. 
  2. count는 정수형 변수로 초기값은 0이다. 
  3. 아이템을 추가할 때마다 count를 1 증가시키고, 소비할 때마다 1 감소시킨다. 
  4. **생산자 코드**: 아이템을 버퍼에 넣은 후 count++ 실행 
  5. **소비자 코드**: 아이템을 버퍼에서 가져온 후 count-- 실행 
  6. **문제 발생**: 논리적으로는 count가 5일 때 생산자가 count++를 하고 소비자가 count--를 하면 다시 5가 되어야 하지만, 실제로는 4, 5, 6 등 예측 불가능한 값이 나올 수 있다. 
  1. 이는 프로세스가 분리되어 실행되므로 문제가 없을 것이라고 생각하기 쉽지만, 실제로는 제대로 동작하지 않는다. 


### 2.2. 쓰레드 예시를 통한 경쟁 상태 심화 학습 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/469.jpg)
1. **단순 **sum 증가 프로그램 예시 
  1. 전역 변수 sum을 0으로 초기화한다. 
  2. 두 개의 스레드(T1, T2)를 생성하여 각각 sum을 10,000번 증가시키는 작업을 수행한다. 
  3. 메인 스레드는 두 스레드가 종료될 때까지 기다린다. 
  4. **예상 결과**: T1이 sum을 10,000으로 만들고, T2가 다시 10,000으로 만들므로 최종 sum은 20,000이 되어야 한다. 
  5. **실제 결과**: 20,000이 나올 때도 있지만, 16,813, 19,999, 19,385 등 비정상적인 값이 자주 발생한다. 

2. sum 증가/감소 프로그램 예시 
  1. 스레드 T1은 sum을 10,000번 증가시키고, 스레드 T2는 sum을 10,000번 감소시킨다. 
  2. **예상 결과**: sum은 최종적으로 0이 되어야 한다. 
  3. **실제 결과**: 0이 나올 때도 있지만, 7,445, -3,128 등 비정상적인 값이 발생한다. 
  4. **반복 횟수와 문제 발생 빈도**: sum을 100번 정도 증가/감소시킬 때는 정상적으로 동작하지만, 1,000번을 넘어가면 간헐적으로 발생하고, 10,000번 정도에서는 아주 자주 발생한다. 
  5. 이러한 문제는 코드가 복잡해질수록 찾아내기 매우 어렵다. 


### 2.3. 기계어 레벨에서의 경쟁 상태 발생 원리 
![image]()
1. **C 코드와 기계어 명령어의 불일치** 
  1. count++나 count--와 같은 C 언어의 한 문장은 기계어 레벨에서 **세 가지 명령어**로 구성된다. 
  2. count++의 기계어 변환: 
  1. LOAD R1, count: 메모리의 count 값을 레지스터 R1으로 가져온다.
  2. ADD R1, #1: R1에 1을 더한다.
  3. STORE count, R1: R1의 값을 다시 메모리의 count에 저장한다.
  3. count--의 기계어 변환: 
  1. LOAD R2, count: 메모리의 count 값을 레지스터 R2로 가져온다.
  2. SUB R2, #1: R2에서 1을 뺀다.
  3. STORE count, R2: R2의 값을 다시 메모리의 count에 저장한다.

2. **컨텍스트 스위치 발생 지점** 
  1. CPU는 이 세 가지 명령어 중 **어디에서든 컨텍스트 스위치를 발생**시킬 수 있다. 
  2. 명령어 실행 도중 컨텍스트 스위치가 발생하면 문제가 발생한다. 

3. **경쟁 상태 시나리오 예시** 
  1. **초기 상태**: count = 5 
  2. **프로듀서(P) 실행**: 
  1. P가 count 값을 레지스터 R1에 로드: R1 = 5 
  2. P가 R1에 1을 더함: R1 = 6 
  3. **컨텍스트 스위치 발생**: P는 레지스터 R1의 값(6)을 저장한 채 대기 큐로 이동한다. 
  3. **컨슈머(C) 실행**: 
  1. C가 count 값을 레지스터 R2에 로드: R2 = 5 (P가 count를 메모리에 저장하지 않았으므로 여전히 5) 
  2. C가 R2에서 1을 뺌: R2 = 4 
  3. C가 R2의 값을 count에 저장: count = 4 
  4. **컨텍스트 스위치 발생**: C는 레지스터 R2의 값(4)을 저장한 채 대기 큐로 이동한다. 
  4. **프로듀서(P) 재개**: 
  1. P가 다시 스케줄되어 이전에 저장했던 레지스터 R1의 값(6)을 복원한다. 
  2. P가 R1의 값(6)을 count에 저장: count = 6 
  3. **최종 결과**: count는 6이 된다. (원래는 5가 되어야 함) 
  5. **결론**: 컨텍스트 스위치가 발생하는 시점에 따라 count 값은 4, 5, 6 등 예측 불가능한 값이 될 수 있다. 
  6. **원인**: 물리적으로 동일한 레지스터(R1, R2)를 사용하지만, 컨텍스트 스위치 과정에서 레지스터 값이 저장되고 복원되면서 예상치 못한 방식으로 변하기 때문이다. 


### 2.4. 경쟁 상태(Race Condition)의 정의 및 일반화 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/1176.jpg)
1. **인터리빙(Interleaving) 실행** 
  1. 프로듀서와 컨슈머의 명령어들이 임의의 순서로 **인터리빙(Interleaving)**되어 실행될 때 데이터 무결성이 깨진다. 
  2. 예를 들어, P의 1번, 2번 명령 후 컨텍스트 스위치, C의 1번, 2번 명령 후 컨텍스트 스위치, P의 3번 명령 실행 시 최종 count는 4가 될 수 있다. 
  3. 이러한 실행 순서에 따라 최종 결과가 달라지는 상황을 **경쟁 상태**라고 한다. 

2. **경쟁 상태(Race Condition) 정의** 
  1. **정의**: 여러 프로세스(또는 스레드)가 공유 데이터에 동시(Concurrent) 또는 병렬(Parallel)로 접근하여 처리할 때, **실행 결과가 접근 순서에 따라 달라지는 상황**을 의미한다. 
  2. 경쟁 상태는 개별 케이스를 해결하기보다 일반적인 상황으로 가정하고 해결책을 모색해야 한다. 


## 3. 동기화(Synchronization)의 개념 및 목표 


### 3.1. 동기화의 정의 및 자바 스레드 예시 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/1362.jpg)
1. **동기화(Synchronization)의 정의** 
  1. 경쟁 상태를 해결하기 위해 **특정 시간에 오직 하나의 프로세스만 공유 데이터를 다룰 수 있도록** 하는 방법이다. 
  2. 프로세스 동기화는 경쟁 상황을 막기 위해 데이터 접근 부분을 순차적으로 실행되도록 만드는 것이다. 

2. **자바 스레드에서의 경쟁 상태 예시** 
  1. **경쟁 상태가 발생하지 않는 경우 (인스턴스 변수)** 
  1. Runnable 인터페이스를 구현한 Runner 클래스에 count 변수를 인스턴스 변수로 선언한다. 
  2. 각 스레드(T1, T2)가 new Runner()를 통해 **별도의 객체 인스턴스**를 생성하여 사용한다. 
  3. 이 경우, 각 스레드의 count 변수는 서로 다른 메모리 영역에 저장되므로 **공유 데이터가 아니다.** 
  4. 따라서 경쟁 상태가 발생하지 않으며, 각 스레드는 독립적으로 count를 증가시켜 예상대로 10,000을 출력한다. 
  2. **경쟁 상태가 발생하는 경우 (정적 변수)** 
  1. Runner 클래스의 count 변수를 static으로 선언한다. 
  2. static 변수는 클래스 변수이므로, 모든 Runner 객체가 **동일한 **count 변수를 공유하게 된다. 
  3. 이 경우, 여러 스레드가 동시에 count에 접근하면 경쟁 상태가 발생한다. 
  4. 실제로 실행해보면 10,000, 4,503, 1,518 등 비정상적인 값이 자주 발생한다. 
  5. 반복 횟수가 100 정도일 때는 문제가 없지만, 5,000번 정도에서는 컨텍스트 스위치가 자주 일어나 경쟁 상태가 계속 발생한다. 


### 3.2. 경쟁 상태의 다른 예시 
![image]()
1. **계좌 이체(Account Transfer)** 
  1. 계좌 이체는 **출금(Withdraw)**과 **입금(Deposit)**이라는 두 가지 행위가 동시에 일어나야 한다. 
  2. 출금은 성공했지만 입금이 실패하면, 돈은 나갔는데 받지 못하는 문제가 발생한다. 
  3. 이러한 상황도 경쟁 상태로 다루어야 하며, 나중에 **데드락(Deadlock)** 부분에서 더 자세히 다룰 예정이다. 

2. **스택(Stack)의 Push/Pop 연산** 
  1. 스택에 데이터를 넣는 push와 데이터를 빼는 pop 연산도 경쟁 상태를 가질 수 있다. 
  2. 해결 방법은 아직 배우지 않았으므로, 나중에 동기화 방법을 학습한 후 고민해 볼 문제이다. 


### 3.3. 임계 영역(Critical Section) 문제 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/1793.jpg)
1. **임계 영역 문제의 정의** 
  1. 경쟁 상태를 해결하기 위한 문제를 **임계 영역 문제(Critical Section Problem)**라고 한다. 
  2. **임계 영역(Critical Section)**: N개의 프로세스(P0부터 Pn-1까지)가 있을 때, 공유 데이터에 접근하고 업데이트하는 코드 영역을 의미한다. 
  3. **핵심 목표**: 어떤 프로세스가 임계 영역을 실행 중일 때는 **다른 프로세스들이 임계 영역에 진입할 수 없도록** 만들어야 한다. 
  4. 이러한 방식으로 경쟁 상태 발생을 방지할 수 있다. 

2. **임계 영역의 코드 구조** 
  1. 임계 영역을 인식하고, 두 프로세스가 동시에 임계 영역을 실행하지 않도록 가정하면 프로세스 동기화가 자연스럽게 이루어진다. 
  2. 소스 코드 영역은 네 가지로 나눌 수 있다. 
  1. **진입 영역(Entry Section)**: 임계 영역에 진입하기 위한 코드로, 진입 허가를 얻는 부분이다. 
  2. **임계 영역(Critical Section)**: 공유 데이터를 액세스하고 업데이트하는 실제 코드 영역이다. (예: count++, count--) 
  3. **퇴출 영역(Exit Section)**: 임계 영역을 빠져나오는 코드로, 허가를 반납하는 부분이다. 
  4. **나머지 영역(Remainder Section)**: 임계 영역과 관련 없는 나머지 코드 영역이다. 
  3. **일반적인 프로세스 구조**: while(true) 루프 안에서 진입 영역 → 임계 영역 → 퇴출 영역 → 나머지 영역 순으로 실행된다. 
  4. **목표**: 임계 영역 내에서는 절대로 컨텍스트 스위치가 발생하지 않도록 해야 한다. 


## 4. 임계 영역 문제 해결을 위한 요구사항 


### 4.1. 세 가지 핵심 요구사항 
![image]()
1. **상호 배제(Mutual Exclusion)** 
  1. **정의**: 어떤 프로세스(Pi)가 임계 영역에서 실행 중일 때, 다른 프로세스들은 그 임계 영역에 진입할 수 없어야 한다. 
  2. **필수 조건**: 상호 배제는 임계 영역 문제 해결의 기본이자 필수 조건이다. 이것이 보장되지 않으면 경쟁 상태를 해결할 수 없다. 

2. **진행(Progress)** 
  1. **문제점**: 상호 배제만 적용하면 **데드락(Deadlock)**이나 **기아(Starvation)** 문제가 발생할 수 있다. 
  1. **데드락 예시**: 교차로에서 여러 방향의 차들이 서로를 막아 아무도 진행하지 못하는 상황. 
  2. **정의**: 임계 영역에 진입하려는 프로세스가 존재하고, 임계 영역이 비어 있다면, **무한히 진입이 연기되는 상황이 발생해서는 안 된다.** 
  3. 즉, 임계 영역에 진입하려는 프로세스들이 있다면, 그들 중 하나는 반드시 임계 영역으로 진입할 수 있어야 한다. 

3. **한정된 대기(Bounded Waiting)** 
  1. **문제점**: 특정 프로세스만 계속 임계 영역에 진입하고, 다른 프로세스는 무한히 기다리는 **기아(Starvation)** 문제가 발생할 수 있다. 
  2. **정의**: 프로세스가 임계 영역에 진입하기 위해 요청한 후부터 실제로 진입할 때까지, 그리고 다른 프로세스들이 임계 영역에 진입하는 횟수에 **제한(Limit)**이 있어야 한다. 
  3. 즉, 어떤 프로세스도 무한히 기다리지 않도록 대기 시간을 한정시켜야 한다. 


### 4.2. 현실적인 해결책의 한계 및 커널에서의 경쟁 상태 예시 
![image]()
1. **현실적인 해결책의 어려움** 
  1. 위 세 가지 요구사항을 모두 만족하는 완벽한 해결책을 찾는 것은 매우 어렵다. 
  2. 현실에서는 이러한 완벽한 방법을 잘 사용하지 않으며, 데드락이 발생하면 그때 해결하는 방식을 택한다. 

2. **운영체제 커널에서의 경쟁 상태 예시 (Fork 시스템 호출)** 
  1. fork() 시스템 호출: 새로운 프로세스를 생성하고 고유한 **프로세스 ID(PID)**를 부여해야 한다. 
  2. **PID 할당 과정**: next_available_pid 변수를 통해 다음 사용 가능한 PID를 관리한다. 
  3. **경쟁 상태 시나리오**: 
  1. P0가 fork()를 호출하여 next_available_pid가 2615라고 가정한다.
  2. P0가 PID 2615를 할당받기 전에 컨텍스트 스위치가 발생한다.
  3. P1이 fork()를 호출하면, next_available_pid는 여전히 2615이므로 P1도 PID 2615를 할당받는다.
  4. 결과적으로 P0와 P1이 동일한 PID 2615를 갖게 되어 프로세스 충돌 및 데이터 무결성 문제가 발생한다.
  4. **해결 방안**: PID를 할당한 후 next_available_pid를 1 증가시켜야 한다 (next_available_pid++). 
  5. **문제점**: next_available_pid++ 연산 또한 기계어 레벨에서 여러 명령어로 나뉘므로, 이 과정에서 컨텍스트 스위치가 발생하면 다시 경쟁 상태가 발생할 수 있다. 


## 5. 임계 영역 문제 해결을 위한 초기 접근 방법 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/2397.jpg)
1. **인터럽트 비활성화(Disabling Interrupts)** 
  1. **방법**: 단일 코어 환경에서 임계 영역에 진입하기 위한 가장 간단한 방법은 **인터럽트 발생을 막는 것**이다. 
  2. count++와 같은 임계 영역 코드가 실행되는 동안(LOAD, ADD, STORE 명령어 실행 동안) 인터럽트를 비활성화하면 컨텍스트 스위치가 발생하지 않는다. 
  3. **장점**: 완벽하게 경쟁 상태를 방지할 수 있다. 
  4. **단점**: 너무 단순하여 복잡한 시스템에서는 사용하기 어렵다. 
  5. **제한**: 멀티프로세서 환경에서는 이 방법이 통하지 않는다. 

2. **커널 유형에 따른 접근** 
  1. **비선점형 커널(Non-Preemptive Kernel)** 
  1. **특징**: 커널 모드에서 실행 중인 프로세스는 스스로 CPU를 양보(Voluntarily Yield)할 때까지 선점되지 않는다. 
  2. **장점**: 커널 모드에서 임계 영역에 진입하면 컨텍스트 스위치가 발생하지 않으므로 경쟁 상태가 발생할 일이 없다. 
  3. **단점**: 현대 운영체제에서는 잘 사용되지 않는다. (스케줄러 부분에서 다루었듯이 성능이 저하된다.) 
  2. **선점형 커널(Preemptive Kernel)** 
  1. **특징**: 프로세스가 커널 모드에서 실행 중이라도 언제든지 선점될 수 있다. 
  2. **장점**: 비선점형 커널보다 훨씬 효율적이고 반응성이 좋다. 
  3. **단점**: 동기화 문제가 반드시 발생하므로, 이를 해결하기 위한 추가적인 메커니즘이 필요하다. 


## 6. 결론 및 다음 학습 내용 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/sJVYUakRo2Y/2695.jpg)
1. **이번 시간 학습 요약** 
  1. **임계 영역 문제(Critical Section Problem)**: 여러 프로세스가 공유 자원(데이터, 파일 등)에 동시 또는 병렬로 접근할 때 발생하는 **경쟁 상태(Race Condition)**를 방지하고 데이터 안전성을 보장하는 문제이다. 
  2. 이러한 문제를 해결하는 방법이 바로 **동기화(Synchronization)**이다. 

2. **다음 학습 내용** 
  1. 다음 시간부터는 동기화 문제의 해결책들을 구체적으로 살펴볼 예정이다. 

