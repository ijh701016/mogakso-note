
## 📌 운영체제에서 동기화 문제의 해결책으로 제시된 피터슨 알고리즘과 아토믹 변수의 차이점은 무엇인가요?
피터슨 알고리즘은 소프트웨어적인 해결책으로 상호 배제, 진행, 한정 대기를 모두 만족하지만, 하드웨어적인 지원 없이는 컨텍스트 스위치 문제로 완벽하게 동작하지 않을 수 있습니다. 반면, 아토믹 변수는 <mark>하드웨어 인스트럭션의 원자성을 활용하여 컨텍스트 스위치 없이 동작을 보장함으로써 동기화 문제를 해결</mark><mark> </mark>합니다. 
##### 💡 피터슨 알고리즘이 해결하고자 하는 동기화 문제의 세 가지 조건은 무엇인가요?
- 상호 배제(Mutual Exclusion): 여러 프로세스가 동시에 공유 자원에 접근하지 못하도록 합니다. 
- 진행(Progress): 임계 영역에 진입하려는 프로세스가 있을 때, 다른 프로세스의 방해 없이 진입할 수 있도록 합니다. 
- 한정 대기(Bounded Waiting): 임계 영역에 진입하려는 프로세스가 무한정 기다리지 않도록 합니다. 


이 콘텐츠는 **운영체제의 동기화 문제**를 해결하기 위한 핵심적인 소프트웨어 및 하드웨어 솔루션을 깊이 있게 다룹니다. 특히, 두 프로세스 간의 **상호 배제, 진행, 한정 대기**라는 세 가지 조건을 완벽하게 만족시키는 **피터슨 알고리즘**의 원리와 구현 방식을 상세히 설명합니다. 또한, 실제 코드 구현 시 발생하는 문제점과 이를 해결하기 위한 **아토믹 변수(Atomic Variable)**와 같은 하드웨어 지원 방식의 중요성을 강조하며, 이론과 실제의 간극을 명확히 보여줍니다. 복잡한 동기화 문제를 근본적으로 이해하고, 안정적인 시스템 설계를 위한 **실용적인 해결책**을 모색하는 개발자나 컴퓨터 공학도에게 필수적인 통찰을 제공할 것입니다.
## 1. 동기화 문제 해결책 개요 
![image]()
1. **운영체제 동기화 문제 해결책 탐색**: 운영체제의 동기화 문제 해결을 위한 '싱크로나이제이션 솔루션'을 다룬다. 
2. **소프트웨어 솔루션**: 임계 영역(Critical Section) 문제를 해결하는 '오케어 솔루션'을 살펴본다. 
  1. **초기 소프트웨어 솔루션**:
  1. 두 개의 프로세스를 해결하는 '테크 알고리즘'이 있다 (연습문제 6.13). 
  2. 'n'개의 프로세스에 대해 '웨이팅 타임'의 하한(low bound)을 가지는 '아이젠버그 알고리즘'이 존재한다 (연습문제 6.14). 
  3. 레슬리 램포트가 제안한 '베이커리 알고리즘'도 유명하지만, 본 자료에서는 다루지 않는다. 


## 2. 피터슨 알고리즘 (Peterson's Algorithm) 


### 2.1. 피터슨 알고리즘의 개념 및 작동 방식 
![image]()
1. **피터슨 알고리즘 소개**:
  1. 클래식 소프트웨어 솔루션 중 하나이다. 
  2. 임계 영역 문제를 가장 완전하게 해결한 알고리즘으로 평가된다. 
  3. 다만, 이 알고리즘은 하드웨어적인 보장(개런티)이 없다. 
2. **임계 영역 문제 해결 방식**:
  1. 두 개의 프로세스(나중에 'n'개로 확장 가능)가 임계 영역(Critical Section)과 나머지 영역(Remainder Section)을 번갈아 실행하는 상황을 가정한다. 
  2. 대부분의 프로그램은 while(true) 루프 안에서 임계 영역과 나머지 영역을 반복적으로 실행하는 형태이다. 
  3. **엔트리 섹션(Entry Section)**과 **엑시트 섹션(Exit Section)**을 만들어 임계 영역 문제를 해결하고 레이스 컨디션(Race Condition)을 방지할 수 있다. 
3. **피터슨 알고리즘 구현을 위한 변수**:
  1. int turn: 현재 임계 영역에 진입할 차례인 프로세스를 나타내는 변수이다. 
  2. boolean flag: 각 프로세스가 임계 영역에 진입할 의사가 있음을 나타내는 두 개의 깃발(플래그) 배열이다. 
4. **개념적 설명 (강아지 산책 비유)**:
  1. 두 사람이 개를 키우는데, 개들이 만나면 싸우므로 동시에 산책할 수 없다. 
  2. **약속 방식**: 한 사람이 산책할 때 다른 사람은 기다리고, 산책이 끝나면 다음 사람에게 차례를 넘기는 방식으로 약속한다. 
  3. **깃발과 차례(Turn) 활용**:
  1. 산책하려는 사람이 깃발을 꽂아 "나 산책할 거야"라고 표시한다. 
  2. turn 변수를 통해 "이제 네 차례야"라고 다음 사람에게 알린다. 
  3. 산책을 마치면 깃발을 내리고 turn을 다음 사람으로 바꿔준다. 
  4. 다음 사람은 자신의 차례가 오면 깃발을 꽂고 산책을 시작한다. 
  5. 이 과정을 반복하여 동시에 산책하는 일이 없도록 한다. 
5. **실제 코드 구현 (프로세스 i 기준)**:
  1. **변수 설정**: flag, flag (각각 프로세스 i, j), turn (0 또는 1)을 사용한다. 
  2. **엔트리 섹션**:
  1. flag[i] = true; (프로세스 i가 임계 영역 진입 의사 표시) 
  2. turn = j; (다음 차례는 프로세스 j에게 넘김) 
  3. while (flag[j] == true && turn == j); (프로세스 j가 임계 영역에 진입 의사가 있고, j의 차례이면 대기) 
  4. 이 while 루프를 빠져나왔다는 것은 프로세스 j가 깃발을 내렸거나, turn이 i로 바뀌었음을 의미한다. 
  3. **임계 영역(Critical Section)**: 프로세스 i가 안전하게 작업을 수행한다. 
  4. **엑시트 섹션**:
  1. flag[i] = false; (프로세스 i가 임계 영역 사용 완료 표시) 
  2. turn은 이미 j로 설정되어 있으므로 추가 변경은 필요 없다. 
  5. **나머지 영역(Remainder Section)**: 프로세스 i가 임계 영역 외의 작업을 수행한다. 
  6. 이러한 방식으로 두 프로세스는 동시에 임계 영역에 진입하지 않는다. 


### 2.2. 피터슨 알고리즘의 실제 적용 및 한계 
![image]()
1. **프로듀서-컨슈머 문제에 적용**:
  1. turn 변수와 flag 배열을 사용하여 프로듀서(p0)와 컨슈머(p1) 스레드를 구현한다. 
  2. **프로듀서(p0) 입장**:
  1. flag = true; (생산 의사 표시) 
  2. turn = 1; (다음 차례는 컨슈머에게) 
  3. while (flag == true && turn == 1); (컨슈머가 생산 의사가 있고, 컨슈머 차례이면 대기) 
  4. 임계 영역 진입 후 count++ (생산 작업) 
  5. flag = false; (생산 완료 표시) 
  3. **컨슈머(p1) 입장**: 프로듀서와 대칭적인 구조로 구현된다. 
  1. flag = true; (소비 의사 표시) 
  2. turn = 0; (다음 차례는 프로듀서에게) 
  3. while (flag == true && turn == 0); (프로듀서가 소비 의사가 있고, 프로듀서 차례이면 대기) 
  4. 임계 영역 진입 후 count-- (소비 작업) 
  5. flag = false; (소비 완료 표시) 
  4. 이러한 대칭 구조를 통해 프로듀서와 컨슈머가 하나씩 주고받으며 동기화된 작업을 수행할 수 있다. 
2. **피터슨 알고리즘 실행 결과 및 문제점**:
  1. 위 코드를 10만 번 실행했을 때, 최종 count 값이 0이 아닌 -13, -9 등 비정상적인 값이 나오는 경우가 발생한다. 
  2. 성공하는 경우도 있지만, 대부분 실패한다. 
  3. 이는 피터슨 알고리즘이 **이론적으로는 완벽하지만, 실제 하드웨어 지원 없이는 제대로 동작하지 않을 수 있음**을 보여준다. 
  4. **문제의 원인**:
  1. turn 변수 확인, flag 변수 확인 등의 과정에서 **컨텍스트 스위치(Context Switch)**가 발생할 수 있다. 
  2. 기계어 레벨에서 로드(Load) 및 스토어(Store) 명령으로 쪼개지는 과정에서 원자성(Atomicity)이 보장되지 않아, 엔트리 섹션에서 임계 영역 진입 권한을 얻는 과정이 제대로 이루어지지 않을 수 있다. 
3. **피터슨 알고리즘의 이론적 완벽성**:
  1. 알고리즘 자체는 개념적으로 완벽하다. 
  2. 강아지 산책 비유처럼 깃발과 차례를 주고받는 방식으로 상호 배제를 달성한다. 
  3. **증명 가능한 세 가지 조건 만족**:
  1. **상호 배제(Mutual Exclusion)**: 동시에 임계 영역에 진입하는 일이 절대로 발생하지 않음을 보장한다. 
  2. **진행(Progress)**: 임계 영역에 진입하려는 프로세스가 있다면, 언젠가는 진입할 수 있음을 보장한다 (데드락 방지). 
  3. **한정 대기(Bounded Waiting)**: 프로세스가 임계 영역에 진입하기 위해 무한정 기다리지 않음을 보장한다 (기아 상태 방지). 
  4. 이 세 가지 조건을 모두 만족하는 소프트웨어 솔루션이다. 
4. **피터슨 알고리즘의 의의**:
  1. 두 프로세스 간의 동기화를 flag와 turn 변수를 이용해 티키타카 방식으로 해결하는 방법을 제시한다. 
  2. 데커 알고리즘, 아이젠버그 알고리즘, 램포트의 베이커리 알고리즘 등 더 복잡한 알고리즘도 있지만, 피터슨 알고리즘은 이론적으로 개념적으로 세 가지 조건을 해결하는 소프트웨어 솔루션으로서의 가치가 크다. 


## 3. 하드웨어 지원을 통한 동기화 해결: 원자 변수 (Atomic Variable) 


### 3.1. 하드웨어 지원의 필요성 및 원자성 개념 
![image]()
1. **소프트웨어 솔루션의 한계**:
  1. 피터슨 알고리즘과 같은 소프트웨어 솔루션은 하드웨어 지원 없이는 문제가 발생한다. 
  2. 기계어 레벨(인스트럭션 레벨)에서 연산이 여러 단계로 쪼개질 때, 그 사이에 컨텍스트 스위치가 발생하면 원자성이 보존되지 않아 문제가 생긴다. 
  3. 하드웨어 인스트럭션 자체가 임계 영역 문제를 푸는 데 필요한 원자성을 지원해주지 못하는 경우가 많다. 
2. **하드웨어 지원의 중요성**:
  1. 만약 하드웨어가 TestAndSet과 같은 원자적 연산을 제공한다면, 이를 통해 동기화를 바로 해결하는 것이 가장 좋다. 
  2. 하드웨어 인스트럭션을 원자적으로 만들면, **원자 변수(Atomic Variable)**를 사용할 수 있게 된다. 
3. **원자성(Atomicity)이란?**:
  1. **아톰(Atom)**: 더 이상 쪼갤 수 없는 물리적 최소 단위를 의미한다. 
  2. **원자적 연산(Atomic Operation)**: 더 이상 쪼갤 수 없으며, 인터럽트(Interrupt)가 걸릴 수 없는 연산 단위를 말한다. 
  3. **예시**: move R1, #A와 같은 하드웨어 인스트럭션은 CPU 클럭 사이클 단위로 실행되므로, 이 과정에서는 인터럽트가 걸릴 수 없다. 
4. **특수 하드웨어 인스트럭션**:
  1. a++와 같이 값을 확인하고 수정하는 연산은 일반적으로 여러 기계어 명령(로드, 증가, 스토어)으로 쪼개진다. 
  2. 이러한 연산을 하나의 CPU 클럭에 실행되도록 **특수 하드웨어 인스트럭션**으로 만들 수 있다. 
  3. 예를 들어, 두 변수의 값을 교환하는 swap 연산도 여러 명령으로 쪼개지지만, 이를 하나의 하드웨어 회로로 만들어 원자적으로 실행할 수 있다. 


### 3.2. TestAndSet 및 CompareAndSwap 하드웨어 인스트럭션 
![image]()
1. TestAndSet 인스트럭션:
  1. 개념적으로는 특정 메모리 위치의 값을 확인하고, 그 값을 true로 설정하는 작업을 하나의 원자적 명령으로 수행한다. 
  2. **구현 예시**:
  1. boolean lock = false; (글로벌 락 변수 초기화) 
  2. while (TestAndSet(&lock)); (락이 true인 동안 대기) 
  3. 임계 영역 진입 후 작업 수행 
  4. lock = false; (임계 영역 사용 완료 후 락 해제) 
  3. 이 TestAndSet 명령이 실행되는 동안에는 컨텍스트 스위치가 발생하지 않으므로, **상호 배제(Mutual Exclusion)**를 확실하게 보장할 수 있다. 
  4. 다만, 데드락(Deadlock)이나 기아 상태(Starvation) 문제는 해결하지 못한다. 
2. CompareAndSwap 인스트럭션:
  1. 두 개의 값(예상 값 expected와 새 값 new_value)을 인자로 받아, 특정 메모리 위치의 현재 값이 expected와 같으면 new_value로 교체하고 true를 반환하며, 다르면 교체하지 않고 false를 반환하는 원자적 연산이다. 
  2. 이 연산도 하나의 하드웨어 인스트럭션으로 만들 수 있다. 
  3. **구현 예시**:
  1. int lock = 0; (락 변수 초기화) 
  2. while (CompareAndSwap(&lock, 0, 1) == false); (락이 0이면 1로 바꾸고 진입, 아니면 대기) 
  3. 임계 영역 진입 후 작업 수행 
  4. lock = 0; (임계 영역 사용 완료 후 락 해제) 
  4. CompareAndSwap 역시 원자적으로 실행되므로 상호 배제를 보장한다. 


### 3.3. 자바(Java)에서의 원자 변수 활용 
![image]()
1. **하드웨어 인스트럭션과 소프트웨어 개발**:
  1. 하드웨어 인스트럭션 개발은 컴퓨터 구조 전문가의 영역이므로, 소프트웨어 개발자는 어셈블리어 레벨이 아니라면 직접 신경 쓸 필요는 없다. 
  2. 하지만 Atomic Variable과 같은 도구를 이해하기 위해 하드웨어 인스트럭션의 개념을 알아야 한다. 
2. **자바에서의 피터슨 솔루션 구현**:
  1. 자바에서 피터슨 솔루션을 구현할 때, turn과 flag 변수를 static으로 선언하고, 프로듀서/컨슈머 스레드를 이너 클래스(Inner Class)로 구현한다. 
  2. 프로듀서 스레드와 컨슈머 스레드는 각각 Runnable 인터페이스를 구현하고 run() 메서드 내에서 피터슨 알고리즘 로직을 수행한다. 
  3. **문제점**: 자바에서 구현된 피터슨 솔루션도 1만 번 또는 10만 번 실행 시 count 값이 0이 아닌 비정상적인 결과가 나온다. 
  4. **원인**: 이 역시 엔트리 섹션에서 컨텍스트 스위치가 발생하여 레이스 컨디션이 해결되지 않기 때문이다. 
3. **자바의 원자 변수(Atomic Variable) 사용**:
  1. 자바는 java.util.concurrent.atomic 패키지에서 원자 변수를 제공한다. 
  2. 예를 들어, AtomicBoolean은 내부적으로 하드웨어의 CompareAndSwap과 같은 원자적 연산을 이용하여 구현된다. 
  3. AtomicBoolean을 이용한 피터슨 솔루션 구현:
  1. flag 배열을 AtomicBoolean 타입으로 선언한다 (AtomicBoolean[] flag = new AtomicBoolean;). 
  2. 생성자에서 각 AtomicBoolean 객체를 초기화한다. 
  3. flag 변수에 값을 설정할 때는 flag[i].set(true)와 같이 원자 변수의 set() 메서드를 사용한다. 
  4. 값을 읽을 때는 flag[j].get()과 같이 get() 메서드를 사용한다. 
  5. AtomicBoolean의 get()과 set() 메서드는 내부적으로 원자성을 보장하므로, 읽기/쓰기 작업 중에 컨텍스트 스위치가 발생하여 인터럽트가 걸리는 일이 없다. 
  4. **결과**: AtomicBoolean을 사용하여 구현한 피터슨 솔루션은 10만 번 실행해도 count 값이 항상 0으로 정확하게 나온다. 
  5. 이는 원자 변수가 티키타카 방식의 동기화에서 정확한 결과를 보장함을 의미한다. 
4. **동기화 문제 해결의 핵심 요약**:
  1. **레이스 컨디션(Race Condition)**: 공유 자원(Shared Data)에 여러 프로세스가 동시에 접근하여 경쟁하는 상황이다. 
  2. **임계 영역(Critical Section)**: 공유 자원에 접근하는 코드 영역이다. 
  3. **동기화(Synchronization)**: 임계 영역을 보호하여 레이스 컨디션을 해결하는 것이다. 
  4. **동기화의 세 가지 기본 조건**:
  1. **상호 배제(Mutual Exclusion)**: 동시에 여러 프로세스가 임계 영역에 진입할 수 없어야 한다. 
  2. **진행(Progress)**: 임계 영역에 진입하려는 프로세스가 있다면, 무한정 기다리지 않고 언젠가는 진입할 수 있어야 한다 (데드락 방지). 
  3. **한정 대기(Bounded Waiting)**: 프로세스가 임계 영역에 진입하기 위해 기다리는 시간이 유한해야 한다 (기아 상태 방지). 
  5. **피터슨 솔루션**: flag와 turn 변수를 이용한 티키타카 방식으로 이 세 가지 조건을 모두 만족하는 이론적으로 완벽한 소프트웨어 솔루션이다. 
  6. **하드웨어 지원 도구**: 피터슨 솔루션의 한계를 극복하고 상호 배제를 쉽고 간단하게 해결하기 위해 **뮤텍스(Mutex)**, **세마포어(Semaphore)**, **모니터(Monitor)**와 같은 동기화 도구들이 사용된다. 

