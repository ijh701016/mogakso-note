
## 📌 CPU 스케줄링의 목적은 무엇인가?
CPU 스케줄링은 멀티 프로그래밍 환경에서 CPU 활용률을 높이고, 단위 시간 내 프로세스 완료 수를 늘리며, 프로세스의 대기 시간과 종료까지의 시간을 최소화하여 <mark>시스템의 효율을 극대화하는 것을 목표</mark><mark> </mark>로 합니다. 
##### 💡 CPU 스케줄링 알고리즘의 종류는?
- FCFS (First Come First Served): 먼저 도착한 프로세스를 순서대로 처리합니다. 
- SJF (Shortest Job First): CPU 버스트 타임이 가장 짧은 프로세스를 먼저 처리합니다. 
- 라운드 로빈 (Round Robin): 정해진 시간만큼 CPU를 할당하여 시분할 방식으로 처리합니다. 
- 우선순위 스케줄링: 프로세스에 우선순위를 부여하여 CPU를 할당합니다. 
- 멀티 레벨 큐 스케줄링: 여러 스케줄링 알고리즘을 조합하여 사용합니다. 


이 콘텐츠는 **운영체제의 핵심인 CPU 스케줄링**의 기본 원리를 명확하게 설명합니다. 멀티프로그래밍 환경에서 CPU 활용도를 극대화하고 프로세스 처리 효율을 높이기 위한 스케줄링의 필요성을 이해할 수 있습니다. 특히, 가장 기본적인 스케줄링 알고리즘인 **FCFS(First-Come, First-Served)**와 **SJF(Shortest-Job-First)**의 작동 방식과 각각의 장단점을 구체적인 예시(간트 차트)를 통해 비교 분석하여, 어떤 알고리즘이 더 효율적인지 직관적으로 파악할 수 있습니다. 스케줄링 목표(CPU 활용률, 처리량, 대기 시간, 응답 시간)와 선점형/비선점형 스케줄링의 개념을 함께 다루어, 운영체제가 어떻게 자원을 관리하고 최적화하는지에 대한 **실용적인 통찰**을 얻을 수 있습니다.
## 1. CPU 스케줄링의 개요 및 필요성 
![image]()
1. **CPU 스케줄링의 정의 및 목적** 
  1. **정의**: 멀티 프로그래밍 운영체제에서 여러 프로세스가 동시에 메모리에 로드되어 있을 때, CPU를 어떤 프로세스에 할당할지 결정하는 과정이다. 
  2. **목적**: CPU 활용도를 높이고, 여러 프로세스가 CPU 자원을 공유하여 동시(concurrent)에 실행되도록 하기 위함이다. 
  3. **전제 조건**: CPU의 빠른 속도로 인해 유휴 시간이 발생하므로, 컨텍스트 스위치를 통해 시간을 분할(시분할)하여 CPU 자원을 효율적으로 사용해야 한다. 

2. **프로세스 상태 변화와 CPU/IO 버스트** 
  1. **CPU 버스트**: 프로세스가 CPU를 집중적으로 사용하는 시간이다. (예: 계산, 데이터 처리) 
  2. **IO 버스트**: 프로세스가 입출력(I/O) 작업을 수행하며 대기하는 시간이다. 
  3. **프로세스 상태 변화**: 프로세스는 CPU 버스트 시 '실행(Running)' 상태, IO 버스트 시 '대기(Waiting)' 상태를 오가며, IO 완료 후에는 '준비(Ready)' 상태로 전환된다. 

3. **CPU 버스트 분포 통계** 
  1. **일반적인 경향**: CPU를 적게 사용하고 IO 버스트 시간이 긴 'IO 바운드' 프로세스의 빈도가, CPU를 많이 사용하는 'CPU 바운드' 프로세스보다 훨씬 많다. 
  2. **스케줄링의 중요성**: 이러한 분포를 이해하면 CPU 스케줄링이 왜 필요한지, 그리고 스케줄링을 통해 CPU 효율이 어떻게 향상되는지 파악할 수 있다. 


## 2. CPU 스케줄러의 역할 및 고려사항 
![image]()
1. **CPU 스케줄링 문제 정의** 
  1. **문제**: 메모리에 로드된 프로세스 중 '준비(Ready)' 상태에 있는 프로세스들에게 CPU를 어떻게 할당할 것인가를 결정하는 것이다. 
  2. **난이도**: 문제는 간단해 보이지만, 그 해결책(솔루션)은 복잡하다. 

2. **준비 큐(Ready Queue) 관리** 
  1. **구조**: 대기 중인 프로세스들을 관리하기 위해 연결 리스트(Linked List)나 이진 트리(Binary Tree) 형태의 준비 큐를 사용한다. 
  2. **FIFO 큐**: 가장 기본적인 형태는 선입선출(First In First Out, FIFO) 큐로, 먼저 도착한 프로세스부터 순서대로 CPU를 할당한다. 
  3. **우선순위 큐(Priority Queue)**: 특정 기준(예: 중요도, 긴급성)에 따라 우선순위를 부여하여, 우선순위가 높은 프로세스를 먼저 실행할 수 있도록 한다. 
  1. **과제**: 이 우선순위를 어떻게 결정할 것인지가 중요한 문제가 된다. 


## 3. 선점형(Preemptive) 및 비선점형(Non-preemptive) 스케줄링 
![image]()
1. **선점형(Preemptive) 스케줄링** 
  1. **정의**: 스케줄러가 현재 CPU를 사용 중인 프로세스를 강제로 중단시키고 다른 프로세스에게 CPU를 할당할 수 있는 방식이다. 
  2. **특징**: 운영체제가 프로세스의 CPU 사용을 제어할 수 있어 유연한 자원 관리가 가능하다. 

2. **비선점형(Non-preemptive) 스케줄링** 
  1. **정의**: 일단 CPU를 할당받은 프로세스는 스스로 CPU를 반납하거나(자발적 종료/대기) 작업이 완료될 때까지 CPU를 계속 사용하는 방식이다. 
  2. **특징**: 스케줄러가 강제로 CPU를 회수할 수 없다. 

3. **CPU 스케줄링 결정 시점 (4가지 경우)** 
  1. **실행(Running) → 대기(Waiting)**: 프로세스가 I/O 작업을 위해 자발적으로 CPU를 반납하고 대기 상태로 전환되는 경우이다. 
  2. **실행(Running) → 준비(Ready)**: 프로세스가 실행 중 특정 이벤트(예: 시간 할당량 소진)로 인해 CPU를 반납하고 준비 상태로 전환되는 경우이다. 
  3. **대기(Waiting) → 준비(Ready)**: I/O 작업이 완료된 프로세스가 다시 CPU를 할당받기 위해 준비 상태로 전환되는 경우이다. 
  4. **실행(Running) → 종료(Terminated)**: 프로세스가 작업을 완료하고 시스템에서 제거되는 경우이다. 

4. **선점/비선점 스케줄링의 적용** 
  1. **비선점형 적용 경우**: 프로세스가 자발적으로 CPU를 반납하는 경우(1번: 실행→대기, 4번: 실행→종료)에는 비선점형 스케줄링이 적용된다. 
  2. **선점형 고려 경우**: 프로세스가 강제로 CPU를 빼앗기거나(2번: 실행→준비) 대기 상태에서 준비 상태로 전환된 프로세스가 더 높은 우선순위로 CPU를 선점할 수 있는 경우(3번: 대기→준비)에는 선점형 스케줄링을 고려해야 한다. 
  3. **현대 운영체제**: 대부분의 현대 운영체제는 더 나은 효율과 응답성을 위해 선점형 스케줄링을 채택한다. 


## 4. 디스패처(Dispatcher)의 역할 및 디스패치 지연 시간 
![image]()
1. **디스패처의 정의 및 역할** 
  1. **정의**: 스케줄러가 선택한 프로세스에게 CPU 제어권을 넘겨주는 모듈이다. 
  2. **주요 역할**:
  1. 하나의 프로세스에서 다른 프로세스로 **컨텍스트 스위치**를 수행한다. 
  2. 사용자 모드(User Mode)로 전환한다. 
  3. 새로운 프로세스의 적절한 실행 위치로 재시작(resume)시킨다. 
  3. **스케줄러와의 관계**: 스케줄러가 어떤 프로세스를 실행할지 '선택'한다면, 디스패처는 실제로 CPU 제어권을 '전환'하는 역할을 한다. 

2. **디스패치 지연 시간(Dispatch Latency)** 
  1. **정의**: 하나의 프로세스 컨텍스트를 저장하고 다른 프로세스 컨텍스트를 복원하는 데 걸리는 시간이다. 
  2. **문제점**: 이 지연 시간이 CPU 사용 시간보다 길어지면, CPU가 실제 작업을 하는 시간보다 컨텍스트 스위치에 더 많은 시간을 소모하게 되어 시스템 효율이 저하된다. 
  3. **중요성**: 디스패치 지연 시간은 가급적 짧아야 한다. 

3. **컨텍스트 스위치 확인 명령어 (vmstat)** 
  1. vmstat 명령어: vmstat t n (t초 간격으로 n번 확인) 명령어를 통해 초당 컨텍스트 스위치 발생 횟수를 확인할 수 있다. 
  2. /proc/self/status 파일: cat /proc/self/status 명령어를 통해 자발적(Voluntary) 및 비자발적(Non-Voluntary) 컨텍스트 스위치 횟수를 확인할 수 있다. 
  1. **자발적 컨텍스트 스위치**: 프로세스가 스스로 CPU를 반납하는 경우(비선점형). 
  2. **비자발적 컨텍스트 스위치**: 스케줄러에 의해 강제로 CPU를 빼앗기는 경우(선점형). 


## 5. CPU 스케줄링의 목표 
![image]()
1. **CPU 활용률(CPU Utilization) 극대화** 
  1. **목표**: CPU가 가능한 한 쉬지 않고 작동하도록 하여, CPU의 사용률을 최대로 높이는 것이다. 

2. **처리량(Throughput) 극대화** 
  1. **목표**: 단위 시간당 완료되는 프로세스의 수를 최대로 늘리는 것이다. 
  2. **의미**: CPU가 얼마나 많은 작업을 성공적으로 완료했는지를 나타낸다. 

3. **반환 시간(Turnaround Time) 최소화** 
  1. **목표**: 프로세스가 시스템에 제출된 시점부터 실행을 완료하고 종료될 때까지 걸리는 총 시간을 최소화하는 것이다. 
  2. **의미**: 프로세스 전체 생애 주기의 효율성을 나타낸다. 

4. **대기 시간(Waiting Time) 최소화** 
  1. **목표**: 프로세스가 준비 큐(Ready Queue)에서 CPU 할당을 기다리는 시간을 최소화하는 것이다. 
  2. **중요성**: 대기 시간을 최소화하면 시스템 효율이 높아지고, 반환 시간 및 CPU 활용률도 개선된다. 

5. **응답 시간(Response Time) 최소화** 
  1. **목표**: 프로세스가 요청을 제출한 시점부터 첫 번째 응답을 받기까지 걸리는 시간을 최소화하는 것이다. 
  2. **적용 분야**: 주로 사용자 인터페이스(UI)나 실시간 시스템(예: 게임)과 같이 사용자의 즉각적인 반응이 중요한 시스템에서 중요하게 고려된다. 
  3. **주요 고려 사항**: 대기 시간과 함께 반환 시간을 중요하게 고려한다. 


## 6. 주요 CPU 스케줄링 알고리즘 소개 
![image]()
1. **CPU 스케줄링 문제의 핵심** 
  1. **문제**: 준비 큐에 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정하는 것이다. 
  2. **목표**: 이 문제를 해결하여 시스템의 효율성을 높이는 것이다. 

2. **FCFS (First-Come, First-Served)** 
  1. **원리**: 가장 먼저 도착한 프로세스에게 CPU를 먼저 할당하는 방식이다. 
  2. **특징**: 구현이 매우 간단하고 공평해 보이지만, 여러 문제점을 가지고 있다. 
  3. **역사**: PC 초창기 운영체제에서 사용되었던 방식이다. 

3. **SJF (Shortest-Job-First)** 
  1. **원리**: CPU 버스트 시간이 가장 짧은 프로세스에게 CPU를 먼저 할당하는 방식이다. 
  2. **변형**: 남은 실행 시간이 가장 짧은 프로세스를 먼저 처리하는 'Shortest-Remaining-Time-First (SRTF)'와 같은 선점형/비선점형 방식에 따라 달라진다. 
  3. **FCFS와의 차이**: FCFS와 SJF는 프로세스 전체 실행 시간을 한 번에 할당하는 방식이다. 

4. **라운드 로빈 (Round Robin, RR)** 
  1. **원리**: 시분할(Time Sharing) 방식을 사용하여, 각 프로세스에게 정해진 시간 할당량(Time Quantum)만큼 CPU를 번갈아 할당하는 방식이다. 
  2. **특징**: 현대 컴퓨터 운영체제에서 널리 사용되는 방식이다. 

5. **우선순위 스케줄링 (Priority Scheduling)** 
  1. **원리**: 다음 CPU를 할당할 프로세스를 선택할 때, 우선순위를 부여하여 우선순위가 높은 프로세스를 먼저 실행하는 방식이다. 
  2. **적용**: 라운드 로빈과 결합하여 사용될 수 있다. 

6. **멀티레벨 큐 및 피드백 큐 (Multi-level Queue & Feedback Queue)** 
  1. **멀티레벨 큐**: 여러 개의 준비 큐를 사용하여 프로세스의 특성(예: 대화형, 배치)에 따라 다른 스케줄링 알고리즘을 적용하는 방식이다. 
  2. **멀티레벨 피드백 큐**: 프로세스의 동작에 따라 큐 간 이동(피드백)을 허용하여, 더욱 동적이고 유연한 스케줄링을 제공하는 현대적인 스케줄러의 형태이다. 


## 7. FCFS (First-Come, First-Served) 알고리즘 상세 분석 
![image]()
1. **FCFS의 기본 원리** 
  1. **가장 간단한 알고리즘**: CPU 스케줄링 알고리즘 중 가장 구현하기 쉽다. 
  2. **작동 방식**: CPU를 먼저 요청한 프로세스에게 무조건 CPU를 배정한다. 
  3. **구현**: FIFO 큐를 사용하여 프로세스가 도착하면 큐에 넣고, CPU가 비면 큐에서 빼내어 실행시킨다. 
  4. **비선점형**: FCFS 알고리즘은 프로세스가 CPU를 선점하면 작업이 끝날 때까지 CPU를 놓지 않는 **비선점형(Non-preemptive)** 방식이다. 

2. **FCFS 성능 분석 (간트 차트 예시)** 
  1. **예시 상황**: P1, P2, P3 세 프로세스가 동시에(시간 0에) 도착하고, CPU 버스트 타임은 각각 P1=24, P2=3, P3=3이라고 가정한다. 
  2. **실행 순서 (P1, P2, P3)** 
  1. P1이 먼저 실행되어 24초에 완료된다. 
  2. P2가 이어서 실행되어 24+3=27초에 완료된다. 
  3. P3가 이어서 실행되어 27+3=30초에 완료된다. 
  3. **대기 시간(Waiting Time) 계산** 
  1. P1: 0초 (바로 실행) 
  2. P2: 24초 (P1이 끝날 때까지 대기) 
  3. P3: 27초 (P1, P2가 끝날 때까지 대기) 
  4. **총 대기 시간**: 0 + 24 + 27 = 51초 
  5. **평균 대기 시간**: 51초 / 3개 프로세스 = <mark>17초</mark> 

3. **FCFS 순서 변경에 따른 성능 변화** 
  1. **순서 변경 (P2, P3, P1)** 
  1. P2가 먼저 실행되어 3초에 완료된다. 
  2. P3가 이어서 실행되어 3+3=6초에 완료된다. 
  3. P1이 이어서 실행되어 6+24=30초에 완료된다. 
  2. **대기 시간(Waiting Time) 계산** 
  1. P2: 0초 
  2. P3: 3초 
  3. P1: 6초 
  4. **총 대기 시간**: 0 + 3 + 6 = 9초 
  5. **평균 대기 시간**: 9초 / 3개 프로세스 = <mark>3초</mark> 
  3. **결론**: 프로세스 도착 순서만 바뀌었을 뿐인데, 평균 대기 시간이 17초에서 3초로 크게 줄어든다. 

4. **FCFS 반환 시간(Turnaround Time) 계산** 
  1. **정의**: 프로세스가 제출된 시점부터 종료될 때까지의 총 시간이다. 
  2. **실행 순서 (P1, P2, P3) 기준** 
  1. P1: 24초 (0초 시작, 24초 종료) 
  2. P2: 27초 (0초 시작, 27초 종료) 
  3. P3: 30초 (0초 시작, 30초 종료) 
  4. **총 반환 시간**: 24 + 27 + 30 = 81초 
  5. **평균 반환 시간**: 81초 / 3개 프로세스 = <mark>27초</mark> 
  3. **순서 변경 시**: P2, P3, P1 순서로 실행될 때의 반환 시간도 계산해 볼 수 있다. 

5. **FCFS의 문제점: 비최적성 및 호위 효과(Convoy Effect)** 
  1. **비최적성**: FCFS는 평균 대기 시간을 최소화하지 못하는 비최적(not minimal) 알고리즘이다. 
  1. 프로세스의 CPU 버스트 타임 길이에 따라 대기 시간과 반환 시간이 크게 달라진다. 
  2. **호위 효과(Convoy Effect)** 
  1. **현상**: CPU를 오래 사용하는 'CPU 바운드' 프로세스(Pmax)가 먼저 도착하면, 뒤에 도착하는 짧은 'IO 바운드' 프로세스(Pmin)들이 Pmax가 끝날 때까지 불필요하게 오래 대기하게 되는 현상이다. 
  2. **비유**: 느린 똥차 한 대가 고속도로의 모든 스포츠카들을 막아버리는 것과 같다. 
  3. **결론**: 호위 효과로 인해 FCFS는 좋은 효율을 얻기 어렵다. 


## 8. SJF (Shortest-Job-First) 알고리즘 상세 분석 
![image]()
1. **SJF의 기본 원리** 
  1. **목표**: 가장 짧은 CPU 버스트 타임을 가진 프로세스를 먼저 스케줄링하여 효율을 높이는 것이다. 
  2. **작동 방식**: CPU가 사용 가능할 때, 다음 CPU 버스트 타임이 가장 짧은 프로세스를 선택하여 할당한다. 
  3. **동일 버스트 타임**: 만약 여러 프로세스의 CPU 버스트 타임이 같다면 FCFS 방식을 따른다. 

2. **SJF 성능 분석 (간트 차트 예시)** 
  1. **예시 상황**: P1, P2, P3, P4 네 프로세스가 도착하고, CPU 버스트 타임은 각각 P1=6, P2=8, P3=7, P4=3이라고 가정한다. 
  2. **실행 순서 (SJF)** 
  1. 가장 짧은 P4(3초)가 먼저 실행되어 3초에 완료된다. 
  2. 다음으로 짧은 P1(6초)이 실행되어 3+6=9초에 완료된다. 
  3. 다음으로 짧은 P3(7초)이 실행되어 9+7=16초에 완료된다. 
  4. 마지막으로 P2(8초)가 실행되어 16+8=24초에 완료된다. 
  5. 이 순서에 따라 간트 차트가 결정된다. 
  3. **대기 시간(Waiting Time) 계산** 
  1. P1: 3초 (P4가 끝날 때까지 대기) 
  2. P2: 16초 (P4, P1, P3가 끝날 때까지 대기) 
  3. P3: 9초 (P4, P1이 끝날 때까지 대기) 
  4. P4: 0초 (바로 실행) 
  5. **총 대기 시간**: 3 + 16 + 9 + 0 = 28초 
  6. **평균 대기 시간**: 28초 / 4개 프로세스 = <mark>7초</mark> 
  7. **FCFS와의 비교**: FCFS의 17초보다 훨씬 빨라졌다. 
  4. **반환 시간(Turnaround Time) 계산** 
  1. P1: 9초 (0초 시작, 9초 종료) 
  2. P2: 24초 (0초 시작, 24초 종료) 
  3. P3: 16초 (0초 시작, 16초 종료) 
  4. P4: 3초 (0초 시작, 3초 종료) 
  5. **총 반환 시간**: 9 + 24 + 16 + 3 = 52초 
  6. **평균 반환 시간**: 52초 / 4개 프로세스 = <mark>13초</mark> 

3. **SJF의 장점** 
  1. **효율성**: FCFS에 비해 대기 시간과 반환 시간을 훨씬 더 줄일 수 있다. 
  2. **최적성**: 주어진 프로세스 집합에 대해 평균 대기 시간을 최소화하는 최적(optimal) 알고리즘이다. 

