
## 📌 SRTF 스케줄링 알고리즘은 무엇인가요?
SRTF(Shortest Remaining Time First)는 <mark>선점형 스케줄링 방식으로, 새로 도착한 프로세스의 CPU 버스트 타임이 현재 실행 중인 프로세스의 남은 시간보다 짧으면 현재 프로세스를 중단하고 새로운 프로세스를 먼저 실행하는 알고리즘</mark><mark> </mark>입니다 
##### 💡 SRTF와 유사한 SJF 스케줄링 알고리즘과의 차이점은 무엇인가요?
SJF(Shortest Job First)는 CPU 버스트를 모두 마칠 때까지 기다려주는 비선점형 방식인 반면, SRTF는 더 짧은 작업이 도착하면 기다리지 않고 현재 작업을 중단하고 선점하는 방식입니다 


운영체제의 핵심인 **CPU 스케줄링 알고리즘**을 깊이 있게 탐구하는 콘텐츠입니다. 단순히 이론을 나열하는 것을 넘어, **SRTF, Round-Robin, Priority 스케줄링** 같은 복잡한 개념들이 실제 시스템에서 어떻게 작동하고 어떤 한계를 가지는지 구체적인 예시와 함께 설명합니다. 특히, SJF의 이론적 최적성과 실제 구현의 어려움, Round-Robin의 타임 퀀텀 설정 중요성, 그리고 우선순위 스케줄링에서 발생할 수 있는 **기아(Starvation) 문제**와 해결책인 에이징 기법까지 다룹니다. 이 콘텐츠를 통해 여러분은 다양한 스케줄링 기법의 장단점을 명확히 이해하고, 실제 운영체제가 어떻게 **자원 효율성과 사용자 경험** 사이의 균형을 맞추는지에 대한 깊이 있는 통찰을 얻을 수 있습니다.
## 1. 스케줄링 알고리즘 개요 및 SJF의 한계 


### 1.1. SJF (Shortest Job First) 스케줄링의 최적성과 구현의 어려움 
![image]()
1. **SJF의 최적성**:
  1. SJF는 **평균 대기 시간(Average Waiting Time)** 측면에서 최적의 솔루션이다. 
  2. 긴 프로세스보다 짧은 프로세스를 먼저 실행하면, 짧은 프로세스의 대기 시간 향상이 긴 프로세스의 대기 시간 증가보다 크기 때문에 평균 대기 시간이 감소한다. 

2. **SJF 구현의 어려움**:
  1. SJF는 이론적으로 최적이지만, 실제 시스템에서 구현하기 어렵다. 
  2. 그 이유는 다음 CPU 버스트 타임(Next CPU Burst Time)을 미리 알 수 없기 때문이다. 
  3. 프로그램이 얼마나 길게 CPU를 사용할지 예측하는 것은 불가능하다. 


### 1.2. 다음 CPU 버스트 타임 예측 방법 
![image]()
1. **예측의 필요성**:
  1. SJF를 엄격하게 적용할 수 없으므로, **다음 CPU 버스트 타임**을 예측하는 방법을 사용한다. 
  2. 과거의 CPU 사용 기록을 통해 미래를 예측하는 방식이다. 

2. **지수적 평균(Exponential Average) 방법**:
  1. 과거의 측정된 CPU 버스트 타임 값을 기반으로 지수적 평균을 계산한다. 
  2. 과거 기록을 길게 보되, 최근 사용량에 더 큰 가중치를 부여하여 예측한다. 
  3. **수식**: <mark>τ(n+1) = α</mark><em>t(n) + (1 - α) </em><mark>τ(n)</mark> 
  - <mark>τ(n+1)</mark>: 이번에 사용할 CPU 버스트 타임에 대한 예측 값 
  - <mark>t(n)</mark>: n번째 CPU 버스트 타임 
  - <mark>α</mark>: 0에서 1 사이의 가중치 파라미터 
  4. **예시**:
  - 초기 τ(0) = 10, α = 0.5일 때, t(n) 값에 따라 τ(n+1) 값이 변화한다. 
  - τ 값은 실제 CPU 버스트 타임의 평균선 역할을 한다. 
  5. **α 값의 영향**:
  - <mark>α = 1</mark>이면 완전히 최근 것만 쳐다본다. 
  - <mark>α = 0</mark>이면 완전히 과거만 쳐다본다. 
  - <mark>α = 0.5</mark>또는 <mark>0.2</mark>정도를 주어 예측하는 것이 좋다. 

3. **예측의 한계**:
  1. CPU 버스트 타임을 수백 시간 동안 기록하고 계산하는 것은 쉽지 않다. 
  2. 따라서 SJF는 이론적으로 최적이지만, 실제 운영체제에서 직접 사용하는 알고리즘은 아니다. 


## 2. SRTF (Shortest Remaining Time First) 스케줄링 


### 2.1. 선점형(Preemptive)과 비선점형(Non-preemptive) 스케줄링 
![image]()
1. **선점형 스케줄링**:
  1. 새로운 프로세스가 도착했을 때, 현재 실행 중인 프로세스의 남은 시간보다 새로 도착한 프로세스의 CPU 버스트 타임이 더 짧으면, 현재 프로세스를 중단시키고 새로운 프로세스를 실행하는 방식이다. 
  2. **컨텍스트 스위치**가 발생하여 현재 프로세스는 레디 큐로 돌아가고, 새로운 프로세스가 CPU를 할당받는다. 
  3. **장점**: 짧은 프로세스가 즉시 실행될 수 있어 전체 대기 시간을 줄이는 데 유리하다. 

2. **비선점형 스케줄링**:
  1. 현재 실행 중인 프로세스가 작업을 완료할 때까지 기다린 후, 다음 프로세스를 실행하는 방식이다. 
  2. 컨텍스트 스위치가 발생하지 않는다. 

3. **선점형의 효율성**:
  1. SJF의 원리처럼 짧은 것을 먼저 실행하면 대기 시간이 줄어들기 때문에, 선점형이 더 유리하다. 
  2. 하지만, 새로운 프로세스가 들어올 때마다 남은 CPU 버스트 타임을 아는 것이 쉽지 않다는 한계가 있다. 


### 2.2. SRTF (Shortest Remaining Time First)의 개념 
![image]()
1. **정의**:
  1. **SRTF**는 **선점형 SJF** 스케줄링이다. 
  2. 현재 실행 중인 프로세스의 남은 시간(Remaining Time)보다 새로 도착한 프로세스의 CPU 버스트 타임이 더 짧으면, 현재 프로세스를 선점(preempt)하여 쫓아내고 새로운 프로세스를 실행한다. 

2. **SRTF와 비선점형 SJF의 차이**:
  1. **비선점형 SJF**: 현재 CPU 버스트를 모두 마칠 때까지 기다린다. 
  2. **SRTF**: 기다리지 않고 더 짧은 프로세스가 도착하면 즉시 선점한다. 


### 2.3. SRTF 스케줄링 예시 및 성능 비교 
![image]()
1. **예시 시나리오**:
  1. 도착 시간(Arrival Time)과 버스트 타임(Burst Time)이 다른 여러 프로세스(P0, P1, P2, P3, P4)가 존재한다. 
  2. 레디 큐에 아무것도 없을 때 P0가 0초에 도착하여 실행된다. 
  3. **1초 시점**: P1이 도착하고, P0의 남은 시간(7)보다 P1의 버스트 타임(4)이 짧으므로 P1이 P0를 선점하여 실행된다. 
  4. **2초 시점**: P2가 도착하고, P1의 남은 시간(3)보다 P2의 버스트 타임(5)이 길므로 P1이 계속 실행된다. 
  5. **3초 시점**: P3가 도착하고, P1의 남은 시간(2)보다 P3의 버스트 타임(5)이 길므로 P1이 계속 실행된다. 
  6. P1이 종료된 후, 남은 프로세스(P0, P2, P3) 중 가장 짧은 P3가 실행된다. 
  7. 이러한 방식으로 남은 시간을 계속 계산하여 더 짧은 프로세스가 도착하면 선점한다. 

2. **성능 계산**:
  1. 위 간트 차트를 기반으로 총 대기 시간(Total Waiting Time)을 계산하면 26이 된다. 
  2. 평균 대기 시간(Average Waiting Time)은 26/4 = <mark>6.5분</mark>이다. 

3. **SJF와의 비교**:
  1. 비선점형 SJF의 평균 대기 시간은 <mark>7.3분</mark>으로, SRTF의 <mark>6.5분</mark>보다 길다. 
  2. SRTF는 도착 즉시 선점이 가능하므로 비선점형 SJF보다 효율적이다. 
  3. 따라서 SRTF는 최적의 스케줄링 알고리즘 중 하나로 간주될 수 있다. 


## 3. 라운드 로빈 (Round-Robin) 스케줄링 


### 3.1. 라운드 로빈의 개념 및 작동 방식 
![image]()
1. **필요성**:
  1. CPU를 한 프로세스가 독점하여 끝까지 실행하는 방식은 **타임 쉐어링(Time Sharing)** 시스템에 부적합하다. 
  2. 예를 들어, 게임 중 CPU를 독점하면 사용자 인터페이스 반응이 느려진다. 

2. **정의**:
  1. **라운드 로빈(Round-Robin)** 스케줄링은 **선점형 FCFS(First-Come, First-Served)** 방식이다. 
  2. CPU 시간을 **타임 퀀텀(Time Quantum)** 또는 **타임 슬라이스(Time Slice)**라는 작은 단위로 나누어 각 프로세스에 할당한다. 
  3. 프로세스는 할당된 타임 퀀텀 동안만 실행되고, 시간이 끝나면 강제로 CPU를 반납하고 레디 큐의 맨 뒤로 이동한다. 

3. **구현**:
  1. 레디 큐는 **원형 큐(Circular Queue)** 형태로 구현하여 프로세스들이 순환하며 CPU를 할당받도록 한다. 
  2. 타임 퀀텀은 보통 <mark>10밀리초</mark>에서 <mark>100밀리초</mark>정도로 설정된다. 


### 3.2. 라운드 로빈의 프로세스 처리 
![image]()
1. **CPU 버스트 타임과 타임 퀀텀의 관계**:
  1. **프로세스의 CPU 버스트 타임이 타임 퀀텀보다 짧은 경우**:
  - 프로세스는 타임 퀀텀이 끝나기 전에 자발적으로 CPU를 반납하고 종료된다. 
  2. **프로세스의 CPU 버스트 타임이 타임 퀀텀보다 긴 경우**:
  - 타임 퀀텀이 끝나면 **타이머 인터럽트**가 발생하여 프로세스는 강제로 CPU를 반납한다. 
  - **컨텍스트 스위치**가 발생하고, 프로세스는 레디 큐의 맨 뒤로 이동하여 다음 차례를 기다린다. 
  - 사용자 입장에서는 프로세스가 계속 실행되는 것처럼 보인다. 


### 3.3. 라운드 로빈 스케줄링 예시 및 성능 분석 
![image]()
1. **예시 시나리오**:
  1. P1(24), P2(3), P3(3) 세 프로세스가 있고, 타임 퀀텀이 <mark>4</mark>라고 가정한다. 
  2. **P1**: 4초 실행 후 레디 큐로 이동 (남은 시간 20) 
  3. **P2**: 3초 실행 후 종료 (타임 퀀텀보다 짧으므로) 
  4. **P3**: 3초 실행 후 종료 (타임 퀀텀보다 짧으므로) 
  5. **P1**: 다시 CPU를 할당받아 남은 시간(20)을 계속 실행한다. 

2. **성능 계산**:
  1. 위 예시에서 P1, P2, P3의 대기 시간을 계산하면 총 17이 된다. 
  2. 평균 대기 시간은 17/3 = <mark>5.67</mark>이다. 
  3. 라운드 로빈은 FCFS보다 평균 대기 시간이 길어질 수도 있지만, SJF 등 다른 알고리즘과 결합하여 유용하게 사용된다. 

3. **타임 퀀텀 크기의 중요성**:
  1. **타임 퀀텀이 너무 큰 경우**:
  - 모든 프로세스가 한 번에 CPU를 획득하면 끝까지 실행하게 되어 FCFS와 유사해진다. 
  - 컨텍스트 스위치 횟수가 줄어들지만, 타임 쉐어링의 이점을 잃는다. 
  2. **타임 퀀텀이 너무 작은 경우**:
  - 컨텍스트 스위치가 너무 자주 발생하여 **오버헤드**가 커진다. 
  - 실제 프로세스 실행 시간보다 컨텍스트 스위치에 소요되는 시간이 더 많아져 시스템 성능이 저하된다. 
  3. **적절한 타임 퀀텀**:
  - 시스템의 연산 특성과 벤치마킹을 통해 적절한 타임 퀀텀 크기를 결정해야 한다. 
  - 턴어라운드 타임(Turnaround Time) 또한 타임 퀀텀 크기에 따라 변동하므로, 최적의 값을 찾아야 한다. 


## 4. 우선순위 (Priority) 스케줄링 


### 4.1. 우선순위 스케줄링의 기본 개념 
![image]()
1. **정의**:
  1. 레디 큐에 있는 프로세스들에게 **우선순위(Priority)**를 부여하여, 우선순위가 높은 프로세스에게 먼저 CPU를 할당하는 방식이다. 
  2. 우선순위가 동일한 프로세스들은 FCFS 방식으로 처리된다. 

2. **SJF와의 관계**:
  1. SJF는 사실상 우선순위 스케줄링의 한 형태이다. 
  2. 다음 CPU 버스트 타임이 짧을수록 우선순위가 높아지는 방식으로 볼 수 있다. 
  3. 책에서는 숫자가 작을수록 우선순위가 높은 것으로 가정한다. 

3. **예시 시나리오**:
  1. P1(10, 우선순위 3), P2(1, 우선순위 1), P3(2, 우선순위 4), P4(1, 우선순위 5), P5(5, 우선순위 2) 프로세스가 있다. 
  2. **P2 (우선순위 1)**: 가장 먼저 실행되어 1초 후 종료. 
  3. **P5 (우선순위 2)**: 다음으로 실행되어 5초 후 종료. 
  4. **P1 (우선순위 3)**: 다음으로 실행되어 10초 후 종료. 
  5. **P3 (우선순위 4)**: 다음으로 실행되어 2초 후 종료. 
  6. **P4 (우선순위 5)**: 마지막으로 실행되어 1초 후 종료. 
  7. 이러한 방식으로 평균 대기 시간과 턴어라운드 타임을 계산할 수 있다. 

4. **선점형과 비선점형**:
  1. 우선순위 스케줄링도 선점형(예: SRTF)과 비선점형(예: SJF)으로 나눌 수 있다. 


### 4.2. 기아(Starvation) 문제와 에이징(Aging) 기법 
![image]()
1. **기아(Starvation) 문제**:
  1. 우선순위 스케줄링에서 **낮은 우선순위**를 가진 프로세스는 계속해서 높은 우선순위의 프로세스에 밀려 CPU를 할당받지 못하고 무한정 대기할 수 있다. 
  2. 이를 **기아(Starvation)** 또는 **무한 대기(Indefinite Postponement)**라고 한다. 

2. **에이징(Aging) 기법**:
  1. 기아 문제를 해결하기 위한 방법으로, 프로세스가 시스템에 오래 대기할수록 **점진적으로 우선순위를 높여주는** 기법이다. 
  2. 이를 통해 아무리 낮은 우선순위의 프로세스라도 결국 CPU를 할당받을 기회를 얻게 된다. 
  3. 선점형 우선순위 스케줄링에서 기아 문제가 발생할 수 있으므로, 에이징과 같은 해결책이 필요하다. 


### 4.3. 멀티레벨 큐 (Multi-Level Queue) 스케줄링 
![image]()
1. **라운드 로빈과 우선순위 스케줄링의 결합**:
  1. 실제 운영체제에서는 라운드 로빈과 우선순위 스케줄링을 단독으로 사용하기보다 **혼합하여 사용**한다. 
  2. 가장 높은 우선순위의 프로세스를 먼저 실행하되, 동일한 우선순위를 가진 프로세스들 사이에서는 라운드 로빈 방식으로 스케줄링한다. 

2. **멀티레벨 큐의 개념**:
  1. 프로세스들을 여러 그룹으로 나누고, 각 그룹에 **다른 우선순위**와 **스케줄링 알고리즘**을 부여하는 방식이다. 
  2. 예를 들어, 스마트폰에서는 전화 신호 처리, 사운드, 디스플레이, 네트워크 데이터 처리 등 다양한 프로세스들이 각기 다른 우선순위를 가진다. 
  3. 각 우선순위 레벨마다 별도의 레디 큐를 둔다. 
  4. **큐의 예시**:
  - 실시간 프로세스(Real-time Process) 큐 (가장 높은 우선순위) 
  - 시스템 프로세스(System Process) 큐 
  - 대화형 프로세스(Interactive Process) 큐 
  - 배치 프로세스(Batch Process) 큐 (가장 낮은 우선순위) 
  5. 각 큐 내에서는 FCFS, 라운드 로빈 등 적절한 스케줄링 알고리즘을 적용할 수 있다. 

3. **멀티레벨 피드백 큐 (Multi-Level Feedback Queue, MLFQ)**:
  1. 멀티레벨 큐의 문제점은 낮은 우선순위 큐의 프로세스가 **기아 상태**에 빠질 수 있다는 것이다. 
  2. 이를 해결하기 위해 **에이징 기법**을 적용한 것이 멀티레벨 피드백 큐이다. 
  3. **작동 방식**:
  - 가장 높은 우선순위 큐에 들어온 프로세스에게는 짧은 타임 퀀텀(예: 8)을 부여한다. 
  - 이 시간 안에 작업을 마치지 못하면 다음 우선순위 큐로 이동하고, 더 긴 타임 퀀텀(예: 16)을 부여받는다. 
  - 가장 낮은 우선순위 큐에서는 FCFS 방식으로 남은 작업을 모두 실행할 수 있다. 
  4. **장점**:
  - CPU를 적게 쓰는 프로세스(I/O 바운드)는 높은 우선순위 큐에서 빠르게 처리되어 자주 CPU를 할당받을 기회를 얻는다. 
  - CPU를 많이 쓰는 프로세스(CPU 바운드)는 점차 낮은 우선순위 큐로 이동하며 더 많은 CPU 시간을 할당받게 된다. 
  5. MLFQ는 실제 운영체제(OS)의 CPU 스케줄링 알고리즘으로 사용된다. 


## 5. 스레드 스케줄링 및 실시간 운영체제 


### 5.1. 스레드 스케줄링 
![image]()
1. **현대 컴퓨터의 스케줄링 대상**:
  1. 현대 컴퓨터에서는 프로세스 스케줄링 대신 **스레드 스케줄링**을 수행한다. 
  2. 이전까지 학습한 내용은 프로세스를 대상으로 했지만, 실제로는 스레드에 적용된다고 이해하면 된다. 

2. **스레드의 종류**:
  1. **유저 스레드(User Thread)**: 유저 레벨 라이브러리가 관리하며, 커널은 유저 스레드의 존재를 알지 못한다. 
  2. **커널 스레드(Kernel Thread)**: 커널이 직접 관리하고 스케줄링하는 대상이다. 

3. **스케줄링 대상**:
  1. 운영체제 커널은 CPU 스케줄링을 **커널 스레드**를 대상으로 수행한다. 
  2. 유저 스레드는 커널 스레드에 매핑되어 서비스된다 (예: Many-to-Many 모델). 


### 5.2. 실시간 운영체제 (Real-Time Operating System, RTOS) 
![image]()
1. **정의**:
  1. **실시간 운영체제**는 주어진 시간 내에 특정 태스크를 반드시 완료할 수 있도록 보장하는 운영체제이다. 
  2. 일반적인 운영체제(Windows, Linux, Android 등)는 실시간 운영체제가 아니다. 

2. **실시간 운영체제의 종류**:
  1. **소프트 리얼타임 (Soft Real-Time)**:
  - 크리티컬한 실시간 프로세스가 반드시 시간 안에 끝나야 하지만, 약간의 지연은 허용된다. 
  - 비크리티컬 프로세스보다 더 빨리 실행되도록 보장한다. 
  - **예시**: 스마트폰 통화 시 RF 신호 처리 및 음성 변환. 0.1초 안에 처리해야 하지만, 0.1001초에 처리되어 말이 약간 끊겨도 사용자가 이해하는 데 큰 문제가 없다. 
  2. **하드 리얼타임 (Hard Real-Time)**:
  - 어떤 태스크든 **반드시 정해진 데드라인 안에 실행**되어야 한다. 
  - 단 1초라도 지연되면 치명적인 결과를 초래할 수 있다. 
  - **예시**: 로켓 제어 시스템. 0.1초의 오차로 인해 로켓의 궤도가 완전히 달라질 수 있다. 

3. **스케줄러의 역할**:
  1. 실시간 스케줄러는 우선순위(Priority)를 기반으로 작동해야 한다. 
  2. **우선순위 역전(Priority Inversion)** 현상과 같은 문제 발생 가능성이 있으며, 이는 과거 달 탐사 로켓 실패 사례에서 나타난 바 있다. 


## 6. 스케줄링 알고리즘 연습 문제 
![image]()
1. **연습 문제의 중요성**:
  1. 제공된 테이블(도착 시간, 버스트 타임 등)을 활용하여 다양한 스케줄링 알고리즘의 성능을 직접 계산해보는 것이 중요하다. 
  2. **계산 항목**: 평균 턴어라운드 타임, 평균 대기 시간 등. 

2. **다양한 알고리즘 적용**:
  1. FCFS, SJF, SRTF, 라운드 로빈, 라운드 로빈과 SRTF 혼합 등 여러 알고리즘을 적용하여 계산한다. 

3. **미래 예측 스케줄링 (Future Knowledge Scheduling)**:
  1. 만약 미래를 알고 있다면(예: P1이 실행 중일 때 P2가 도착할 것을 미리 안다면), P1을 기다리게 하고 P2를 먼저 실행하는 등의 최적화된 스케줄링이 가능하다. 
  2. 이러한 미래 예측은 **프로파일링(Profiling)**을 통해 과거 데이터를 기반으로 추정할 수 있다. 
  3. 이러한 문제들을 직접 풀어보면서 스케줄링 알고리즘에 대한 이해를 높일 수 있다. 

