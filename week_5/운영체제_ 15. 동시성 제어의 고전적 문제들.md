
## 📌 운영체제에서 동시성 제어의 고전적 문제들은 무엇인가?
운영체제에서 동시성 제어의 고전적 문제들은 <mark>생산자-소비자 문제, 읽기-쓰기 문제, 그리고 철학자들의 저녁 식사 문제</mark><mark> </mark>입니다 
##### 💡 생산자-소비자 문제와 읽기-쓰기 문제의 핵심 내용은 무엇인가?
- 생산자-소비자 문제: 생산자가 데이터를 생성하고 소비자가 이를 소비할 때, 유한 버퍼를 통해 공유된 자원을 효율적으로 주고받는 동기화 문제입니다. 
- 읽기-쓰기 문제: 여러 프로세스가 공유 데이터에 접근할 때, 읽기만 하는 리더와 읽고 쓰는 라이터 간의 데이터 무결성 및 일관성을 유지하는 동기화 문제입니다. 


운영체제의 **동시성 제어** 문제를 깊이 있게 다루는 이 콘텐츠는, 복잡한 시스템 환경에서 여러 프로세스가 공유 자원에 접근할 때 발생하는 문제와 그 해결책을 명확히 제시합니다. 특히 **생산자-소비자 문제**와 **읽기-쓰기 문제(Readers-Writers Problem)**를 중심으로, 세마포어와 뮤텍스를 활용한 고전적인 해결 방안부터 자바의 synchronized, wait(), notify() 메서드를 이용한 현대적인 접근법까지 폭넓게 다룹니다. 단순히 이론을 나열하는 것을 넘어, 실제 코드 예시와 함께 각 해결책의 장단점 및 발생 가능한 **기아(Starvation)** 문제까지 짚어주어 실질적인 시스템 설계 및 디버깅에 필요한 **핵심 통찰**을 제공합니다. 복잡한 동시성 문제를 이해하고 효율적인 시스템을 구축하고자 하는 개발자나 컴퓨터 공학 전공자에게 이 콘텐츠는 필수적인 가이드가 될 것입니다.
## 1. 동시성 제어의 고전적 문제들 소개 
![image]()
1. **동시성 제어 문제의 중요성**: 복잡한 시스템 환경에서 여러 프로세스가 공유 자원에 접근할 때 발생하는 문제와 해결책을 다룬다. 
2. **주요 고전적 문제**:
  1. **생산자-소비자 문제 (Bounded-Buffer Problem)**: 유한 버퍼를 이용한 생산자-소비자 문제 해결 방안을 다룬다. 
  2. **읽기-쓰기 문제 (Readers-Writers Problem)**: 리더와 라이터가 공유 데이터에 접근할 때 발생하는 동기화 문제를 다룬다. 
  3. **철학자들의 저녁식사 문제 (Dining Philosophers Problem)**: 철학자들이 식사 자원을 공유할 때 발생하는 교착 상태 문제를 다룬다. 
3. **학습 목표**: 이러한 대표적인 동기화 문제들을 기존에 학습한 내용을 바탕으로 응용하여 해결하는 방법을 살펴본다. 


## 2. 생산자-소비자 문제 (Bounded-Buffer Problem) 


### 2.1. 문제 정의 및 공유 데이터 구조 
![image]()
1. **문제 정의**:
  1. **생산자 (Producer)**: 계속해서 데이터를 생산한다. 
  2. **소비자 (Consumer)**: 생산된 데이터를 계속해서 소비한다. 
  3. **공유 버퍼**: 생산자와 소비자 사이에 데이터를 주고받는 중간 매개체로, <mark>n개</mark>의 버퍼 공간을 가진다. 각 버퍼는 <mark>아이템 한 개</mark>를 보유할 수 있다. 
2. **생산자와 소비자의 목표**:
  1. **생산자**: 버퍼를 가득 채워 소비자가 소비할 수 있도록 한다. 
  2. **소비자**: 버퍼를 비워 생산자가 데이터를 쓸 수 있도록 한다. 
3. **공유 데이터 (Shared Data) 구성**:
  1. **버퍼 (buffer)**: <mark>n개</mark>의 데이터 공간을 가진다. 
  2. **뮤텍스 (mutex)**: <mark>1</mark>로 초기화된 바이너리 세마포어로, 상호 배제(Mutual Exclusion)를 보장한다. 
  3. **세마포어 (Semaphore)**:
  1. **empty**: <mark>n</mark>으로 초기화된 카운팅 세마포어로, 비어있는 버퍼의 개수를 나타낸다. 
  2. **full**: <mark>0</mark>으로 초기화된 카운팅 세마포어로, 채워진 버퍼의 개수를 나타낸다. 
4. **뮤텍스 사용 목적**: 버퍼 풀에 접근하는 생산자와 소비자가 동시에 접근하여 레이스 컨디션(Race Condition)을 일으키는 것을 방지하고, 임계 구역(Critical Section)에 한 번에 한 프로세스만 진입하도록 상호 배제를 보장한다. 
5. **empty/full 세마포어 사용 목적**: 비어있는 버퍼와 채워진 버퍼의 개수를 카운팅하여 생산자와 소비자의 동기화를 조절한다. 


### 2.2. 생산자 프로세스 구조 
![image]()
1. **아이템 생산**: 생산자는 먼저 아이템을 생산한다. 
2. **버퍼 진입 대기 (empty)**:
  1. wait(empty): 버퍼에 빈 공간이 생길 때까지 기다린다. 이는 소비자가 버퍼를 비울 때까지 기다리는 역할을 한다. 
  2. **다중 생산자 고려**: 생산자가 여러 명일 경우, 버퍼가 비어있지 않아도 wait(empty)를 통해 진입을 제어한다. 
3. **임계 구역 진입 대기 (mutex)**:
  1. wait(mutex): wait(empty)를 통과한 후, 다른 생산자나 소비자가 임계 구역에 진입하지 못하도록 뮤텍스 락을 획득한다. 
  2. **상호 배제 보장**: 이 과정을 통해 버퍼가 비어있고, 현재 자신만이 임계 구역에 진입했음이 보장된다. 
4. **아이템 버퍼에 쓰기**: 버퍼에 아이템 값을 기록한다. 
5. **자원 반납 및 알림**:
  1. signal(mutex): 임계 구역 작업을 마친 후 뮤텍스를 반납한다. 
  2. signal(full): 아이템을 생산하여 버퍼가 채워졌음을 소비자들에게 알린다. 
  3. **카운팅 세마포어 역할**: signal(full)은 full 세마포어 값을 증가시켜, 소비자들이 대기 중이라면 깨어나게 한다. 


### 2.3. 소비자 프로세스 구조 
![image]()
1. **버퍼 진입 대기 (full)**:
  1. wait(full): 버퍼에 채워진 아이템이 생길 때까지 기다린다. 이는 생산자가 아이템을 생산하여 signal(full)을 호출할 때까지 대기하는 역할을 한다. 
2. **임계 구역 진입 대기 (mutex)**:
  1. wait(mutex): wait(full)을 통과한 후, 다른 생산자나 소비자가 임계 구역에 진입하지 못하도록 뮤텍스 락을 획득한다. 
3. **아이템 버퍼에서 읽기**: 버퍼에서 아이템 값을 읽어 소비한다. 
4. **자원 반납 및 알림**:
  1. signal(mutex): 임계 구역 작업을 마친 후 뮤텍스를 반납한다. 
  2. signal(empty): 아이템을 소비하여 버퍼에 빈 공간이 생겼음을 생산자들에게 알린다. 
  3. **카운팅 세마포어 역할**: signal(empty)는 empty 세마포어 값을 증가시켜, 생산자들이 대기 중이라면 깨어나게 한다. 
5. **대칭 구조의 중요성**: 생산자와 소비자의 wait와 signal 호출 순서가 정확히 대칭을 이루어야 동기화 문제가 발생하지 않는다. 순서가 바뀌면 오류가 발생할 수 있다. 
6. **현대적 해결책**: 이러한 복잡한 동기화 문제는 요즘에는 직접 풀기보다는 이미 구현된 라이브러리나 언어 기능을 사용하는 것이 일반적이다. 


## 3. 읽기-쓰기 문제 (Readers-Writers Problem) 


### 3.1. 문제 정의 및 특징 
![image]()
1. **기존 동기화 문제와의 차이점**:
  1. 대부분의 동기화 문제는 공유 데이터에 여러 프로세스가 동시에 접근할 때 레이스 컨디션이 발생하는 것을 가정한다. 
  2. 읽기-쓰기 문제는 프로세스들의 동작이 **읽기(Read)**와 **쓰기(Write)**로 나뉜다는 점에서 차이가 있다. 
2. **프로세스 유형**:
  1. **리더 (Reader)**: 공유 데이터를 읽기만 하는 프로세스 (예: 데이터베이스의 SELECT 쿼리). 
  2. **라이터 (Writer)**: 공유 데이터를 읽고 쓰는(업데이트 포함) 프로세스 (예: 데이터베이스의 UPDATE, INSERT 쿼리). 
3. **동시 접근 시 문제 발생 여부**:
  1. **두 개 이상의 리더 동시 접근**: 데이터 변경이 없으므로 문제가 발생하지 않는다. 데이터의 일관성(Consistency)이나 무결성(Integrity)이 깨지지 않는다. 
  2. **라이터와 다른 라이터 동시 접근**: 데이터 변경이 발생하므로 일관성이 깨진다. 
  3. **라이터와 리더 동시 접근**: 라이터가 데이터를 변경하는 동안 리더가 읽으면 일관성이 깨진다. (예: 은행 계좌 입금 중 잔액 조회, 합격자 발표 전 불합격 상태 조회). 
4. **문제의 핵심**: 리더와 라이터, 또는 라이터와 라이터 간의 동시 접근으로 인한 데이터 혼돈(Chaos)을 어떻게 막을 것인가가 핵심이다. 


### 3.2. 읽기-쓰기 문제의 두 가지 해법 (우선순위 관점) 
![image]()
1. **첫 번째 리더스-라이터스 문제 (First Readers-Writers Problem)**:
  1. **원칙**: 어떤 리더도 라이터가 대기 중이라고 해서 기다리지 않는다. 리더와 라이터에게 공평한 기회를 준다. 
  2. **문제점**: 만약 리더가 압도적으로 많으면 라이터는 계속 대기하게 되어 **기아(Starvation)** 상태에 빠질 수 있다. (예: 잔액 조회 100만 명 vs 입금 1명). 
  3. **해결의 어려움**: 현실적으로 리더가 많을 때 라이터의 기아 문제를 해결하기 어렵다. 
2. **두 번째 리더스-라이터스 문제 (Second Readers-Writers Problem)**:
  1. **원칙**: 라이터가 공유 데이터에 접근하기 위해 대기 중이라면, 새로운 리더는 진입하지 못하고 라이터에게 우선순위를 부여한다. 
  2. **장점**: 라이터의 기아 문제를 해결할 수 있다. 
  3. **문제점**: 리더가 기아 상태에 빠질 수 있으며, 구현이 더 복잡하다. 
  4. **현실적 복잡성**: 실제 시스템에서는 리더와 라이터의 수, 각 작업의 소요 시간 등 다양한 요소를 고려해야 하므로 매우 복잡한 솔루션이 필요하다. 
3. **학습 방향**: 수업에서는 첫 번째 리더스-라이터스 문제의 개념적 해결 방안을 중심으로 살펴본다. 


### 3.3. 첫 번째 리더스-라이터스 문제 해결 (세마포어 활용) 
![image]()
1. **목표**: 리더와 라이터를 똑같이 취급하지 않고, 리더는 동시에 임계 구역에 진입할 수 있도록 하여 효율성을 높인다. 
2. **사용하는 세마포어**:
  1. **rw_mutex**: <mark>1</mark>로 초기화된 바이너리 세마포어 (뮤텍스). 리더와 라이터가 공유 데이터에 접근할 때 사용한다. 
  2. **mutex**: <mark>1</mark>로 초기화된 바이너리 세마포어 (뮤텍스). read_count 변수를 업데이트할 때 발생하는 임계 구역 문제를 해결하기 위해 사용한다. 
3. **공유 변수**:
  1. **read_count**: 현재 공유 데이터를 읽고 있는 리더의 수를 나타내는 변수. 
  2. **rw_mutex의 역할**: read_count가 <mark>0</mark>이 되면 라이터가 진입할 수 있도록 허용한다. 즉, 아무도 읽고 있지 않을 때만 라이터가 쓸 수 있다. 
4. **라이터 프로세스 구조**:
  1. wait(rw_mutex): rw_mutex를 획득하여 임계 구역에 진입한다. 
  2. **쓰기 작업 수행**: 공유 데이터에 쓰기 작업을 수행한다. 
  3. signal(rw_mutex): 쓰기 작업을 마친 후 rw_mutex를 반납한다. 
  4. **특징**: 라이터는 rw_mutex만 획득하면 되므로 구조가 비교적 간단하다. 
5. **리더 프로세스 구조**:
  1. **read_count 증가 및 mutex 획득**:
  1. wait(mutex): read_count를 업데이트하기 위한 임계 구역 보호를 위해 mutex를 획득한다. 
  2. read_count++: 현재 읽고 있는 리더의 수를 1 증가시킨다. 
  3. **첫 번째 리더의 rw_mutex 획득**: 만약 read_count가 <mark>1</mark>이 되면 (즉, 첫 번째 리더가 진입하는 경우), wait(rw_mutex)를 호출하여 rw_mutex를 획득한다. 이는 라이터가 진입하는 것을 막기 위함이다. 
  4. signal(mutex): read_count 업데이트를 마친 후 mutex를 반납한다. 
  2. **읽기 작업 수행**: 공유 데이터를 읽는 작업을 수행한다. 
  3. **read_count 감소 및 mutex 획득**:
  1. wait(mutex): read_count를 업데이트하기 위한 임계 구역 보호를 위해 mutex를 획득한다. 
  2. read_count--: 읽기 작업을 마친 후 read_count를 1 감소시킨다. 
  3. **마지막 리더의 rw_mutex 반납**: 만약 read_count가 <mark>0</mark>이 되면 (즉, 마지막 리더가 나가는 경우), signal(rw_mutex)를 호출하여 rw_mutex를 반납한다. 이는 대기 중인 라이터가 진입할 수 있도록 허용하기 위함이다. 
  4. signal(mutex): read_count 업데이트를 마친 후 mutex를 반납한다. 
  4. **개념적 이해**: 리더가 들어올 때마다 read_count가 증가하고, read_count가 <mark>0</mark>이 아닐 때는 rw_mutex가 획득된 상태이므로 라이터는 진입할 수 없다. 마지막 리더가 나갈 때 read_count가 <mark>0</mark>이 되면 rw_mutex를 반납하여 라이터에게 기회를 준다. 
6. **스케줄러의 역할**:
  1. signal(rw_mutex) 호출 시, rw_mutex를 기다리는 큐에는 라이터뿐만 아니라 리더들도 있을 수 있다. 
  2. **공평한 기회**: 스케줄러가 대기 중인 리더와 라이터에게 공평한 기회를 준다면, 이는 첫 번째 리더스-라이터스 해법이 된다. 
  3. **라이터 우선순위**: 스케줄러가 대기 중인 라이터에게 우선순위를 준다면, 이는 두 번째 리더스-라이터스 해법이 된다. 


### 3.4. 리더-라이터 락 (Reader-Writer Lock) 
![image]()
1. **현대적 해결책**: 리더스-라이터스 문제는 이미 많은 연구를 통해 **리더-라이터 락(Reader-Writer Lock)**이라는 일반화된 해결책으로 제공된다. 
2. **작동 방식**:
  1. 리더-라이터 락을 획득할 때 **리드 모드(Read Mode)** 또는 **라이트 모드(Write Mode)**를 지정한다. 
  2. **리드 모드**: 여러 프로세스가 동시에 락을 획득하여 진입할 수 있다. 
  3. **라이트 모드**: 오직 한 프로세스만 락을 획득하여 진입할 수 있다. 
3. **장점**: 이를 통해 라이터에 대한 상호 배제(Mutual Exclusion)가 보장되므로 동기화 문제가 발생하지 않는다. 
4. **개념적 이해**: 리더-라이터 락은 리더 프로세스와 라이터 프로세스가 공유 자원에 접근할 때 발생하는 동기화 문제를 해결하기 위한 도구이다. 


## 4. 생산자-소비자 문제 구현 예시 (Pthread 및 Java) 


### 4.1. Pthread를 이용한 생산자-소비자 문제 구현 
![image]()
1. **목표**: Pthread 라이브러리를 사용하여 생산자-소비자 문제를 직접 구현하고 실험한다. 
2. **공유 데이터 및 초기화**:
  1. **버퍼**: 크기가 <mark>5</mark>인 버퍼를 사용한다. 
  2. **뮤텍스**: pthread_mutex_t 타입의 mutex를 사용하여 상호 배제를 구현한다. 
  3. **세마포어**: sem_t 타입의 empty와 full을 사용한다.
  1. empty: 버퍼 크기인 <mark>5</mark>로 초기화한다. 
  2. full: <mark>0</mark>으로 초기화한다. 
  4. **인덱스**: in과 out 변수를 사용하여 버퍼의 입출력 위치를 관리한다. 
3. **메인 함수 설정**:
  1. 생산자 스레드 <mark>1개</mark>, 소비자 스레드 <mark>1개</mark>를 생성한다. 
  2. 스레드들이 <mark>10초</mark>동안 동기화되는 과정을 관찰한다. 
4. **생산자 (**producer) 함수:
  1. **무한 루프**: while(true)를 통해 계속 아이템을 생산한다. 
  2. **슬립**: <mark>0.1초에서 0.5초</mark>사이로 랜덤하게 슬립하여 생산 속도를 조절한다. 
  3. **아이템 생성**: <mark>1000에서 1999</mark>사이의 랜덤 숫자를 아이템으로 생성한다. 
  4. **아이템 삽입**: insert_item() 함수를 호출하여 버퍼에 아이템을 넣는다. 
5. **소비자 (**consumer) 함수:
  1. **무한 루프**: while(true)를 통해 계속 아이템을 소비한다. 
  2. **슬립**: <mark>0.1초에서 0.5초</mark>사이로 랜덤하게 슬립하여 소비 속도를 조절한다. 
  3. **아이템 추출**: remove_item() 함수를 호출하여 버퍼에서 아이템을 꺼낸다. 
6. insert_item() 함수 (생산자의 임계 구역):
  1. sem_wait(&empty): 빈 버퍼가 생길 때까지 대기한다. 
  2. pthread_mutex_lock(&mutex): 뮤텍스 락을 획득한다. 
  3. **버퍼에 아이템 삽입**: buffer[in]에 아이템을 넣고 in 인덱스를 증가시킨다 (버퍼 크기로 모듈러 연산). 
  4. pthread_mutex_unlock(&mutex): 뮤텍스 락을 반납한다. 
  5. sem_post(&full): 버퍼가 채워졌음을 알린다. 
7. remove_item() 함수 (소비자의 임계 구역):
  1. sem_wait(&full): 채워진 버퍼가 생길 때까지 대기한다. 
  2. pthread_mutex_lock(&mutex): 뮤텍스 락을 획득한다. 
  3. **버퍼에서 아이템 추출**: buffer[out]에서 아이템을 꺼내고 out 인덱스를 증가시킨다 (버퍼 크기로 모듈러 연산). 
  4. pthread_mutex_unlock(&mutex): 뮤텍스 락을 반납한다. 
  5. sem_post(&empty): 버퍼가 비었음을 알린다. 
8. **실험 결과 분석**:
  1. **기본 설정 (버퍼 5개, 생산자 1, 소비자 1)**: 생산자와 소비자가 사이좋게 번갈아 가며 실행되는 경우가 많다. 
  2. **버퍼 1개 설정**: 버퍼가 1개일 때도 생산자와 소비자가 번갈아 가며 실행되지만, 간혹 소비자가 두 번 연속 실행되는 등 예상치 못한 결과가 나올 수 있다. 
  3. **다중 생산자/소비자 설정**: 버퍼 크기, 생산자 수, 소비자 수를 변경하며 실험하면 더 복잡한 동기화 상황을 관찰할 수 있다. 
  4. **결론**: Pthread의 세마포어를 이용한 동기화는 복잡하지만, 적절히 구현하면 동기화 문제를 해결할 수 있다. 


### 4.2. Java를 이용한 생산자-소비자 문제 구현 (wait(), notify() 활용) 
![image]()
1. **목표**: Java의 synchronized, wait(), notify() 메서드를 사용하여 생산자-소비자 문제를 구현하고 이해한다. 
2. CashBox 클래스: 공유 버퍼 역할을 하는 클래스로, 용돈 상자에 비유된다. 
  1. **공유 인스턴스**: 생산자 스레드와 소비자 스레드가 동일한 CashBox 인스턴스를 공유한다. 
  2. **메서드**: give() (돈을 넣는 행위, 생산자 역할)와 take() (돈을 가져가는 행위, 소비자 역할) 메서드를 포함한다. 
3. **메인 함수 설정**:
  1. CashBox 인스턴스를 생성하고, 버퍼 사이즈를 설정한다. 
  2. 생산자 스레드와 소비자 스레드를 생성하고 시작시킨다. 
4. **생산자 (**Producer) 스레드:
  1. Runnable 인터페이스를 구현한다. 
  2. 생성자에서 CashBox 인스턴스를 받아 공유한다. 
  3. run() 메서드에서 CashBox.give()를 호출하여 돈을 넣는다. 
  4. **비유**: 아빠가 돈을 벌어 용돈 상자에 돈을 넣는 역할. 
5. **소비자 (**Consumer) 스레드:
  1. Runnable 인터페이스를 구현한다. 
  2. 생성자에서 CashBox 인스턴스를 받아 공유한다. 
  3. run() 메서드에서 CashBox.take()를 호출하여 돈을 가져간다. 
  4. **비유**: 아들이 용돈 상자에서 돈을 가져가는 역할. 
6. give() 메서드 (생산자의 임계 구역):
  1. synchronized (this): CashBox 인스턴스에 대한 모니터 락을 획득하여 상호 배제를 보장한다. 
  2. **버퍼 가득 참 대기**: while (count == buffer.length) 조건이 참인 동안 wait()를 호출하여 대기한다. 버퍼가 가득 차면 생산자는 기다린다. 
  3. **아이템 삽입**: 버퍼에 아이템을 넣고 count를 증가시킨다. 
  4. notifyAll(): 대기 중인 모든 스레드(소비자)에게 버퍼 상태가 변경되었음을 알린다. 
  5. wait()와 notify()의 역할: wait()는 스레드를 대기 상태로 만들고 락을 반납하며, notify() 또는 notifyAll()은 대기 중인 스레드를 깨워 다시 락을 획득하고 실행을 재개하도록 한다. 이는 Pthread의 wait와 signal과 유사한 역할을 한다. 
7. take() 메서드 (소비자의 임계 구역):
  1. synchronized (this): CashBox 인스턴스에 대한 모니터 락을 획득하여 상호 배제를 보장한다. 
  2. **버퍼 비어있음 대기**: while (count == 0) 조건이 참인 동안 wait()를 호출하여 대기한다. 버퍼가 비어있으면 소비자는 기다린다. 
  3. **아이템 추출**: 버퍼에서 아이템을 꺼내고 count를 감소시킨다. 
  4. notifyAll(): 대기 중인 모든 스레드(생산자)에게 버퍼 상태가 변경되었음을 알린다. 
8. **실험 결과 분석**:
  1. **기본 설정 (버퍼 1개, 생산자 1, 소비자 1)**: 생산자와 소비자가 "용돈 줘요"와 "고마워요"를 번갈아 가며 완벽하게 동기화된다. 
  2. **다중 소비자 (버퍼 1개, 생산자 1, 소비자 N)**: 여러 소비자가 번갈아 가며 아이템을 가져간다. 
  3. **다중 생산자/소비자 (버퍼 5개, 생산자 N, 소비자 N)**: 여러 생산자와 소비자가 동시에 접근해도 충돌 없이 데이터 일관성이 유지된다. 
  4. **결론**: Java의 synchronized, wait(), notifyAll()을 사용하면 Pthread의 세마포어보다 훨씬 간결하고 강력하게 동기화 문제를 해결할 수 있다. 


### 4.3. Java를 이용한 리더-라이터 락 구현 개념 
![image]()
1. **개념적 이해**: Java에서도 리더-라이터 락을 직접 구현할 수 있으며, 이는 read_count와 isWriting 플래그를 사용하여 제어한다. 
2. acquireReadLock() (리더 락 획득):
  1. **라이터 대기**: 현재 라이터가 쓰고 있다면 wait()를 호출하여 대기한다. 
  2. **read_count 증가**: 리더가 진입했으므로 read_count를 증가시킨다. 
3. releaseReadLock() (리더 락 반납):
  1. **read_count 감소**: 리더가 나갔으므로 read_count를 감소시킨다. 
  2. **마지막 리더의 알림**: read_count가 <mark>0</mark>이 되면 notifyAll()을 호출하여 대기 중인 라이터에게 알린다. 
4. acquireWriteLock() (라이터 락 획득):
  1. **리더/라이터 대기**: read_count가 <mark>0</mark>이 아니거나 다른 라이터가 쓰고 있다면 wait()를 호출하여 대기한다. 
  2. **쓰기 상태 설정**: isWriting 플래그를 true로 설정한다. 
5. releaseWriteLock() (라이터 락 반납):
  1. **쓰기 상태 해제**: isWriting 플래그를 false로 설정한다. 
  2. notifyAll(): 대기 중인 모든 스레드(리더 또는 라이터)에게 버퍼 상태가 변경되었음을 알린다. 
6. notifyAll() 사용의 목적:
  1. notify()는 대기 중인 스레드 중 하나만 깨우지만, notifyAll()은 모든 대기 스레드를 깨운다. 
  2. 모든 스레드를 깨우면, 이들이 다시 경쟁하여 락을 획득하므로 더 공평한 기회를 보장할 수 있다. 


## 5. 다음 학습 내용 
![image]()
1. **철학자들의 저녁식사 문제**: 다음 시간에는 동시성 제어의 세 번째 고전적 문제인 철학자들의 저녁식사 문제에 대해 학습한다. 

