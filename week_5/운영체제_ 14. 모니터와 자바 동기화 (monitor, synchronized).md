
## 📌 모니터와 자바 동기화는 무엇인가?
모니터는 뮤텍스나 세마포어 사용의 어려움을 해결하기 위해 고안된 <mark>고급 동기화 도구이며, 자바는 이 모니터 구조를 충실히 따르고 있어 자바의 동기화를 이해하면 모니터를 거의 다 이해했다고 볼 수 있습니다.</mark>
##### 💡 자바에서 모니터 기반 동기화를 구현하는 두 가지 핵심 요소는?
- synchronized 키워드: 임계 영역(Critical Section)을 지정하여 해당 코드 블록에 모니터 락을 획득해야만 진입 가능하게 합니다.
- wait() 및 notify() 메소드: 스레드 간의 실행 순서를 제어하고 특정 조건에 따라 스레드를 대기시키거나 깨우는 데 사용됩니다.


운영체제에서 **동기화 문제**를 해결하는 핵심 개념인 **모니터**와 자바의 synchronized 키워드를 깊이 있게 다룹니다. 기존 뮤텍스나 세마포어의 복잡성과 오류 발생 가능성을 넘어, 어떻게 모니터가 더 **안전하고 직관적인 동기화 메커니즘**을 제공하는지 명확히 설명합니다. 특히 자바의 synchronized 키워드를 활용하여 **공유 자원 접근 시 발생하는 레이스 컨디션**을 효과적으로 방지하고, 데드락과 우선순위 역전 현상 같은 고급 동기화 문제까지 이해할 수 있는 실용적인 통찰을 얻을 수 있습니다. 복잡한 멀티스레드 환경에서 안정적인 코드를 작성하고 싶은 개발자라면 반드시 알아야 할 필수 지식입니다.
## 1. 동기화 도구의 한계 및 모니터의 등장 배경 
![image]()
1. **뮤텍스 및 세마포어의 사용 어려움**: 
  1. 세마포어는 강력하고 효과적이지만, **타이밍 에러(프로그래밍 에러)**가 자주 발생한다. 
  2. 특정 시퀀스를 잘못 사용하면 항상 발생하지 않고 잡기도 어려운 문제들이 계속 발생하여 프로그래머들이 밤샘 작업을 하게 된다. 

2. **뮤텍스 및 세마포어 사용 시 발생 가능한 오류 예시**: 
  1. **순서 위반**: wait와 signal의 순서를 지키지 않으면 임계 영역(Critical Section)에 두 개 이상의 프로세스가 동시에 진입하는 **레이스 컨디션**이 발생하여 데이터 무결성이 깨진다. 
  2. **중복 호출**: wait를 두 번 호출하거나, signal을 호출해야 할 위치에서 호출하지 않으면 문제가 발생한다. 
  3. 이러한 문제들은 프로그래머가 의도치 않게(honest programming) 발생하거나, 복잡한 코드에서 순서가 꼬이면서 자주 발생한다. 

3. **문제 해결을 위한 접근 방식**: 
  1. 세마포어, 뮤텍스 락을 잘못 사용하여 발생하는 문제를 해결하는 가장 좋은 방법은 **잘못 쓸 가능성을 낮추는 것**이다. 
  2. 이를 위해 **아주 심플한 동기화 메커니즘 툴**을 사용하지 않는 것이 권장된다. 
  3. 현재는 저수준 개발(low-level development)이 아니면 세마포어나 뮤텍스를 직접 사용하는 경우가 거의 없으며, **모니터**와 같은 **고수준 동기화 도구(higher-level synchronization tool)**를 주로 사용한다. 


## 2. 모니터의 개념 및 구조 
![image]()
1. **모니터의 정의**: 
  1. 모니터는 **프로그래머가 정의하는 데이터 타입**으로, **상호 배제(mutual exclusion)**를 제공하는 state type이다. 
  2. 쉽게 말해 **클래스**와 유사하며, 특정 변수를 선언하고 이 변수에 정의된 인스턴스를 호출하도록 해준다. 

2. **모니터의 구조 및 동작 방식**: 
  1. **의사 코드(Pseudo-code) 예시**: monitor 블록 안에서 함수들을 선언하면, 이 함수들은 모니터 내에서 **동기화된 함수**로 사용된다. 
  2. **구성 요소**:
  1. **공유 데이터(Shared Data)**: 여러 스레드가 접근하는 데이터. 
  2. **초기화 코드(Initialization Code)**: 공유 데이터를 초기화하는 코드. 
  3. **동기화된 연산(Synchronized Operations)**: 공유 데이터에 대해 반드시 동기화되어야 하는 연산들. 
  3. 이러한 요소들을 **모니터**라는 자료 구조로 묶어주면, 마치 객체 지향 프로그래밍의 **클래스**나 C 언어의 **구조체(struct)**처럼 동작한다. 
  4. 모니터에 정의된 자료 구조를 사용하는 스레드들을 위해 **엔트리 큐(Entry Queue)** 또는 **대기 큐(Wait Queue)**가 자동으로 생성된다. 

3. **조건 변수(Condition Variable)의 도입**: 
  1. 모니터는 그 자체로 동기화 문제를 해결하기에 부족한 점이 있어 **조건 변수(Condition Variable)**를 추가로 도입한다. 
  2. 조건 변수는 **협력적 동기화 메커니즘**을 제공하며, wait와 signal 연산을 통해 특정 조건이 만족될 때까지 스레드를 대기시키거나 깨울 수 있다. 
  3. 예를 들어, x와 y라는 조건 변수가 있을 때, x에만 락을 걸고 y에만 락을 걸 수 있도록 하여, 각 변수에 대한 별도의 대기 큐를 분리하여 관리한다. 

4. **자바(Java)와의 연관성**: 
  1. 모니터의 개념을 깊이 이해하려면 책 내용만으로는 부족하지만, **자바가 모니터 구조를 충실히 따르고 있다.** 
  2. 따라서 **자바의 동기화 메커니즘을 이해하면 모니터를 거의 다 이해했다고 볼 수 있다.** 


## 3. 자바의 동기화 메커니즘: synchronized 키워드 
![image]()
1. **자바의 모니터 락**: 
  1. 자바는 모니터 자체는 아니지만 **모니터 락(Monitor Lock)**을 사용한다. 
  2. 이를 **내재적 락(Intrinsic Lock)** 또는 **모니터 락(Monitor Lock)**이라고 부르며, 뮤텍스나 세마포어 락보다 더 본질적인 락이다. 
  3. 자바의 기본 단위는 프로세스가 아닌 **스레드**이므로, 주로 스레드 동기화를 위한 동시성 메커니즘으로 모니터를 사용한다. 

2. **자바 동기화의 핵심 요소**: 
  1. synchronized 키워드 
  2. wait(), notify(), notifyAll() 메소드 

3. synchronized 키워드의 역할: 
  1. synchronized는 이름 그대로 **동기화된(synchronized)**이라는 의미를 가진다. 
  2. **임계 영역(Critical Section)**에 해당하는 코드 블록을 synchronized 키워드로 묶어준다. 
  3. 해당 코드 블록(임계 영역)에 진입하려면 **모니터 락을 획득해야만 가능**하며, 코드 블록을 벗어나면 락을 반납한다. 
  4. 이는 마치 **열쇠를 받아야 코드 영역에 진입 가능하고, 나오면 열쇠를 반납하는 것**과 같다. 

4. synchronized 키워드 사용 방법: 
  1. **락을 소유할 객체 인스턴스 지정**: 모니터 락은 특정 **객체 인스턴스**에 할당된다. 
  2. **메소드에 **synchronized 선언: 
  1. 메소드 앞에 synchronized 키워드를 붙이면, 해당 **메소드 코드 블록 전체**가 임계 영역이 된다. 
  2. 이때 락을 획득할 객체 인스턴스는 this (현재 객체 자신)가 된다. 
  3. 이는 가장 편리한 방법이지만, 메소드 전체가 임계 영역이 되어 멀티스레딩의 장점을 상실할 수 있다는 단점이 있다. 
  3. **코드 블록에 **synchronized 선언: 
  1. synchronized (객체 인스턴스) { ... } 형태로 특정 코드 블록을 묶어 임계 영역으로 지정한다. 
  2. 이 블록에 진입할 때는 지정된 객체 인스턴스의 모니터 락을 획득하고, 블록을 벗어날 때는 락을 자동으로 해제한다. 
  3. 프로그래머는 임계 영역만 선언하면 되므로, 락 획득 및 해제(acquire/release)를 직접 호출할 필요가 없어 **매우 쉽고 편리하다.** 

5. synchronized 키워드의 이해 난이도: 
  1. 뮤텍스부터 세마포어까지 학습한 후 synchronized를 보면 쉽지만, 자바를 처음 배우면서 synchronized 키워드를 접하면 이해하기 어렵다. 


## 4. 자바의 동기화 메커니즘: wait() 및 notify() 메소드 
![image]()
1. wait() 및 notify()의 필요성: 
  1. synchronized 키워드는 **상호 배제(mutual exclusion)**를 해결하지만, 스레드 간의 **실행 순서 제어(예: S1 다음에 S2 실행)**는 불가능하다. 
  2. 이러한 순서 제어를 위해서는 wait()와 notify() 메소드가 필요하다. 

2. wait() 및 notify()의 역할: 
  1. 이 메소드들은 세마포어의 P 연산(wait)과 V 연산(signal)에 해당한다. 
  2. java.lang.Object 클래스에 선언되어 있으므로, **모든 자바 객체가 이 메소드들을 가지고 있다.** 

3. wait() 메소드: 
  1. 어떤 스레드가 특정 객체의 wait() 메소드를 호출하면, 해당 객체의 **모니터 대기 큐(Wait Queue)**에 들어가 **대기 상태**가 된다. 

4. notify() 및 notifyAll() 메소드: 
  1. synchronized 임계 영역에 진입하려면 모니터 락을 획득해야 한다. 
  2. 작업을 마친 후 다른 스레드에게 양보하려면 notify()를 호출해야 한다. 
  3. 어떤 스레드가 특정 객체의 notify() 메소드를 호출하면, 해당 객체의 모니터에서 대기 중인 스레드 중 **하나를 깨운다.** 
  4. notifyAll() 메소드를 호출하면 해당 객체에서 대기 중인 **모든 스레드를 깨운다.** 
  1. 모든 스레드가 깨어나면 레디 큐에 들어가고, 그중 하나가 락을 획득하여 실행된다. 
  2. 나머지 스레드들은 다시 대기 큐로 돌아갈 수 있다. 


## 5. synchronized 키워드 활용 예제: 카운터 동기화 


### 5.1. 동기화 문제 발생 예제 (Sample 1) 
![image]()
1. **카운터 클래스 정의**: 
  1. Counter 클래스에 static int count 변수와 increment() 메소드를 정의한다. 
  2. increment() 메소드는 count 변수를 1 증가시킨다. 
  3. MyRunnable 인터페이스는 Counter.increment()를 호출하는 run() 메소드를 가진다. 

2. **메인 함수 실행 흐름**: 
  1. MyRunnable 인스턴스를 사용하여 5개의 스레드를 생성하고 시작한다. 
  2. 각 스레드는 MyRunnable의 run() 메소드를 호출하며, 이 메소드 안에서 Counter.increment()를 1만 번 호출한다. 
  3. 모든 스레드가 종료될 때까지 메인 스레드는 join() 메소드로 대기한다. 
  4. 모든 스레드 종료 후 Counter.count 값을 출력한다. 
  5. count 변수는 static이므로 5개의 스레드가 **하나의 **count 변수를 공유한다. 

3. **결과 및 문제점**: 
  1. 예상 결과는 5만(5개 스레드 * 1만 번 증가)이지만, 실제 실행 결과는 **2969**와 같이 **예상보다 훨씬 낮은 값**이 출력된다. 
  2. 이는 **심각한 동기화 문제**가 발생하여 **레이스 컨디션**이 초래되었음을 보여준다. 


### 5.2. 메소드 전체 동기화 예제 (Sample 2) 
![image]()
1. **해결 방법**: 
  1. Counter 클래스의 increment() 메소드에 synchronized 키워드를 선언한다. 
  2. increment() 메소드 전체가 임계 영역이 되며, 이 메소드에 진입할 때 **모니터 락을 획득**하고, 메소드를 벗어날 때 **락을 해제**한다. 
  3. 이 락 획득 및 해제 과정은 자바가 자동으로 처리한다. 

2. **결과**: 
  1. synchronized 키워드를 추가한 후 실행하면, **5만**이라는 **정확한 결과**가 출력된다. 
  2. 이는 동기화 문제가 해결되었음을 의미한다. 

3. **단점**: 
  1. 메소드 전체를 synchronized로 묶는 것은 편리하지만, 메소드가 길어지고 임계 영역이 아닌 부분이 많을 경우 **멀티스레딩의 장점을 상실**시킬 수 있다. 
  2. 메소드 전체를 묶는 것보다 **실질적인 임계 영역만 묶는 것이 효율적**이다. 


### 5.3. 특정 코드 블록 동기화 예제 (Sample 3) 
![image]()
1. **해결 방법**: 
  1. increment() 메소드 내에서 count++ 부분만 synchronized (객체 인스턴스) { ... } 블록으로 묶는다. 
  2. 이때 락을 획득할 객체 인스턴스를 명시적으로 지정해야 한다. 
  3. 예를 들어, static final Object obj = new Object();와 같이 **의미 없는 객체**를 생성하여 락 객체로 사용할 수 있다. 
  4. 만약 메소드가 static이 아니라면 this를 사용하여 자기 자신의 객체 인스턴스 락을 획득할 수도 있다. 

2. **결과**: 
  1. synchronized 블록을 사용하여 count++ 부분만 동기화한 후 실행하면, **5만**이라는 **정확한 결과**가 출력된다. 
  2. 이는 동기화 문제가 해결되었음을 의미한다. 


## 6. synchronized 키워드 사용 시 주의사항: this 참조 문제 (Sample 4) 
![image]()
1. **예제 설정**: 
  1. Counter 클래스에서 increment() 메소드의 static 키워드를 제거하여 **인스턴스 메소드**로 만든다. 
  2. increment() 메소드 내에서 synchronized (this) { count++; }와 같이 this 객체의 모니터 락을 사용하도록 변경한다. 
  3. count 변수는 여전히 static으로 유지하여 **공유 자원**임을 명시한다. 
  4. MyRunnable 클래스는 Counter 인스턴스를 멤버 변수로 가지고 생성자를 통해 주입받도록 변경한다. 

2. **메인 함수 실행 흐름**: 
  1. 메인 함수에서 5개의 스레드를 생성하는 것은 동일하다. 
  2. 하지만 new MyRunnable(new Counter())와 같이 **각 스레드마다 새로운 **Counter 인스턴스를 생성하여 MyRunnable에 전달한다. 
  3. 결과적으로 5개의 스레드는 각각 **다른 **Counter 인스턴스를 가지게 된다. 
  4. 각 Counter 인스턴스는 increment() 메소드를 호출하며, 이 메소드는 synchronized (this)를 통해 **자신(각각의 **Counter 인스턴스)의 락을 사용한다. 
  5. 그러나 count 변수는 static이므로, **5개의 **Counter 인스턴스가 하나의 static count 변수를 공유한다. 

3. **결과 및 문제점**: 
  1. 예상과 달리 다시 **동기화 문제**가 발생하여 **5만이라는 정확한 결과가 나오지 않는다.** 
  2. **원인**: synchronized (this) 블록은 **자기 자신(각각의 **Counter 인스턴스)을 참조하는 객체 변수이다. 
  3. 5개의 스레드가 각각 다른 Counter 인스턴스를 가지고 있으므로, 각 스레드는 **서로 다른 모니터 락**을 획득하게 된다. 
  4. 즉, 각 Counter 인스턴스는 자기 자신과만 동기화될 뿐, **다른 **Counter 인스턴스와는 동기화되지 않는다. 
  5. 따라서 공유 자원인 static count 변수에 대한 **상호 배제가 제대로 이루어지지 않아** 동기화 문제가 다시 발생한다. 


## 7. synchronized 키워드 사용 시 올바른 this 참조 활용 (Sample 5) 
![image]()
1. **해결 방법**: 
  1. MyRunnable에 전달되는 Counter 인스턴스를 **하나만 생성하여 모든 스레드가 공유**하도록 한다. 
  2. 메인 함수에서 Counter counter = new Counter();를 한 번만 호출하고, 이 counter 인스턴스를 5개의 MyRunnable 인스턴스에 파라미터로 넘겨준다. 
  3. 이렇게 하면 5개의 스레드는 모두 **동일한 **Counter 객체 인스턴스를 참조하게 된다. 

2. **결과**: 
  1. 모든 스레드가 동일한 Counter 인스턴스의 increment() 메소드를 호출하고, 이 메소드는 synchronized (this)를 통해 **하나의 **Counter 인스턴스 락을 공유하게 된다. 
  2. 이는 마치 세마포어 예제에서 열쇠가 1개인 바이너리 세마포어를 사용하는 것과 동일한 효과를 낸다. 
  3. 결과적으로 동기화 문제가 해결되어 **5만**이라는 **정확한 결과**가 출력된다. 


## 8. 모니터와 자바 동기화 요약 
![image]()
1. **모니터의 개념적 이해**: 
  1. 모니터는 클래스처럼 **모니터 변수**와 **조건 변수**를 선언하고, 조건 변수에 사용할 수 있는 wait()와 notify() 메소드를 호출하여 동기화를 수행한다. 

2. **자바 **synchronized의 활용: 
  1. wait()와 notify()보다 훨씬 간편하게 synchronized 키워드를 사용하여 동기화를 구현할 수 있다. 
  2. synchronized 블록을 통해 **임계 영역을 지정**하거나, 메소드에 synchronized를 선언하여 **메소드 전체를 동기화**할 수 있다. 


## 9. 라이브니스(Liveness) 문제: 데드락과 우선순위 역전 


### 9.1. 라이브니스 개념 및 데드락 
![image]()
1. **라이브니스(Liveness)의 의미**: 
  1. 지금까지 배운 뮤텍스, 세마포어, 모니터는 **상호 배제(mutual exclusion)**만 제공하며, **진행(progress)**, **데드락(deadlock)**, **무한 대기(starvation)** 문제를 해결해주지 못한다. 
  2. 오히려 이러한 동기화 도구들은 데드락 문제를 더 일으킬 수 있다. 
  3. 라이브니스는 시스템이 **진행(progress)**되어야 하고, **무한 대기(starvation)**가 발생하지 않아야 함을 의미한다. 
  4. 라이브니스 문제는 고급 동기화 개념으로, 여기서는 **데드락**과 **우선순위 역전** 두 가지만 살펴본다. 

2. **데드락(Deadlock) 정의**: 
  1. **두 개 이상의 프로세스**가 **영원히 기다려야 하는 상황**을 의미한다. 
  2. 특히, 대기 큐에 있는 프로세스만 발생시킬 수 있는 이벤트를 내가 기다리고 있을 때 발생한다. 

3. **데드락 발생 예시 (세마포어 사용)**: 
  1. **P0 프로세스**: wait(S), wait(Q), 임계 영역, signal(Q), signal(S) 
  2. **P1 프로세스**: wait(Q), wait(S), 임계 영역, signal(S), signal(Q) 
  3. **문제 발생 시나리오**:
  1. P0이 wait(S)를 호출하여 S를 획득한다. 
  2. P1이 wait(Q)를 호출하여 Q를 획득한다. 
  3. P0이 wait(Q)를 호출하지만 Q는 P1이 가지고 있으므로 P0은 Q를 기다린다. 
  4. P1이 wait(S)를 호출하지만 S는 P0이 가지고 있으므로 P1은 S를 기다린다. 
  5. 결과적으로 P0은 P1이 Q를 해제하기를 기다리고, P1은 P0이 S를 해제하기를 기다리며 **서로 영원히 기다리는 교착 상태(Deadlock)**에 빠진다. 
  4. 이러한 상황에서는 임계 영역에 진입하지 못했으므로 signal을 호출할 수 없어 영원히 대기하게 된다. 


### 9.2. 우선순위 역전(Priority Inversion) 
![image]()
1. **우선순위 역전 정의**: 
  1. **높은 우선순위(High Priority)를 가진 프로세스**가 **낮은 우선순위(Low Priority)를 가진 프로세스** 때문에 실행이 지연되는 현상이다. 
  2. 예를 들어, 높은 우선순위 프로세스가 커널 데이터에 접근하려는데, 이 데이터를 낮은 우선순위 프로세스가 점유하고 있어 기다려야 하는 경우이다. 

2. **우선순위 역전 발생 예시**: 
  1. **비유**: 아버지가 TV를 보려는데, 낮은 우선순위인 막내가 TV를 보고 있는 상황. 
  2. **일반적인 경우**: 아버지는 막내를 쫓아내고(선점, Preemption) TV를 볼 수 있다. 
  3. **문제 발생**: TV를 보려면 리모컨이 필요한데, 막내가 리모컨을 쥐고 있는 경우. 
  1. 아버지가 막내를 쫓아내도 막내가 리모컨을 가지고 나가버리면 아버지는 TV를 볼 수 없다. 
  2. 아버지는 막내가 리모컨을 내려놓을 때까지 기다려야 한다. 
  4. **컴퓨터 시스템 예시**:
  1. 레디 큐에 대기 중인 **높은 우선순위 프로세스(Q)**가 있고, 현재 실행 중인 **낮은 우선순위 프로세스(P)**가 있다. 
  2. 스케줄러만 동작한다면 Q가 P를 쫓아내고 실행될 수 있다. 
  3. 하지만 Q가 어떤 자원(예: 프린터)을 필요로 하는데, 이 자원을 P가 점유하고 있는 경우. 
  4. Q는 P가 자원을 해제할 때까지 기다려야 하므로, **높은 우선순위임에도 불구하고 대기**하게 된다. 

3. **우선순위 역전의 심화 문제**: 
  1. **중간 우선순위(Medium Priority) 프로세스의 개입**:
  1. 높은 우선순위(H), 중간 우선순위(M), 낮은 우선순위(L) 프로세스가 있다. 
  2. L이 자원을 점유하고 있어 H가 대기 중이다. 
  3. 이때 M이 실행될 수 있다면, L은 CPU를 점유하지 못하고 M에게 밀려 자원을 해제할 기회를 얻지 못한다. 
  4. 결과적으로 H는 L이 자원을 해제하기를 기다리는데, L은 M 때문에 실행되지 못하여 H의 대기 시간이 더욱 길어진다. 

4. **해결 방법: 우선순위 상속 프로토콜(Priority Inheritance Protocol)**: 
  1. 높은 우선순위 프로세스(H)가 낮은 우선순위 프로세스(L)가 소유한 자원을 필요로 할 때, **일시적으로 L의 우선순위를 H의 우선순위로 높여준다.** 
  2. 이렇게 하면 L은 높은 우선순위로 빠르게 실행되어 자원을 해제하고, H는 자원을 획득하여 실행될 수 있다. 
  3. 자원 해제 후 L은 원래의 낮은 우선순위로 돌아간다. 


## 10. 결론 및 향후 학습 내용 
![image]()
1. **오늘 학습 내용**: 
  1. 뮤텍스, 세마포어, 모니터 개념. 
  2. 자바의 동기화 키워드인 synchronized의 사용법. 

2. **향후 학습 내용**: 
  1. wait()와 notify() 메소드는 7장(고전적 동기화 문제)에서 프로듀서-컨슈머, 리더-라이터 문제 등을 풀 때 예제와 함께 자세히 다룰 예정이다. 
  2. 데드락, 우선순위 역전과 같은 라이브니스 문제 해결을 위한 **라이브니스(Liveness)** 개념은 8장에서 더 깊이 다룰 예정이다. 

