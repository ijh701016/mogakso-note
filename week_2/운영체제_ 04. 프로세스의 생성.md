
## 📌 유닉스/마이크로 OS에서 새로운 프로세스는 어떻게 생성되나요?
유닉스/마이크로 OS에서 새로운 프로세스는 <mark>'fork'라는 시스템 콜에 의해 생성</mark><mark> </mark>되며, 부모 프로세스의 주소 공간을 복사하여 자식 프로세스를 만듭니다 
##### 💡 fork 시스템 콜의 반환 값으로 부모 프로세스와 자식 프로세스를 어떻게 구분하나요?
fork 시스템 콜의 반환 값이 0이면 자식 프로세스이고, 0이 아닌 PID(프로세스 ID)를 반환하면 부모 프로세스입니다 


이 콘텐츠는 **프로세스 생성과 컨텍스트 스위치**라는 운영체제의 핵심 개념을 실제 코드 예시와 함께 깊이 있게 다룹니다. fork() 시스템 콜을 통한 **자식 프로세스 생성 원리**와 부모-자식 프로세스 간의 메모리 공간 복사 및 실행 흐름을 명확히 이해할 수 있습니다. 특히, 전역 변수가 복사된 프로세스에서 어떻게 독립적으로 동작하는지, 그리고 exec() 계열 함수가 기존 프로세스를 어떻게 새로운 프로그램으로 대체하는지 등 **실용적인 코드 동작 방식**을 통해 운영체제의 동시성 제어 메커니즘을 체감할 수 있습니다. 복잡한 멀티태스킹 환경에서 프로세스들이 어떻게 상호작용하고 관리되는지 그 본질을 파악하고 싶은 개발자나 컴퓨터 공학도에게 필수적인 통찰을 제공합니다.
## 1. 프로세스 생성 및 컨텍스트 스위치 개요 
![image]()
1. **프로세스의 정의 및 구성 요소** 
  1. **프로세스 정의**: CPU가 실행할 프로그램이 메모리(RAM)에 로드된 상태를 의미한다. 
  2. **CPU 구성 요소**: ALU, 레지스터(프로그램 카운터, 스택 포인터 등)를 포함한다. 
  3. **PCB (Process Control Block)**: 프로세스의 상태 정보(스테이트), 리소스 정보, 레지스터 정보 등을 담아 놓은 자료 구조이다. 

2. **컨텍스트 스위치 (Context Switch)** 
  1. **정의**: 현재 CPU가 실행 중인 프로세스의 PCB 정보를 외부에 저장(스토어)하고, 다른 프로세스의 PCB 정보를 CPU 레지스터에 로드하는 과정을 의미한다. 
  2. **목적**: 문맥 교환을 통해 타임 쉐어링(Time Sharing)을 구현하여, 여러 프로세스가 동시에 실행되는 것처럼 보이는 동시성(Concurrency) 제어를 가능하게 한다. 

3. **새로운 프로세스 생성의 어려움** 
  1. 개념적으로는 이해하기 쉽지만, 실제로 구현하고 동작을 이해하는 것은 쉽지 않다. 


## 2. fork() 시스템 콜을 이용한 자식 프로세스 생성 


### 2.1. fork() 시스템 콜의 기본 원리 
![image]()
1. fork() 시스템 콜: 유닉스/리눅스 계열 OS에서 새로운 프로세스를 생성하는 데 사용되는 시스템 콜이다. 
2. **자식 프로세스 구성**:
  1. 부모 프로세스의 주소 공간(Address Space)을 그대로 복사하여 새로운 프로세스를 생성한다. 
  2. fork() 호출 이후, 부모 프로세스와 자식 프로세스 모두 다음 인스트럭션(명령어)을 계속 실행한다. 
3. fork()의 리턴 값:
  1. **0**: 자식 프로세스에서 리턴되는 값이다. 
  2. **0이 아닌 PID (Process ID)**: 부모 프로세스에서 리턴되는 값으로, OS 커널이 부여한 자식 프로세스의 PID이다. 
  3. 이 리턴 값을 통해 부모 프로세스와 자식 프로세스를 구분할 수 있다. 


### 2.2. fork() 동작 예시 및 전역 변수 복사 
![image]()
1. **프로그램 준비**: main.c 소스 코드를 컴파일하여 a.out 실행 파일을 생성한다. 
2. **메모리 로드 및 프로세스 생성**:
  1. a.out을 메모리에 로드하면 코드/텍스트 섹션, 데이터 섹션, 힙 영역, 스택 영역 등이 할당된다. 
  2. 이 정보와 프로세스 상태 정보를 PCB에 저장하면 프로세스 생성이 완료된다. 
3. fork() 호출 시 동작: 
  1. **부모 프로세스(P0)**: fork()를 호출하면, P0의 주소 공간(메모리)이 그대로 복사되어 **자식 프로세스(P1)**가 생성된다. 
  2. **실행 흐름**:
  1. P0가 fork() 문장을 실행한 후, 다음 명령어인 `printf("Hello Process PID: %d
", pid);`를 실행한다. 
2. 이때 P0는 fork()로부터 자식 프로세스의 PID(0이 아닌 값)를 리턴받으므로, Hello Process PID: [자식 PID]를 출력한다. 
3. P0는 실행을 마치고 CPU를 반납한다. 
4. 운영체제는 대기 중인 P1의 PCB를 CPU에 로드하여 컨텍스트 스위치를 수행한다. 
5. P1은 fork() 호출 직후부터 실행되며, fork()로부터 0을 리턴받으므로, Hello Process PID: 0을 출력한다. 
6. **결과**: Hello Process PID: [자식 PID]와 Hello Process PID: 0이 각각 한 번씩 출력된다. 

4. **전역 변수 복사 및 독립성 (연습 문제 3.1)** 
  1. **상황**: 전역 변수 value가 5로 초기화된 상태에서 fork()를 호출한다. 
  2. fork() 시점: fork()가 호출되는 시점에 value의 값(5)이 부모 프로세스에서 자식 프로세스로 그대로 복사된다. 
  3. **자식 프로세스 실행**:
  1. pid가 0인 자식 프로세스에서 value += 15;를 실행하면, 자식 프로세스의 value는 <mark>20</mark>이 된다. 
  2. 이후 자식 프로세스는 종료된다. 
  4. **부모 프로세스 실행**:
  1. pid가 0보다 큰 부모 프로세스는 wait(NULL);을 호출하여 자식 프로세스가 종료될 때까지 대기한다. 
  2. 자식 프로세스 종료 후, 부모 프로세스는 `printf("PARENT: value = %d
", value);`를 실행한다. 
3. 이때 부모 프로세스의 value는 자식 프로세스의 변경에 영향을 받지 않고 <mark>초기 값 5</mark>를 유지한다. 
4. **결론**: fork()를 통해 주소 공간이 복사되면, 부모와 자식 프로세스는 각자의 메모리 공간을 가지므로, 한쪽에서 전역 변수를 변경해도 다른 쪽에 영향을 미치지 않는다. 


## 3. wait() 시스템 콜을 이용한 자식 프로세스 대기 
![image]()
1. wait() 시스템 콜의 역할: 
  1. 부모 프로세스가 자식 프로세스의 종료를 기다리게 하는 시스템 콜이다. 
  2. wait()를 호출한 부모 프로세스는 레디 큐(Ready Queue)에서 웨이트 큐(Wait Queue)로 이동하여 자식 프로세스가 종료될 때까지 대기한다. 
  3. 자식 프로세스가 종료되면 인터럽트가 발생하여 부모 프로세스가 다시 실행될 수 있다. 

2. wait() 적용 예시: 
  1. **코드 변경**: wait.h 헤더 파일을 추가하고 fork() 이후 if (pid > 0) { wait(NULL); } 코드를 삽입한다. 
  2. **실행 흐름**:
  1. fork() 호출 후 부모 프로세스(P0)와 자식 프로세스(P1)가 생성된다. 
  2. P0는 pid > 0 조건에 따라 wait(NULL)을 호출하고 웨이트 큐로 이동한다. 
  3. P1은 pid == 0이므로 wait()를 호출하지 않고 즉시 `printf("Hello Process PID: 0
");`를 실행한다. 
4. P1이 종료되면 P0에게 인터럽트를 걸고, P0는 웨이트 큐에서 나와 `printf("Hello Process PID: [자식 PID]
");`를 실행한다. 
3. **결과**: Hello Process PID: 0이 먼저 출력되고, 이어서 Hello Process PID: [자식 PID]가 출력된다. 
4. **차이점**: wait()가 없을 때는 부모와 자식의 실행 순서가 보장되지 않지만, wait()를 사용하면 자식이 먼저 실행되고 부모가 나중에 실행되는 순서가 보장된다. 


## 4. fork()를 통한 다중 프로세스 생성 


### 4.1. 중첩된 fork() 호출 시 프로세스 개수 (연습 문제 3.2) 
![image]()
1. fork() 1회 호출: 부모 프로세스 1개가 자식 프로세스 1개를 생성하여 총 <mark>2개</mark>의 프로세스가 된다. 
2. fork() 2회 호출:
  1. 첫 번째 fork() 후 부모(P0)와 자식(P1)이 생성된다. 
  2. 두 번째 fork()는 P0와 P1 모두에서 실행되므로, P0는 새로운 자식(P2)을, P1은 새로운 자식(P3)을 생성한다. 
  3. 총 <mark>4개</mark>의 프로세스(P0, P1, P2, P3)가 된다. 
3. fork() 3회 호출:
  1. 두 번째 fork() 후 4개의 프로세스가 존재한다. 
  2. 세 번째 fork()는 이 4개의 프로세스 모두에서 실행되므로, 각각 새로운 자식 프로세스를 생성한다. 
  3. 총 <mark>8개</mark>의 프로세스가 된다. 
4. **결론**: n번의 fork() 호출은 <mark>2^n</mark>개의 프로세스를 생성한다. 


### 4.2. for 루프 내 fork() 호출 (연습 문제 3.1d) 
![image]()
1. for 루프 구조: for (i = 0; i < 4; i++) { fork(); }와 같이 fork()가 루프 내에서 4번 호출된다. 
2. **예상 프로세스 개수**: fork()가 4번 호출되므로, 이론적으로는 <mark>2^4 = 16개</mark>의 프로세스가 생성될 것으로 예상된다. 
3. **실제 동작 확인**:
  1. 실제로 코드를 실행하여 printf()로 프로세스 ID를 출력해보면, 예상과 다른 결과가 나올 수 있다. 
  2. 이는 운영체제의 스케줄링 및 환경에 따라 달라질 수 있으며, 다양한 실험을 통해 확인해야 한다. 


## 5. exec() 계열 함수를 이용한 프로그램 대체 
![image]()
1. exec() 계열 함수의 필요성: 
  1. fork()는 부모 프로세스와 동일한 작업을 수행하는 자식 프로세스를 생성한다. 
  2. 하지만 때로는 기존 프로세스가 **전혀 다른 새로운 프로그램**을 실행해야 할 필요가 있다. 
  3. 예시: 배틀넷 런처(Launcher)가 워크래프트나 스타크래프트 같은 실제 게임 프로그램을 실행시키는 경우. 

2. exec() 계열 함수 (execlp)의 동작: 
  1. fork()를 통해 자식 프로세스를 생성한다. 이때 자식 프로세스는 부모 프로세스(예: 런처 프로그램 a.out)의 복사본이다. 
  2. 자식 프로세스 내에서 execlp() 함수를 호출하면, 이 함수는 **새로운 프로그램(예: 게임 프로그램 **b.out)을 메모리에 로드하여 기존 자식 프로세스의 메모리 컨텍스트를 완전히 덮어씌운다. 
  3. 이후 자식 프로세스는 b.out 프로그램을 실행하게 된다. 

3. execlp() 사용 예시 (ls 명령어 실행) 
  1. **상황**: main 함수를 가진 P0 프로세스가 fork()를 호출하여 P1을 생성한다. 
  2. execlp("/bin/ls", "ls", NULL); 호출: P1 프로세스 내에서 execlp()를 호출하여 /bin/ls 프로그램을 실행한다. 
  3. **결과**: P1은 ls 명령어를 실행하여 디렉토리 목록을 출력한다. 
  4. **중요한 점**: execlp() 호출 이후에 오는 코드(예: `printf("Child complete
");`)는 **절대 실행되지 않는다.** 
5. **이유**: execlp()가 새로운 프로그램으로 메모리 공간을 완전히 덮어씌웠기 때문에, 기존 프로그램의 나머지 명령어들은 메모리에서 사라지게 된다. 
6. **결론**: exec() 계열 함수는 현재 프로세스를 새로운 프로그램으로 **대체**하는 역할을 한다. 


## 6. 프로세스 ID 확인 및 동시성 문제 
![image]()
1. **프로세스 ID 확인 (**getpid(), getppid()) 
  1. getpid(): 현재 실행 중인 프로세스의 PID를 반환한다. 
  2. getppid(): 현재 실행 중인 프로세스의 부모 프로세스(Parent Process)의 PID를 반환한다. 
  3. fork()와 함께 사용:
  1. 자식 프로세스(pid == 0인 경우)에서 getpid()를 호출하면 자신의 PID를, getppid()를 호출하면 부모의 PID를 얻을 수 있다. 
  2. 부모 프로세스(pid > 0인 경우)에서 getpid()를 호출하면 자신의 PID를, getppid()를 호출하면 자신의 부모(즉, fork()를 호출한 프로세스의 부모)의 PID를 얻을 수 있다. 
  3. fork()가 리턴한 자식 PID와 자식 프로세스 내에서 getpid()로 얻은 PID는 동일해야 한다. 

2. **전역 변수 배열 복사 (연습 문제 3.16)** 
  1. **상황**: 전역 변수 배열 arr을 선언하고 fork()를 호출한다. 
  2. **자식 프로세스**: pid == 0인 경우, for 루프를 돌며 arr[i] *= i; 연산을 수행한다. 
  3. **부모 프로세스**: pid > 0인 경우, wait()를 호출하여 자식 프로세스 종료를 기다린 후 arr 배열의 값을 출력한다. 
  4. **결과**: 자식 프로세스에서 변경된 arr 값(예: 0, 1, 4, 9, 16)과 부모 프로세스에서 변경되지 않은 arr 값(예: 0, 1, 2, 3, 4)이 각각 출력된다. 
  5. **재확인**: 전역 변수와 마찬가지로 전역 변수 배열도 fork() 시점에 복사되므로, 부모와 자식은 독립적인 메모리 공간을 가지며 서로의 변경에 영향을 주지 않는다. 

3. **프로세스 실행 순서의 비보장성** 
  1. **문제점**: wait()를 사용하지 않는 경우, fork() 이후 부모 프로세스와 자식 프로세스 중 어느 것이 먼저 실행될지 **보장할 수 없다.** 
  2. **원인**: fork() 직후 운영체제의 스케줄러가 컨텍스트 스위치를 발생시켜 자식 프로세스에게 CPU를 할당할 수 있기 때문이다. 
  3. **해결책**: 이러한 동시성 문제를 해결하기 위해 **동기화(Synchronization)** 메커니즘이 필요하며, 이는 다음 시간에 다룰 주제이다. 


## 7. 프로세스 개념 및 다음 학습 내용 요약 
![image]()
1. **프로세스 개념 재정리**: 
  1. **프로세스**: 실행 중인 프로그램(Program in execution)이다. 
  2. **OS 스케줄러**: CPU 스케줄러는 여러 프로세스(P0, P1, ..., Pn)를 동시에 실행시키기 위해 타임 쉐어링(Time Sharing)을 수행한다. 
  3. **컨텍스트 스위치**: CPU의 레지스터 정보(특히 프로그램 카운터, 스택 포인터)를 저장하고 복원하는 과정으로, 타임 쉐어링의 핵심 메커니즘이다. 

2. **동시성 제어의 중요성**: 
  1. 여러 프로세스가 동시에 실행되는 환경(Concurrent Environment)에서는 동시성 제어(Concurrency Control) 문제가 발생하기 쉽다. 
  2. 이러한 문제를 해결하기 위해 **동기화(Synchronization)**가 필수적이다. 

3. **다음 학습 내용**: 
  1. **프로세스 간 통신 (IPC: Inter-Process Communication)**: 프로세스들이 서로 어떻게 통신하는지에 대해 학습할 예정이다. 

