
## 📌 프로세스 간 통신(IPC)의 두 가지 주요 방식은 무엇인가?
프로세스 간 통신(IPC)은 크게 <mark>공유 메모리(Shared Memory) 방식과 메시지 패싱(Message Passing) 방식</mark><mark> </mark>으로 나눌 수 있습니다 
##### 💡 두 방식의 특징은 무엇인가?

| **방식** | **특징** |
| --- | --- |
| 공유 메모리 | 프로세스들이 명시적으로 공유 공간에 데이터를 쓰고 읽으며 통신  |
| 메시지 패싱 | 운영체제가 메시지 전달을 관리하며, 프로세스는 샌드(send)와 리시브(receive) 기능만 사용  |


운영체제에서 여러 프로세스가 동시에 실행될 때 발생하는 **프로세스 간 통신(IPC)**의 핵심 원리를 명쾌하게 설명합니다. 독립적인 프로세스와 달리, 서로 영향을 주고받는 **협력 프로세스(Cooperating Process)**들이 어떻게 데이터를 주고받고 동기화하는지 두 가지 주요 모델인 **공유 메모리(Shared Memory)**와 **메시지 패싱(Message Passing)**을 통해 깊이 있게 다룹니다. 특히, 생산자-소비자 문제와 같은 실제 시나리오를 통해 각 방식의 장단점과 구현 시 고려해야 할 **블로킹/논블로킹, 동기/비동기 통신**의 중요성을 이해할 수 있습니다. 이 콘텐츠를 통해 복잡한 시스템의 동작 원리를 파악하고, 효율적인 애플리케이션 설계에 필요한 실용적인 통찰을 얻을 수 있을 것입니다.
## 1. 프로세스 간 통신(IPC)의 필요성 
![image]()
1. **프로세스 실행 환경 분류** 
  1. 운영체제에서 여러 프로세스가 동시에 실행되는 환경은 두 가지로 나눌 수 있다. 
  2. **독립적으로 실행되는 경우 (Independent Process)** 
  1. 서로 영향을 주지 않고 각자 자신의 일을 수행한다. 
  2. 각자의 메모리 영역을 독립적으로 가지므로 서로 간섭할 일이 없다. 
  3. CPU 스케줄링을 통해 잘 공존할 수 있다. 
  3. **협력하며 실행되는 경우 (Cooperating Process)** 
  1. 프로세스들이 서로 영향을 주고받는 상황이다. 
  2. 예시: 아빠 프로세스와 아들 프로세스가 서로 간섭하며 메시지를 주고받을 때 문제가 발생할 수 있다. 

2. **협력 프로세스에서 IPC 문제 발생** 
  1. 독립 프로세스는 공유 데이터나 메시지 교환이 없어 문제가 없다. 
  2. 협력 프로세스는 서로 영향을 주거나 받기 때문에 문제가 발생한다. 
  3. **IPC (Inter-Process Communication)**: 프로세스들이 데이터를 공유하거나 메시지를 주고받을 때 발생하는 문제를 해결하기 위한 메커니즘이다. 


## 2. IPC의 두 가지 주요 모델 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/181.jpg)
1. **IPC 메커니즘의 본질**: 결국 데이터를 주고받는 과정이다. 
  1. 예시: 아빠가 용돈을 주거나 아들이 용돈을 받는 행위, 성적표를 주고받는 행위 등. 

2. **두 가지 통신 모델** 
  1. **공유 메모리 (Shared Memory)** 
  1. **개념**: 프로세스들이 공유하는 특정 메모리 공간(용돈 함)을 통해 데이터를 주고받는 방식이다. 
  2. **예시**: 아빠가 용돈 함에 돈을 넣으면 아들이 가져가는 방식이다. 
  2. **메시지 패싱 (Message Passing)** 
  1. **개념**: 운영체제(OS)가 중간에 개입하여 메시지를 전달하는 방식이다. 
  2. **예시**: 아빠가 은행에 입금하면 은행(OS)이 아들 계좌로 이체해주는 방식이다. 
  3. **메시지 큐**: 메시지 패싱 시 메시지를 주고받는 데 사용되는 큐이다. 


## 3. 공유 메모리 방식: 생산자-소비자 문제 해결 


### 3.1. 생산자-소비자 문제의 이해 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/302.jpg)
1. **생산자-소비자 문제 정의** 
  1. 협력 프로세스 간의 가장 기본적인 문제이다. 
  2. **생산자 (Producer)**: 정보를 생산하는 프로세스이다. 
  3. **소비자 (Consumer)**: 정보를 소비하는 프로세스이다. 

2. **생산자-소비자 문제의 실제 예시** 
  1. **컴파일러와 어셈블러**: 컴파일러가 C 코드를 어셈블리 코드로 생성(생산)하면, 어셈블러가 이를 기계어로 변환(소비)한다. 
  2. **웹 서버와 브라우저**: 웹 서버가 HTML 파일을 전송(생산)하면, 브라우저가 이를 받아 화면에 표시(소비)한다. 
  3. **유튜브 서버와 스마트폰**: 유튜브 서버가 영상을 스트리밍(생산)하면, 스마트폰이 이를 받아 화면에 디스플레이(소비)한다. 


### 3.2. 공유 메모리를 이용한 생산자-소비자 문제 해결 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/430.jpg)
1. **문제 설정**: 생산자 프로세스가 영상을 계속 전송하고, 소비자 프로세스는 이 영상을 받아 화면에 뿌려야 한다. 

2. **동시 실행 환경**: 생산자(P)와 소비자(Q) 프로세스는 CPU를 타임 쉐어링하며 컨텍스트 스위치를 통해 동시에(concurrently) 실행된다. 

3. **버퍼 사용**: 생산자와 소비자 사이에 **버퍼(Buffer)**를 사용하여 데이터를 주고받는다. 
  1. 생산자는 버퍼에 데이터를 채우고, 소비자는 버퍼에 데이터가 있으면 가져간다. 

4. **바운디드 버퍼 (Bounded Buffer)** 
  1. 대부분의 버퍼는 무한대가 아닌 **유한한 크기**를 가진다. 
  2. **버퍼가 가득 찬 경우**: 생산자는 더 이상 생산하지 못하고 대기(wait)한다. 
  3. **버퍼가 비어 있는 경우**: 소비자는 소비할 데이터가 없어 대기(wait)한다. 

5. **공유 메모리로서의 버퍼** 
  1. 버퍼를 **공유 메모리**로 만들어 생산자와 소비자가 공유한다. 
  2. **메모리 영역 보호**: 일반적으로 각 프로세스의 메모리 영역은 독립적으로 보장되어야 한다. 
  1. 다른 프로세스가 함부로 접근하면 바이러스, 오동작 등 문제가 발생할 수 있다. 
  2. 운영체제(OS)는 프로세스 간 공유될 수 있는 특별한 메모리 영역인 **공유 메모리**를 관리하여 이러한 문제를 해결한다. 

6. **공유 버퍼의 논리적 구현 (예시)** 
  1. **구조체 배열 버퍼**: item 타입의 구조체 배열로 버퍼를 생성한다. 
  2. in과 out 포인터: 버퍼의 in과 out 포인터를 모두 0으로 초기화한다. 
  1. in: 생산자가 다음 데이터를 넣을 위치를 가리킨다. 
  2. out: 소비자가 다음 데이터를 가져갈 위치를 가리킨다. 
  3. **버퍼 상태**: in과 out이 만나면 버퍼가 비어있음을 의미하며, 이때는 대기한다. 
  4. **순환 버퍼**: 버퍼가 가득 차면 in 포인터가 다시 처음으로 돌아오는 순환(circular) 방식으로 구현된다. 

7. **생산자 프로세스 코드 (가정)** 
  1. next_produced 아이템 생성: 생산할 다음 아이템을 생성한다. 
  2. **버퍼 가득 참 대기**: (in + 1) % BUFFER_SIZE == out 조건이 참이면 버퍼가 가득 찼으므로, 생산자는 대기(wait)한다. 
  3. **아이템 저장**: 버퍼에 공간이 있으면 in 위치에 next_produced 아이템을 저장하고 in을 증가시킨다. 
  4. in과 out이 만날 때: 버퍼가 가득 차면 생산자는 대기한다. 

8. **소비자 프로세스 코드 (가정)** 
  1. **버퍼 비어 있음 대기**: in == out 조건이 참이면 버퍼가 비어 있으므로, 소비자는 대기(wait)한다. 
  2. **아이템 가져오기**: 버퍼에 아이템이 있으면 out 위치의 아이템을 가져와 소비하고 out을 증가시킨다. 
  3. in과 out이 만날 때: 버퍼가 비어 있으면 소비자는 대기한다. 

9. **공유 메모리 방식의 동기화**: 생산자와 소비자 프로세스가 컨텍스트 스위치를 통해 동시 실행되더라도, 이 버퍼를 통해 동기화가 잘 이루어진다. 
  1. 이는 공유 메모리를 이용한 생산자-소비자 문제 해결의 기본 개념이다. 


## 4. 메시지 패싱 방식 


### 4.1. 공유 메모리 방식의 한계 및 메시지 패싱의 등장 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1044.jpg)
1. **공유 메모리 방식의 문제점** 
  1. 응용 프로그래머가 공유 메모리 영역에 대한 명시적인 접근(쓰기, 읽기)을 직접 구현해야 한다. 
  2. 생산자/소비자 프로세스의 수가 많아지면(N:M 관계) 버퍼 관리 및 동기화 로직이 매우 복잡해진다. 
  3. 이러한 복잡한 문제를 응용 프로그래머에게 전적으로 맡기는 것은 비효율적이다. 

2. **메시지 패싱의 개념**: 운영체제(OS)가 공유 메모리 관리 및 복잡한 동기화 문제를 대신 처리해주는 방식이다. 
  1. OS는 협력 프로세스들이 메시지를 주고받을 수 있도록 **API (Application Programming Interface)**를 제공한다. 
  2. 프로그래머는 단순히 메시지를 보내고(send) 받는(receive) 기능만 사용하면 된다. 


### 4.2. 메시지 패싱의 기본 기능 및 장점 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1168.jpg)
1. **기본 기능**: send(message)와 receive(message) 두 가지 기능으로 구성된다. 

2. **생산자/소비자 코드의 간결성** 
  1. 생산자는 send(next_produced)만 호출하면 된다. 
  2. 소비자는 receive(next_consumed)만 호출하면 된다. 
  3. 버퍼 가득 참/비어 있음 대기 로직 등 복잡한 동기화 처리는 OS의 시스템 콜(send, receive) 내부에서 알아서 처리된다. 
  4. 프로그래머는 훨씬 편하게 통신 기능을 구현할 수 있다. 

3. **공유 메모리 방식의 필요성 유지**: 메시지 패싱이 편리하지만, OS를 신뢰하지 못하거나 프로슈머(생산자이자 소비자) 간의 복잡한 N:M 통신과 같은 특수한 경우에는 직접 공유 메모리를 관리해야 할 필요가 있다. 


### 4.3. 메시지 패싱의 통신 링크 구현 방식 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1280.jpg)
1. **커뮤니케이션 링크**: P와 Q 프로세스 간에 메시지를 보내고 받는 기능을 제공하는 연결이다. 
  1. 겉으로는 P와 Q가 직접 통신하는 것처럼 보이지만, 실제로는 OS의 시스템 콜(send, receive)을 통해 이루어진다. 

2. **구현 방식의 다양성** 
  1. **직접 통신 (Direct Communication) vs. 간접 통신 (Indirect Communication)** 
  1. 직접 통신: 아빠가 아들에게 직접 용돈을 주는 방식이다. 
  2. 간접 통신: 아빠가 책상에 용돈을 두고 아들이 가져가는 방식이다. 
  2. **동기 통신 (Synchronous) vs. 비동기 통신 (Asynchronous)** 
  1. 동기 통신: 아빠가 용돈을 줄 때 아들의 지갑 상태를 확인하고 주는 방식이다. 
  2. 비동기 통신: 아빠가 기분 좋을 때 아무 때나 용돈을 주는 방식이다. 
  3. **자동 버퍼링 (Automatic Buffering) vs. 명시적 버퍼링 (Explicit Buffering)** 


### 4.4. 직접 통신 (Direct Communication) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1449.jpg)
1. **개념**: 각 프로세스가 통신하려는 상대방의 이름을 명시적으로 지정하여 메시지를 주고받는 방식이다. 
  1. send(P, message): P에게 메시지를 보낸다. 
  2. receive(Q, message): Q로부터 메시지를 받는다. 
  3. 가장 중요한 특징은 **누구에게 주는지, 누구로부터 받는지 명시**해야 한다는 점이다. 

2. **특성** 
  1. **자동 링크 생성**: P가 Q에게 보낸다고 명시하면 P와 Q 사이에 통신 링크가 자동으로 생성된다. 
  2. **단일 링크**: 두 프로세스(P와 Q) 쌍 간에는 정확히 하나의 링크만 존재할 수 있다. 


### 4.5. 간접 통신 (Indirect Communication) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1580.jpg)
1. **개념**: P와 Q 사이에 **중간 매개체**가 필요하다. 
  1. 메시지는 이 매개체를 통해 전송되고 수신된다. 
  2. **메일박스 (Mailbox)** 또는 **포트 (Port)**라고 불린다. 
  3. 메일박스는 메시지를 보내고 받는 저장소 역할을 하는 오브젝트이다. 
  4. **예시**: 용돈 함에 돈을 넣으면 여러 자녀가 가져갈 수 있는 방식이다. 

2. **메시지 패싱 스키마**: 
  1. send(A, message): 메일박스 A에 메시지를 보낸다. 
  2. receive(A, message): 메일박스 A로부터 메시지를 받는다. 
  3. 특정 상대방을 명시하지 않고 메일박스에 메시지를 보내거나 받는다. 

3. **특성** 
  1. **링크 생성 조건**: 두 프로세스가 특정 메일박스(포트)를 공유할 때 비로소 링크가 생성된다. 
  2. **다중 링크 가능**: 하나의 메일박스를 여러 프로세스가 공유할 수 있다. 
  1. 예시: 아빠, 엄마, 할머니가 하나의 용돈 함에 돈을 넣고, 아들, 딸, 손자가 가져갈 수 있다. 
  3. **다중 메일박스**: 여러 개의 메일박스를 만들어 복잡한 통신 링크를 구성할 수 있다. 
  1. 예시: 아빠 용돈 함, 엄마 용돈 함 등을 따로 만들어 특정 자녀만 접근하게 할 수 있다. 

4. **OS의 역할**: OS는 메일박스 관리를 위한 기능을 제공한다. 
  1. create: 새로운 메일박스를 생성한다. 
  2. send: 메일박스에 메시지를 보낸다. 
  3. receive: 메일박스에서 메시지를 받는다. 
  4. delete: 메일박스를 삭제한다. 
  5. OS가 버퍼링 및 누가 메시지를 가져갈지 등을 알아서 처리한다. 

5. **포트 (Port) 개념**: 메일박스는 운영체제에서 주로 **포트**라는 이름으로 불린다. 
  1. 특정 포트 번호는 특정 서비스(예: 텔넷 23번 포트)에 할당될 수 있다. 
  2. 웹 프로그래밍에서 8080 포트와 같이 운영체제가 사용하지 않는 포트를 임시로 할당하여 사용하는 것이 간접 통신의 예시이다. 


## 5. 메시지 패싱의 디자인 옵션: 블로킹/논블로킹 및 동기/비동기 통신 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/1940.jpg)
1. **블로킹 I/O (Blocking I/O) vs. 논블로킹 I/O (Non-blocking I/O)** 
  1. **블로킹 샌드 (Blocking Send)** 
  1. 메시지를 보낸 프로세스(생산자)는 메시지가 완전히 전송될 때까지 대기(block)한다. 
  2. 예시: 2GB 데이터를 1GB 버퍼에 전송할 때, 1GB를 전송한 후 소비자가 1GB를 가져갈 때까지 생산자는 대기한다. 
  2. **논블로킹 샌드 (Non-blocking Send)** 
  1. 메시지를 보낸 프로세스는 메시지를 보낸 후 즉시 다음 작업을 계속 수행한다. 
  2. OS가 메시지 전송을 책임지고 처리하므로, 생산자는 블록되지 않는다. 
  3. **블로킹 리시브 (Blocking Receive)** 
  1. 메시지를 받는 프로세스(소비자)는 유효한 메시지를 받을 때까지 대기(block)한다. 
  4. **논블로킹 리시브 (Non-blocking Receive)** 
  1. 메시지를 받는 프로세스는 메시지가 없으면 즉시 null을 반환하고 다음 작업을 계속 수행한다. 

2. **동기 통신 (Synchronous Communication) vs. 비동기 통신 (Asynchronous Communication)** 
  1. **동기 통신 (Synchronous Communication)** 
  1. **블로킹 I/O**를 사용하는 경우이다. 
  2. 샌드 호출 후 다음 문장으로 넘어갔다는 것은 메시지가 완전히 전송되었음을 의미한다. 
  3. 송신자와 수신자 간의 **동기화**가 보장된다. 
  4. **장점**: 메시지 전송의 확실성을 보장한다 (예: 요금 부과 서비스). 
  5. **단점**: 메시지 전송이 완료될 때까지 대기하므로 느리다. 
  2. **비동기 통신 (Asynchronous Communication)** 
  1. **논블로킹 I/O**를 사용하는 경우이다. 
  2. 샌드 호출 후 즉시 다음 작업을 수행하므로, 메시지 전송 완료 여부를 확신할 수 없다. 
  3. **장점**: 전송 후 바로 다른 작업을 할 수 있어 효율적이고 빠르다. 
  4. **단점**: 메시지 전송 실패 시 재전송 로직 등을 직접 구현해야 한다. 


## 6. IPC 개념 정리 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/Bgdii8FppOU/2384.jpg)
1. **IPC의 목적**: 프로세스들이 동시 실행되는 환경에서 프로세스 간 통신(커뮤니케이션)을 가능하게 하는 것이다. 

2. **두 가지 주요 방식** 
  1. **공유 메모리 (Shared Memory)**: 두 프로세스가 명시적으로 약속된 공유 공간에 데이터를 쓰고 읽는 방식이다. 
  1. 생산자-소비자 문제 해결에 사용된다. 
  2. **메시지 패싱 (Message Passing)**: P가 Q에게 메시지를 전달하고 받는 방식이다. 
  1. 내부의 복잡한 처리는 OS가 담당하며, 프로그래머는 send와 receive만 사용한다. 

3. **메시지 패싱의 세부 구현 옵션** 
  1. **메일박스/포트 사용**: 메시지 전달을 위해 메일박스 또는 포트를 이용한다. 
  2. **통신 방식**:
  1. **직접 통신 (Direct)**: 상대방을 명시한다. 
  2. **간접 통신 (Indirect)**: 메일박스를 통해 통신한다. 
  3. **동기화 방식**:
  1. **블로킹 I/O (Blocking I/O)**: 동기(Synchronous) 통신을 의미한다. 
  2. **논블로킹 I/O (Non-blocking I/O)**: 비동기(Asynchronous) 통신을 의미한다. 

4. **향후 학습 내용**: 다음 시간에는 유닉스에서 IPC가 실제로 어떻게 구현되는지 살펴볼 예정이다. 

