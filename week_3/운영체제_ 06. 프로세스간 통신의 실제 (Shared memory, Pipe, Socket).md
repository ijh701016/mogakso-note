
## 📌 프로세스 간 통신(IPC)의 실제 구현 방식에는 어떤 것들이 있나요?
프로세스 간 통신(IPC)의 실제 구현 방식에는 크게 <mark>공유 메모리(Shared Memory), 파이프(Pipe), 소켓(Socket) 방식</mark><mark> </mark>이 있습니다. 
##### 💡 각 IPC 구현 방식의 특징은 무엇인가요?
- **공유 메모리(Shared Memory)**: 메모리 맵 파일을 이용하여 여러 프로세스가 메모리 영역을 공유하는 방식으로, 매우 빠르지만 프로그래머가 직접 메모리 관리(오픈, 라이트, 리드, 클로즈 등)를 해야 합니다. 
- **파이프(Pipe)**: 유닉스 초창기부터 사용된 간단한 IPC 메커니즘으로, 주로 부모-자식 프로세스 간 단방향 통신에 사용되며, 양방향 통신을 위해서는 두 개의 파이프가 필요합니다. 
- **소켓(Socket)**: 네트워크에 연결된 다른 컴퓨터의 프로세스와 통신하기 위한 방식으로, IP 주소와 포트 번호를 묶어 통신 종단점을 정의하며, 원격 프로시저 호출(RPC) 개념과 연결됩니다. 


이 콘텐츠는 **프로세스 간 통신(IPC)**의 핵심 개념과 실제 활용 사례를 깊이 있게 다룹니다. 특히, 유닉스 계열 시스템의 표준인 **POSIX 셰어드 메모리**를 활용한 데이터 공유 방식과, 전통적인 **파이프(Pipe)**를 이용한 메시지 전달 방식을 구체적인 코드 예시와 함께 설명하여 실질적인 이해를 돕습니다. 나아가, 단일 시스템을 넘어 네트워크 환경에서 프로세스 간 통신을 가능하게 하는 **소켓(Socket)**과 **원격 프로시저 호출(RPC)**의 개념까지 확장하여, 분산 시스템 개발에 필요한 기초 지식을 체계적으로 제공합니다. 복잡한 IPC/RPC 개념을 명확히 이해하고 실제 시스템 개발에 적용하고자 하는 개발자나 컴퓨터 공학 전공자에게 필수적인 통찰을 제공할 것입니다.
## 1. IPC(프로세스 간 통신)의 실제 활용 사례 개요 
![image]()
1. **IPC 개념 복습 및 실제 활용 논의** 
  1. 이전 시간에 학습한 IPC의 개념을 바탕으로 실제 IPC 활용 방안을 살펴본다. 

2. **주요 IPC 시스템 액세스 사례** 
  1. **POSIX 셰어드 메모리**: 메모리 맵 파일을 이용한 데이터 공유 방식이다. 
  2. **파이프(Pipe)**: 메시지 전달 방식의 전통적인 유닉스 IPC 메커니즘이다. 


## 2. POSIX 셰어드 메모리 활용 


### 2.1. POSIX 표준 및 셰어드 메모리 개념 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/42.jpg)
1. **POSIX(Portable Operating System Interface) 정의** 
  1. 유닉스 계열 운영체제의 표준화를 위해 만들어진 인터페이스이다. 
  2. 마지막에 'X'가 붙는 것은 유닉스 계열에서 사용되기 때문이다. 
  3. 운영체제 표준화의 필요성으로 인해 등장했으며, 유닉스 계열의 난립을 줄이는 데 기여했다. 
  4. 리눅스도 POSIX 표준을 도입하고 있다. 

2. **메모리 맵 파일(Memory-Mapped File)을 이용한 셰어드 메모리** 
  1. 셰어드 메모리는 **메모리 맵 파일**을 이용하여 구현된다. 
  2. 일반적인 파일 오픈은 하드디스크에 접근하지만, 메모리에 파일을 생성하면 매우 빠르게 데이터를 처리할 수 있다. 
  3. 메모리 맵 파일을 통해 셰어드 메모리 영역을 확보한다. 

3. **셰어드 메모리 생성 과정** 
  1. shm_open() 함수를 사용하여 셰어드 메모리 파일을 생성하고 이름을 부여한다. 
  2. O_CREAT | O_RDWR 플래그와 접근 권한(예: 0666)을 설정하여 파일 디스크립터를 생성한다. 
  3. ftruncate() 함수로 셰어드 메모리 오브젝트의 크기를 지정한다 (예: 4096 바이트). 
  4. mmap() 함수를 사용하여 메모리 맵 파일을 셰어드 메모리 영역에 매핑한다. 
  1. mmap()은 읽기/쓰기가 가능한 파일로 파일 디스크립터를 받아 메모리 매핑을 수행한다. 


### 2.2. 셰어드 메모리 프로듀서(Producer) 구현 예시 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/235.jpg)
1. **프로듀서 코드 개요** 
  1. 셰어드 메모리 이름과 크기를 지정한다. 
  2. "Hello"와 "Shared Memory" 두 개의 메시지를 셰어드 메모리에 쓸 예정이다. 
  3. 파일 디스크립터(fd)와 캐릭터 포인터(ptr)를 선언한다. 

2. **셰어드 메모리 생성 및 매핑** 
  1. shm_open()으로 셰어드 메모리 파일을 생성하고 fd를 얻는다. 
  2. ftruncate()로 크기를 4096 바이트로 설정한다. 
  3. mmap()으로 fd를 읽기/쓰기 형태로 메모리에 매핑하여 셰어드 메모리 영역을 확보한다. 

3. **데이터 쓰기 및 포인터 이동** 
  1. sprintf()를 사용하여 첫 번째 메시지("Hello")를 ptr이 가리키는 메모리 공간에 쓴다. 
  2. ptr을 첫 번째 메시지의 길이만큼 이동시킨다. 
  3. 이동된 ptr 위치에 두 번째 메시지("Shared Memory")를 쓴다. 
  4. 이 과정은 파일에서 seek하는 것과 유사하다. 

4. **컴파일 및 실행** 
  1. gcc 컴파일 시 -lrt 라이브러리를 링크하여 실행한다. 
  2. 이 프로듀서 프로세스는 셰어드 메모리 영역에 데이터를 쓰는 역할을 한다. 


### 2.3. 셰어드 메모리 컨슈머(Consumer) 구현 예시 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/412.jpg)
1. **컨슈머 코드 개요** 
  1. 프로듀서와 동일하게 shm_open() 및 mmap()을 사용하여 셰어드 메모리 영역을 매핑한다. 
  2. 이름이 같으므로 동일한 셰어드 메모리 영역을 리턴받는다. 

2. **데이터 읽기 및 출력** 
  1. 컨슈머는 읽기(O_RDONLY) 모드로 셰어드 메모리에 접근한다. 
  2. printf()를 사용하여 ptr이 가리키는 메모리 내용을 출력한다. 
  3. 메모리에 매핑된 내용이 바로 출력된다. 

3. **셰어드 메모리 해제** 
  1. shm_unlink() 함수를 사용하여 셰어드 메모리 영역을 해제한다. 
  2. 컴파일 및 실행 시 프로듀서와 동일하게 -lrt 라이브러리를 사용한다. 


### 2.4. 셰어드 메모리 실습 및 주의사항 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/487.jpg)
1. **실습 코드 확인** 
  1. 제공된 코드는 shm_open을 통해 메모리에 매핑하고, sprintf로 문자열을 쓴 후 포인터를 이동하여 다음 문자열을 쓰는 방식이다. 
  2. 문자열 외에 바이너리 데이터도 쓸 수 있다. 

2. **프로듀서 실행 결과** 
  1. gcc로 컴파일 후 프로듀서(a.out)를 실행하면, 셰어드 메모리에 데이터를 쓰지만 화면에 아무것도 출력하지 않고 종료된다. 
  2. 데이터는 셰어드 메모리 영역에 남아있게 된다. 

3. **컨슈머 실행 결과** 
  1. 미리 컴파일된 SHM_consumer를 실행하면, 프로듀서가 쓴 "Hello Shared Memory"가 출력된다. 
  2. 이는 컨슈머가 메모리 맵을 통해 셰어드 메모리에 접근하여 데이터를 읽어왔기 때문이다. 

4. shm_unlink()의 중요성 
  1. 컨슈머 코드에 shm_unlink()가 포함되어 있어, 실행 후 셰어드 메모리 영역이 해제된다. 
  2. shm_unlink()가 실행된 후 컨슈머를 다시 실행하면, 셰어드 메모리가 존재하지 않으므로 세그멘테이션 폴트(Segmentation Fault)가 발생할 수 있다. 

5. **교재 코드 활용 권장** 
  1. 교재에 제공된 3.16_producer와 3.16_consumer 코드를 활용하여 직접 실험해 볼 것을 권장한다. 


## 3. 파이프(Pipe)를 이용한 메시지 패싱 


### 3.1. 셰어드 메모리의 한계와 파이프의 등장 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/694.jpg)
1. **셰어드 메모리의 단점** 
  1. shm_open, mmap, shm_unlink 등 개발자가 직접 관리해야 할 부분이 많아 부담스럽다. 

2. **파이프의 특징** 
  1. 유닉스 초창기부터 사용된 IPC 메커니즘으로, 두 프로세스 간의 통신 도구 역할을 한다. 
  2. 셰어드 메모리보다 구현이 간단하다. 


### 3.2. 파이프의 통신 방식 및 제약 사항 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/737.jpg)
1. **단방향(Unidirectional) 통신** 
  1. 파이프는 기본적으로 한 방향으로만 데이터가 흐르도록 설계된다. 
  2. 양방향 통신을 구현하려면 두 개의 파이프를 사용해야 한다. 
  3. 이는 하프 듀플렉스(Half-duplex) 또는 풀 듀플렉스(Full-duplex) 통신과 관련이 있다. 

2. **부모-자식(Parent-Child) 관계 필수** 
  1. 파이프를 이용한 통신은 일반적으로 부모-자식 관계의 프로세스 간에만 가능하다. 
  2. 이는 구현의 편의성을 위한 제약이다. 

3. **네트워크 통신 불가** 
  1. 파이프는 동일 시스템 내에서만 작동하며, 네트워크를 통한 통신은 불가능하다. 
  2. 네트워크 통신이 가능한 파이프는 **소켓(Socket)**이라고 부른다. 


### 3.3. 파이프의 종류: 오디너리 파이프와 네임드 파이프 
![image]()
1. **오디너리 파이프(Ordinary Pipe)** 
  1. 가장 기본적인 파이프 형태로, P와 Q 두 프로세스 간의 통신에 사용된다. 
  2. 이 콘텐츠에서는 오디너리 파이프만 다룬다. 

2. **네임드 파이프(Named Pipe)** 
  1. 여러 개의 파이프에 이름을 부여하여 사용하는 방식이다. 
  2. 부모-자식 관계 없이도 통신이 가능하다는 장점이 있다. 
  3. 오디너리 파이프보다 고도화된 형태이다. 


### 3.4. 오디너리 파이프를 이용한 양방향 통신 구현 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/888.jpg)
1. **부모-자식 관계의 통신** 
  1. 오디너리 파이프는 부모 프로세스가 파이프를 생성하고, 자식 프로세스와 통신하는 데 사용된다. 
  2. 따라서 부모-자식 관계가 필수적이다. 

2. **양방향 통신을 위한 두 개의 파이프** 
  1. 양방향 통신을 위해서는 두 개의 파이프가 필요하다. 
  2. **파이프 1**: 부모에서 자식으로 데이터를 전송한다. 
  3. **파이프 2**: 자식에서 부모로 데이터를 전송한다. 
  4. 두 개의 파일 디스크립터를 사용하여 양방향 통신을 구현할 수 있다. 

3. **프로듀서-컨슈머 모델** 
  1. 두 개의 파이프를 사용하여 프로듀서(쓰는 프로세스)와 컨슈머(읽는 프로세스) 모델을 만들 수 있다. 
  2. 단방향 파이프 두 개를 사용하면 양방향 통신이 가능하다. 


### 3.5. 파이프 시스템 콜 및 코드 예시 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1000.jpg)
1. pipe() 시스템 콜 
  1. pipe() 시스템 콜은 fd 배열을 인자로 받아 두 개의 파일 디스크립터(읽기 엔드, 쓰기 엔드)를 생성하여 리턴한다. 
  2. fd은 읽기 엔드, fd은 쓰기 엔드를 의미한다. 

2. **코드 예시 설정** 
  1. READ_END와 WRITE_END를 각각 0과 1로 매크로 정의한다. 
  2. 버퍼 사이즈를 25로 설정한다. 
  3. write_msg는 "Greeting" 문자열을, read_msg는 읽어온 데이터를 저장하는 데 사용된다. 

3. **프로세스 생성 및 역할 분담** 
  1. fork() 시스템 콜을 사용하여 부모 프로세스와 자식 프로세스를 생성한다. 
  2. **부모 프로세스 (PID > 0)** 
  1. 읽기 엔드를 닫고(close(fd[READ_END])), 쓰기 엔드(fd[WRITE_END])에 write_msg를 쓴다. 
  3. **자식 프로세스 (PID == 0)** 
  1. 쓰기 엔드를 닫고(close(fd[WRITE_END])), 읽기 엔드(fd[READ_END])로부터 데이터를 읽어 read_msg에 저장한다. 
  2. 읽어온 read_msg를 출력한다. 
  4. 이 과정을 통해 "Greeting" 메시지가 부모에서 자식으로 전달된다. 


### 3.6. 파이프 실습 및 포크(Fork)와의 연관성 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1113.jpg)
1. **실행 결과 확인** 
  1. 컴파일된 a.out을 실행하면, 자식 프로세스에서 "Greeting" 메시지를 읽어 출력하는 것을 확인할 수 있다. 

2. **포크와 파이프의 연동** 
  1. fork()를 통해 부모와 자식 프로세스가 동시에 실행된다. 
  2. pipe()로 생성된 두 개의 파일 디스크립터(fd, fd)는 부모와 자식 프로세스 모두에게 상속된다. 
  3. 부모가 fd에 쓰면 자식이 fd으로 받을 수 있다. 

3. **추가 실습 제안** 
  1. 현재는 단방향 통신만 구현되었으므로, 자식 프로세스가 부모에게 다시 메시지를 보내는 양방향 통신을 직접 구현해 볼 것을 제안한다. 


## 4. 네트워크 IPC: 소켓(Socket)과 RPC(원격 프로시저 호출) 


### 4.1. 네트워크 환경에서의 IPC 필요성 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1246.jpg)
1. **기존 IPC의 한계** 
  1. 셰어드 메모리나 파이프는 단일 PC 내에서만 작동하는 IPC 방식이다. 
  2. 현대 컴퓨터는 대부분 네트워크에 연결되어 있으므로, 다른 컴퓨터의 프로세스와 통신할 필요가 있다. 
  3. 네트워크 환경에서는 메모리 공유나 파이프를 직접 사용할 수 없다. 

2. **소켓의 등장** 
  1. 네트워크 환경에서 프로세스 간 통신을 위해 **소켓**이라는 개념이 등장했다. 


### 4.2. 소켓(Socket)의 개념 및 구성 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1324.jpg)
1. **소켓의 정의** 
  1. 통신을 위한 양 종단(endpoint)을 의미한다. 
  2. 네트워크로 연결된 두 컴퓨터 간의 통신 채널(파이프 형태)을 의미한다. 

2. **소켓의 구성 요소** 
  1. **IP 주소**: 컴퓨터를 식별하는 고유 주소이다. 
  2. **포트 번호**: 특정 컴퓨터 내에서 통신할 프로세스를 식별하는 번호이다. 
  3. **IP 주소 + 포트 번호 = 소켓**: 이 두 가지를 묶으면 네트워크 상의 특정 통신 종단을 식별할 수 있다. 


### 4.3. RPC(Remote Procedure Call)의 등장 배경 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1406.jpg)
1. **소켓 통신의 복잡성** 
  1. 소켓을 통해 데이터를 주고받을 때, 서로 다른 시스템 아키텍처(예: 64비트/32비트 머신, 리틀 엔디안/빅 엔디안)로 인해 데이터 표현 방식이 달라지는 문제가 발생한다. 
  2. 데이터 타입(문자열, 정수, 부동소수점 등)과 길이를 일일이 지정하고 변환해야 하는 복잡성이 있다. 

2. **RPC의 개념** 
  1. **원격 프로시저 호출(Remote Procedure Call)**: 원격지에 있는 프로세스의 함수(프로시저)를 로컬 함수처럼 호출하는 개념이다. 
  2. 네트워크에 연결된 컴퓨터 간에 원격 함수 호출을 추상화한다. 
  3. **예시**: 대규모 배열의 합계를 계산할 때, 배열을 여러 부분으로 나누어 각 부분을 다른 컴퓨터의 sum 함수에 보내 계산하고 결과를 받아 합치는 방식이다. 
  4. 이를 통해 개발자는 원격 통신의 복잡성을 신경 쓰지 않고 로컬 함수를 호출하듯이 원격 함수를 사용할 수 있다. 


### 4.4. 소켓 프로그래밍의 실제 예시 (Java) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/1561.jpg)
1. **소켓의 주소 지정** 
  1. IP 주소와 포트 번호를 묶어 네트워크 상의 컴퓨터를 특정한다. 
  2. **도메인 네임**: www.google.com과 같은 도메인 네임은 DNS 서버를 통해 IP 주소로 변환된다. 
  3. **포트 번호**: IP 주소 뒤에 :80 (HTTP 기본 포트) 또는 :8080과 같이 붙여 특정 포트를 지정한다. 
  4. 브라우저는 이 정보를 바탕으로 웹 서버에 요청을 보내고 데이터를 받아 화면에 표시한다. 

2. **Java 소켓 프로그래밍의 장점** 
  1. Java는 소켓 프로그래밍을 쉽게 할 수 있는 인터페이스를 제공한다. 

3. **Java 소켓의 종류** 
  1. Socket: 연결 지향형(Connection-oriented) TCP 소켓을 의미한다. 
  2. DatagramSocket: 비연결형(Connectionless) UDP 소켓으로, 브로드캐스팅에 사용된다. 
  3. MulticastSocket: 특정 수신자 그룹에게만 데이터를 전송하는 멀티캐스트 통신에 사용된다. 
  4. 주로 Socket이 많이 사용된다. 

4. **Date Server 구현 예시** 
  1. ServerSocket 생성: ServerSocket 객체를 생성하고 포트 번호(예: 6013 또는 7078)를 지정한다. 
  1. ServerSocket은 클라이언트의 연결을 기다리므로 IP 주소를 지정할 필요가 없다. 
  2. **연결 대기 및 수락**: serverSocket.accept() 메서드를 호출하여 클라이언트의 연결 요청을 기다리고, 요청이 오면 Socket 객체(클라이언트 소켓)를 리턴한다. 
  3. **데이터 전송**: 클라이언트 소켓의 출력 스트림을 통해 현재 시간을 문자열 형태로 클라이언트에게 전송한다. 
  4. **연결 종료**: 클라이언트 소켓을 닫는다(client.close()). 
  5. **동시 처리**: 서버는 여러 클라이언트의 요청을 동시에 처리할 수 있지만, 동시 접속자 수나 포트 수에 제한이 있을 수 있다. 

5. **Date Client 구현 예시** 
  1. **서버 IP 및 포트 지정**: 클라이언트는 서버 컴퓨터의 IP 주소(예: 127.0.0.1은 로컬 호스트)와 포트 번호(예: 6013 또는 7078)를 지정하여 Socket 객체를 생성한다. 
  2. **데이터 수신**: 서버로부터 받은 데이터를 입력 스트림을 통해 읽어온다. 
  3. **데이터 출력**: 읽어온 데이터를 화면에 출력한다. 
  4. **연결 종료**: 클라이언트 소켓을 닫는다(client.close()). 
  5. **실습 권장**: 포트 번호와 IP 주소를 변경하여 직접 실행해 볼 것을 권장한다. 

6. **실행 시연** 
  1. DateServer를 실행하면 "I am listening" 메시지를 출력하며 연결을 대기한다. 
  2. DateClient를 실행하면 서버에 연결되고, 서버는 "New client is connected" 메시지를 출력한다. 
  3. 클라이언트는 서버가 보낸 현재 시간 또는 "만나서 반가워"와 같은 메시지를 받아 출력한다. 

7. **소켓을 통한 원격 통신 요약** 
  1. 이 예제를 통해 원격지에 있는 두 프로세스(P1과 P2)가 소켓을 통해 통신하는 것을 확인할 수 있다. 
  2. 소켓은 IP 주소와 포트 번호로 바인딩된 일종의 파이프이다. 


### 4.5. RPC(Remote Procedure Call)의 심화 개념 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/2265.jpg)
1. **RPC 구현의 복잡성** 
  1. RPC는 예제를 만들기가 복잡하여 개념 설명 위주로 진행된다. 
  2. 실제 산업 현장에서는 RPC가 많이 사용된다. 

2. **RPC의 다양한 구현체** 
  1. **Java**: RMI(Remote Method Invocation)로 구현된다. 
  2. **Microsoft Windows**: COM(Component Object Model) 및 DCOM(Distributed COM)으로 구현된다. 
  3. **Enterprise 환경**: EJB(Enterprise JavaBeans) 등 고급 환경에서 사용된다. 

3. **RPC의 핵심 목표** 
  1. 클라이언트가 원격 호스트에 있는 함수(프로시저)를 네트워크를 통해 호출할 수 있도록 하는 것이다. 

4. **RPC 구현의 난제: 스텁(Stub)과 스켈레톤(Skeleton)** 
  1. 클라이언트가 원격 함수를 호출하려면 원격 함수의 정보를 알아야 한다. 
  2. **스텁(Stub)**: 클라이언트 측에서 원격 함수 호출을 로컬 함수 호출처럼 보이게 하는 인터페이스이다. 
  3. **스켈레톤(Skeleton)**: 서버 측에서 스텁으로부터 전달받은 요청을 실제 원격 함수로 연결해주는 역할을 한다. 
  4. **데이터 직렬화 문제**: 파라미터를 전달할 때, 서로 다른 시스템의 엔디안(Endianness) 문제(빅 엔디안/리틀 엔디안)로 인해 데이터 표현 방식이 달라질 수 있다. 
  1. 예를 들어, 4바이트 정수 0x01020304가 리틀 엔디안에서는 04 03 02 01로, 빅 엔디안에서는 01 02 03 04로 저장될 수 있다. 

5. **객체 직렬화(Object Serialization)** 
  1. 객체를 파라미터로 전달할 때, 객체 자체뿐만 아니라 객체가 참조하는 모든 데이터(예: Person 객체의 name 필드가 참조하는 String 객체)를 함께 묶어서 보내야 한다. 
  2. 이처럼 객체와 그 참조 관계를 한꺼번에 묶어 전송 가능한 형태로 만드는 과정을 **직렬화(Serialization)**라고 한다. 

6. **마샬링(Marshalling)** 
  1. 원격 서비스 이용 시 데이터를 정렬하고 객체를 직렬화하여 주고받는 과정을 **마샬링**이라고 한다. 
  2. 파라미터를 마샬링하여 보내고, 리턴 값도 마샬링하여 받아야 한다. 

7. **IDL(Interface Definition Language)** 
  1. 이러한 복잡한 스텁, 스켈레톤 정의 및 마샬링 처리를 위해 **IDL(Interface Definition Language)**이라는 인터페이스 정의 언어를 사용한다. 

8. **RPC와 IPC의 관계** 
  1. RPC는 IPC의 확장 개념이다. 
  2. **IPC**: 컴퓨터 내부에서 두 프로세스 간의 통신을 의미한다. 
  3. **RPC**: 두 프로세스가 반드시 하나의 PC에 있을 필요 없이, 원격 네트워크에 연결된 컴퓨터 간에 통신하는 것을 의미한다. 
  4. 마샬링된 파라미터를 보내고 마샬링된 객체를 리턴받는 방식으로 작동한다. 


## 5. 다음 학습 내용 예고 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/BW3Cr0-MFxE/2604.jpg)
1. **IPC 및 RPC 학습 요약** 
  1. 두 개 이상의 프로세스 간 통신(IPC)과 그 확장 개념인 RPC를 학습했다. 

2. **자원 공유 문제 예고** 
  1. 여러 프로세스가 자원을 공유할 때 발생하는 문제(경쟁 조건 등)는 다음 장부터 심도 있게 다룰 예정이다. 

3. **스레드(Thread) 학습 예고** 
  1. 다음 시간에는 프로세스보다 가벼운 동시성 단위인 **스레드**에 대해 자세히 살펴볼 예정이다. 
  2. 스레드는 Java를 통해 쉽게 이해할 수 있다. 

