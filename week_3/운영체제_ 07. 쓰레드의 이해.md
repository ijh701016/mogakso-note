
## 📌 쓰레드란 무엇인가요?
쓰레드는 프로세스 내에서 코드 영역이나 데이터 영역을 공유하면서 프로그램 카운터, 레지스터 정보 등을 별도로 가지는 <mark>'라이트웨이트 프로세스(LWP)'</mark>입니다.
##### 💡 멀티쓰레딩의 장점은 무엇인가요?
- 리스폰시브니스: 블로킹 없이 논블로킹으로 실행 가능
- 리소스 공유: 코드와 데이터 영역을 공유하여 IPC 없이 데이터 통신 가능
- 경제성: 프로세스 생성보다 스레드 생성이 훨씬 경제적이며, 컨텍스트 스위치 비용이 적음
- 확장성(Scalability): 멀티 코어 시스템에서 병렬 처리를 통해 성능 향상 가능


운영체제에서 **쓰레드(Thread)**가 무엇인지, 그리고 왜 현대 소프트웨어 개발에 필수적인지 명확하게 이해할 수 있는 강의입니다. 하나의 프로세스 안에서 여러 작업 흐름을 동시에 처리하는 **멀티스레딩의 개념**을 실제 자바 예제를 통해 쉽게 설명하며, 응답성 향상, 자원 공유의 효율성, 경제성, 확장성 등 **멀티스레딩의 4가지 핵심 장점**을 구체적으로 배울 수 있습니다. 특히, 암달의 법칙을 통해 무조건적인 코어 수 증가가 성능 향상으로 이어지지 않는 이유를 파악하고, **병렬 프로그래밍의 도전 과제**까지 심도 있게 다루어 실질적인 개발 역량을 키우는 데 큰 도움을 줄 것입니다.
## 1. 쓰레드(Thread)의 기본 개념 및 등장 배경 


### 1.1. 프로세스와 쓰레드의 관계 
![image]()
1. **기존 프로세스 개념**:
  1. 메모리에 로드된 실행 중인 프로그램(인스트럭션)을 CPU가 가져와 실행하는 상태를 **프로세스**라고 한다. 
  2. 과거에는 하나의 프로세스가 하나의 제어 흐름(싱글 스레드 오브 컨트롤)을 가졌다. 
  3. 여러 프로세스가 동시에 실행되는 멀티 프로그래밍 환경에서는 CPU가 타임 쉐어링(Time Sharing)과 컨텍스트 스위칭(Context Switching)을 통해 프로세스들을 번갈아 실행했다. 
  4. 프로세스 간 통신(IPC)은 공유 메모리나 메시지 큐를 통해 이루어졌다. 

2. **쓰레드의 등장**:
  1. 프로세스 내에서 프로그램 카운터(Program Counter), 레지스터, 스택 정보만 별도로 유지하면, 같은 프로그램 안에서 여러 실행 흐름을 가질 수 있다. 
  2. 이를 통해 굳이 프로세스를 복제(fork)할 필요 없이 하나의 프로세스 내에서 여러 작업을 동시에 처리할 수 있게 된다. 
  3. 쓰레드는 **경량 프로세스(Lightweight Process, LWP)**라고도 불린다. 
  4. CPU 입장에서는 멀티 스레딩이 제공될 때 CPU를 점유하는 가장 기본적인 단위가 쓰레드가 된다. 
  5. 프로세스 ID(PID) 대신, 실제 CPU를 점유하는 것은 프로세스 안의 **쓰레드 ID(TID)**이다. 

3. **싱글 스레드와 멀티 스레드의 구조 비교**:
  1. **싱글 스레드**: 코드, 데이터 섹션, 오픈 파일 정보, 스택, 프로그램 카운터, 레지스터 정보를 모두 하나의 제어 흐름이 가진다. 
  2. **멀티 스레드**:
  1. **공유 영역**: 코드 섹션, 데이터 섹션, 오픈 파일 정보는 모든 쓰레드가 공유한다. 
  2. **개별 영역**: 레지스터 정보, 스택 포인터, 프로그램 카운터는 각 쓰레드가 별도로 가진다. 
  3. 이러한 구조를 통해 하나의 프로세스 내에서 여러 개의 독립적인 실행 흐름(쓰레드)이 존재할 수 있다. 


### 1.2. 멀티 프로세싱과 멀티 스레딩의 구분 
![image]()
1. **멀티 프로세싱**: 여러 개의 프로세스가 동시에 동작하는 것을 의미한다. 
2. **멀티 스레딩**: 하나의 프로세스 내에 여러 개의 쓰레드가 존재하는 것을 의미한다. 


## 2. 멀티 스레딩의 장점 


### 2.1. 응답성(Responsiveness) 향상 
![image]()
1. **문제 상황 (싱글 스레드 서버 예시)**:
  1. 과거 데이트 서버 예제에서 서버 소켓이 클라이언트 요청을 처리할 때, 하나의 요청 처리가 완료될 때까지 다음 요청을 받지 못하는 블로킹(Blocking) 방식이었다. 
  2. 만약 클라이언트가 대용량 데이터(예: 2GB 영화 파일)를 전송하면, 서버는 해당 전송이 끝날 때까지 다른 클라이언트의 요청을 처리할 수 없어 응답성이 저하된다. 

2. **멀티 스레딩을 통한 해결**:
  1. 클라이언트 요청이 들어오면, 메인 스레드는 새로운 쓰레드를 생성하여 해당 요청 처리를 맡기고, 자신은 계속해서 다음 요청을 받는다(논블로킹 방식). 
  2. 이를 통해 서버는 동시에 여러 클라이언트 요청을 처리할 수 있어 응답성이 크게 향상된다. 
  3. 현대적인 웹 서버를 포함한 대부분의 소프트웨어는 이러한 멀티 스레딩을 지원한다. 


### 2.2. 자원 공유(Resource Sharing)의 효율성 
![image]()
1. **프로세스 간 자원 공유**:
  1. 프로세스 간 통신(IPC) 시에는 공유 메모리나 OS의 메시지 큐를 사용하여 데이터를 주고받아야 한다. 
  2. 이는 별도의 메커니즘이 필요하여 복잡성이 증가한다. 

2. **쓰레드 간 자원 공유**:
  1. 쓰레드들은 동일 프로세스 내에서 코드 영역과 데이터 영역을 기본적으로 공유한다. 
  2. 따라서 별도의 공유 메모리를 만들 필요 없이, 쓰레드들이 데이터 영역을 공유 메모리처럼 직접 사용할 수 있어 자원 사용이 훨씬 자유롭고 효율적이다. 


### 2.3. 경제성(Economy) 
![image]()
1. **프로세스 생성 비용**:
  1. 새로운 프로세스를 생성하려면 코드 영역 전체를 복사하는 등 많은 자원이 필요하다. 
  2. 예를 들어, 오버워치나 배틀그라운드 같은 대용량 게임의 경우, 프로세스를 복사하는 것보다 하나의 프로세스 내에서 여러 쓰레드를 사용하는 것이 훨씬 경제적이다. 

2. **컨텍스트 스위칭 비용**:
  1. 프로세스 간 컨텍스트 스위칭은 프로세스 제어 블록(PCB) 전체를 옮겨야 하므로 비용이 많이 든다. 
  2. 쓰레드 간 컨텍스트 스위칭은 프로세스 내에서 레지스터, 스택 포인터, 프로그램 카운터 등 일부 정보만 변경하면 되므로 훨씬 간단하고 빠르다. 


### 2.4. 확장성(Scalability) 
![image]()
1. **멀티 프로세서 아키텍처 활용**:
  1. 멀티 코어 시스템(멀티 프로세서 아키텍처)에서 각 코어에 쓰레드를 할당하여 병렬 처리가 가능하다. 
  2. 이를 통해 시스템의 처리 능력을 효과적으로 확장할 수 있다. 

2. **멀티 스레딩의 중요성**:
  1. 이러한 장점들 때문에 멀티 스레딩은 현대 소프트웨어 개발에서 매우 중요한 개념이다. 
  2. 멀티 프로세싱을 먼저 배우는 이유 중 하나는 멀티 스레딩의 중요성 때문이다. 


## 3. 자바(Java)에서의 쓰레드 프로그래밍 


### 3.1. 자바 쓰레드의 특징 
![image]()
1. **자바의 쓰레드 모델**:
  1. 자바는 언어 설계 단계부터 쓰레드 모델을 도입하여 쓰레드 기반 개발을 지원한다. 
  2. API가 간략하고 쉽게 만들어져 있어 쓰레드 생성 및 관리가 용이하다. 
  3. Pthread(POSIX Threads)와 비교하면 자바의 쓰레드 프로그래밍이 훨씬 쉽다. 


### 3.2. 자바에서 쓰레드를 생성하는 세 가지 방법 
![image]()
1. **Thread 클래스 상속 (Extends Thread)** 
  1. Thread 클래스를 상속받아 public void run() 메소드를 오버라이딩(재정의)한다. 
  2. run() 메소드 안에 쓰레드가 실행할 코드를 작성한다. 
  3. 일반적으로 쓰레드 코드는 while(true)와 같이 무한 반복하며 특정 작업을 수행하도록 구현된다. 
  4. Thread.sleep(밀리초)를 사용하여 일정 시간 대기할 수 있다. 
  5. 쓰레드 종료를 위해 InterruptedException을 캐치하여 처리한다. 
  6. **단점**: 자바는 다중 상속을 지원하지 않으므로, Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없다. 

2. **Runnable 인터페이스 구현 (Implements Runnable)** 
  1. Runnable 인터페이스를 구현하여 public void run() 메소드를 오버라이딩한다. 
  2. Runnable 인터페이스는 run() 메소드 하나만 가지고 있는 단순한 인터페이스이다. 
  3. Runnable 구현체의 인스턴스를 Thread 클래스의 생성자에 파라미터로 넘겨주어 쓰레드를 생성한다. 
  4. Thread 클래스가 Runnable 구현체의 run() 메소드를 호출하여 쓰레드를 실행한다. 
  5. **장점**: 다중 상속의 제약 없이 다른 클래스를 상속받으면서 쓰레드 기능을 구현할 수 있어 권장되는 방법이다. 

3. **람다 표현식 (Lambda Expression) 사용** 
  1. 자바 1.8부터 도입된 기능으로, Runnable 인터페이스와 같은 함수형 인터페이스를 람다 표현식으로 간결하게 구현할 수 있다. 
  2. 별도의 클래스 선언 없이 익명 쓰레드 형태로 run() 메소드의 내용을 직접 정의한다. 
  3. Runnable 타입의 객체 참조 변수를 선언하고 람다 표현식으로 run() 메소드를 대입한 후, 이를 Thread 생성자에 넘겨준다. 
  4. 간단한 쓰레드 코드를 작성할 때 유용하다. 


### 3.3. 쓰레드 실행 및 제어 
![image]()
1. **쓰레드 시작**:
  1. 생성된 Thread 인스턴스에 대해 start() 메소드를 호출한다. 
  2. start() 메소드는 run() 메소드를 직접 호출하는 것이 아니라, Thread 클래스가 내부적으로 run() 메소드를 호출하도록 한다. 
  3. start()가 호출되면 메인 쓰레드와 별개로 새로운 쓰레드가 실행되기 시작한다. 
  4. start() 호출 후 바로 메인 쓰레드가 다음 코드를 실행할 수 있으므로, 자식 쓰레드의 실행 결과가 메인 쓰레드보다 늦게 출력될 수 있다. 

2. **쓰레드 대기 (join)**:
  1. 프로세스에서 wait()를 사용하듯이, 쓰레드에서는 join() 메소드를 사용하여 다른 쓰레드의 종료를 기다릴 수 있다. 
  2. thread.join()을 호출하면 현재 실행 중인 메인 쓰레드는 해당 thread가 종료될 때까지 기다린다. 
  3. join()을 사용하면 자식 쓰레드의 실행이 완료된 후에 메인 쓰레드의 다음 코드가 실행되도록 순서를 제어할 수 있다. 


### 3.4. 쓰레드 종료 
![image]()
1. stop() 메소드 사용 지양:
  1. Thread.stop() 메소드는 사용하지 않도록 권장된다(deprecated). 
  2. 이는 쓰레드를 강제로 종료하여 데이터 불일치 등 예상치 못한 문제를 발생시킬 수 있기 때문이다. 

2. interrupt() 메소드를 통한 종료:
  1. 쓰레드 내부에서 InterruptedException을 처리하여 쓰레드를 안전하게 종료하는 것이 일반적인 방법이다. 
  2. 외부에서 interrupt() 메소드를 호출하면, 쓰레드가 sleep() 등으로 대기 중일 때 InterruptedException이 발생하여 쓰레드가 종료 로직을 수행할 수 있게 된다. 


### 3.5. 자바 쓰레드 학습의 중요성 
![image]()
1. **실습의 필요성**:
  1. 제시된 자바 쓰레드 예제(ThreadExample 1, 2, 3, 5)를 직접 실행하고 이해하는 것이 중요하다. 
  2. 프로그래밍 경험이 없거나 쓰레드 프로그래밍에 익숙하지 않더라도, 예제를 통해 동작 방식을 파악해야 한다. 

2. **향후 학습과의 연계**:
  1. 이후 프로세스 동기화(6장, 7장)와 같은 복잡한 개념을 자바 쓰레드를 기준으로 설명할 예정이므로, 쓰레드 개념을 미리 숙지해야 한다. 
  2. 실제로 코드를 들여다보지 않으면 동기화 문제를 이해하기 매우 어렵다. 


## 4. 멀티 코어 시스템과 병렬 프로그래밍의 도전 과제 


### 4.1. 멀티 코어 시스템에서의 쓰레드 활용 
![image]()
1. **멀티 코어 환경의 이점**:
  1. CPU 코어가 여러 개 있는 멀티 코어 시스템에서는 멀티 스레딩의 기능적 이점이 더욱 커진다. 
  2. 각 코어에 쓰레드를 할당하여 병렬적으로 실행할 수 있으므로, 컨텍스트 스위칭 오버헤드 없이 동시에 여러 작업을 처리할 수 있다. 
  3. 이를 통해 동시성(Concurrency)이 크게 향상된다. 

2. **인터리빙(Interleaving)과 병렬(Parallel) 처리**:
  1. **싱글 코어**: 여러 쓰레드가 시간 분할(Time Sharing) 방식으로 번갈아 실행되는 **인터리빙** 방식이다. 
  2. **멀티 코어**: 여러 쓰레드가 각기 다른 코어에서 **동시에(Parallel)** 실행될 수 있다. 
  3. 코어 수에 따라 쓰레드를 분배하여 타임 쉐어링과 병렬 처리를 조합하여 효율성을 높일 수 있다. 


### 4.2. 병렬 프로그래밍의 도전 과제 (Programming Challenges) 
![image]()
1. **태스크 식별 (Identifying Tasks)** 
  1. 어떤 작업들을 독립적으로 분리하여 병렬로 실행할 수 있는지 찾아내는 능력이 필요하다. 
  2. 예시: 100만 개의 숫자 합계는 각 부분을 나누어 병렬로 더한 후 합칠 수 있어 병렬 처리가 용이하다. 
  3. 예시: 정렬(Merge Sort)과 같은 작업은 부분 정렬 후 병합하는 과정에서 의존성(Dependency)이 발생하므로, 완전히 병렬적이지 않다. 
  4. 따라서 작업 간의 의존성을 파악하고 병렬 처리 가능한 부분을 식별하는 것이 중요하다. 

2. **밸런싱 (Balancing)** 
  1. 각 쓰레드에 균등한 작업량을 할당하여 모든 코어가 효율적으로 사용되도록 해야 한다. 
  2. 만약 작업량이 불균등하게 분배되면, 일부 쓰레드는 일찍 끝나서 놀고 있고, 다른 쓰레드는 과도하게 바쁜 상황이 발생할 수 있다. 
  3. 데이터를 어떻게 분할하고 각 코어에 할당할지 결정하는 것이 중요하다. 

3. **데이터 의존성 및 동기화 (Data Dependency & Synchronization)** 
  1. 병렬 처리되는 데이터 간의 의존성을 고려해야 한다. 
  2. 예를 들어, 부분 정렬된 결과를 합칠 때 올바른 순서로 동기화하여 병합해야 한다. 
  3. 이러한 동기화 문제는 멀티 스레딩 프로그래밍의 주요 도전 과제이다. 

4. **테스팅 및 디버깅 (Testing & Debugging)** 
  1. 싱글 스레드 프로그램은 브레이크 포인트를 설정하여 메모리 상태를 확인하며 디버깅하기 쉽다. 
  2. 하지만 멀티 스레드 프로그램은 여러 쓰레드가 동시에 실행되므로, 특정 시점에 각 쓰레드가 어떤 상태인지 예측하기 어렵다. 
  3. 따라서 멀티 스레드 시스템의 디버깅과 테스팅은 매우 어렵고 복잡하다. 


### 4.3. 병렬 처리의 종류 (데이터 병렬 처리 vs. 태스크 병렬 처리) 
![image]()
1. **데이터 병렬 처리 (Data Parallelism)**:
  1. 동일한 작업을 여러 데이터에 대해 병렬로 수행하는 방식이다. 
  2. 데이터를 여러 조각으로 나누어 각 쓰레드가 독립적으로 처리한다. 

2. **태스크 병렬 처리 (Task Parallelism)**:
  1. 서로 다른 작업을 여러 쓰레드에 할당하여 병렬로 수행하는 방식이다. 
  2. 데이터는 하나로 두고, 처리할 태스크를 쪼개어 각 쓰레드가 처리한다. 

3. **현대 분산 시스템에서의 의미**:
  1. 하둡(Hadoop)과 같은 분산 시스템에서는 컴퓨팅 자원(CPU, 메모리, 스토리지)이 클라우드 환경에서 매우 풍부하고 복잡하게 구성된다. 
  2. 이러한 환경에서는 데이터 병렬 처리와 태스크 병렬 처리의 구분이 크게 중요하지 않으며, 맵리듀스(MapReduce)와 같은 분산 처리 기법이 사용된다. 
  3. 따라서 이 단계의 병렬 처리 개념은 분산 시스템 과목에서 더 심도 있게 다루어진다. 


## 5. 암달의 법칙 (Amdahl's Law) 
![image]()
1. **암달의 법칙 정의**:
  1. CPU 코어 수가 무조건 많다고 해서 시스템 성능이 비례적으로 향상되는 것은 아니라는 법칙이다. 
  2. 시스템의 전체 작업 중 **직렬(Serial)로 처리될 수밖에 없는 부분의 비율**이 성능 향상에 큰 영향을 미친다. 

2. **공식**:
  1. Speedup <= 1 / (S + (1-S)/N) 
  2. Speedup: 성능 향상 배율 
  3. S: 전체 시스템 작업 중 **직렬로 실행되어야 하는 부분의 비율** (0 <= S <= 1) 
  4. N: 코어(프로세서)의 개수 

3. **예시 및 해석**:
  1. **S = 0.25 (25%가 직렬 처리)**:
  1. 코어 2개일 때: Speedup은 약 1.6배이다. (이론적으로 100% 병렬 처리 가능하면 2배) 
  2. 코어 4개일 때: Speedup은 약 2.28배이다. (이론적으로 100% 병렬 처리 가능하면 4배) 
  2. **결론**: 직렬 처리 부분이 25%만 존재해도, 코어 수가 증가하더라도 성능 향상 폭은 크게 제한된다. 
  3. **그래프 해석**: 직렬 처리 비율이 50%인 경우, 코어 수가 아무리 늘어나도 성능 향상은 2배를 넘을 수 없다. 직렬 처리 비율이 높을수록 코어 수 증가에 따른 성능 향상 효과는 미미해진다. 

4. **시사점**:
  1. 코어 수가 많다고 무조건 좋은 것이 아니며, 모든 작업이 병렬 처리 가능한 것이 아니라면 코어 수 증가는 큰 의미가 없다. 
  2. 따라서 병렬 프로그래밍 시 직렬 처리 부분을 최소화하는 것이 성능 향상에 매우 중요하다. 


## 6. 다음 학습 내용 
![image]()
1. 이번 시간에는 쓰레드의 개념과 자바를 이용한 기본 쓰레드 프로그래밍을 학습했다. 
2. 다음 시간에는 자바 외에 Pthread와 같은 다른 쓰레드 모델과 쓰레드 동기화 문제에 대해 심도 있게 다룰 예정이다. 

