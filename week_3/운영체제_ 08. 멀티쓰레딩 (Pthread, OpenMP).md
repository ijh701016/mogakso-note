

운영체제에서 **멀티쓰레딩**의 핵심 개념을 깊이 있게 이해하고 싶은 분들을 위한 강의입니다. **유저 스레드**와 **커널 스레드**의 차이점부터 시작하여, 이들이 어떻게 상호작용하는지 다양한 매핑 모델(Many-to-One, One-to-One, Many-to-Many)을 통해 명확하게 설명합니다. 특히, 리눅스/유닉스 계열에서 널리 사용되는 **Pthread** 라이브러리와 C/C++에서 컴파일러 지시자를 통해 손쉽게 병렬 처리를 구현하는 **OpenMP**의 실제 코드 예시를 통해 이론을 실전에 적용하는 방법을 배울 수 있습니다. 복잡한 멀티쓰레딩 환경에서 프로세스와 스레드가 전역 변수를 어떻게 공유하고 관리하는지 구체적인 실험 결과를 통해 직접 확인하며, 효율적인 병렬 프로그래밍의 기초를 다질 수 있는 실용적인 통찰을 제공합니다.
## 1. 멀티쓰레딩 개요 및 스레드 타입 
![image]()
1. **멀티쓰레딩 소개** 
  1. 운영체제 8번째 시간으로 멀티쓰레딩에 대해 자세히 살펴볼 예정이다. 

2. **스레드의 두 가지 타입** 
  1. 스레드는 **유저 스레드(User Thread)**와 **커널 스레드(Kernel Thread)** 두 가지 타입으로 나뉜다. 

3. **유저 스레드 설명** 
  1. 프로세스 내부에서 여러 개로 동작하는 요소인 스레드는 자바에서도 지원한다. 
  2. 자바는 운영체제가 아닌 가상 머신(VM)이며, 자바 VM이 하나의 소프트웨어로 동작하면서 스레딩을 수행한다. 
  3. 유저 스레드는 운영체제가 가진 CPU 코어를 직접 제어할 수 없다. 
  4. 운영체제의 제어 없이 유저 모드에서 스레딩하는 것을 유저 스레드라고 한다. 
  5. 자바 초창기에는 운영체제 스레드와 독립적인 그린 스레드를 사용했으나, 요즘에는 운영체제 스레드를 이용하는 네이티브 스레드를 사용한다. 

4. **커널 스레드 설명** 
  1. 운영체제(OS) 입장에서는 CPU 코어를 직접 제어할 수 있다. 
  2. OS가 직접 생성하고 관리하는 스레드를 커널 스레드라고 한다. 
  3. 커널 모드에서 사용하는 스레드를 커널 스레드로 이해할 수 있다. 
  4. 커널 스레드는 커널 스페이스(커널 모드)에서 생성되는 스레드를 의미한다. 


## 2. 유저 스레드와 커널 스레드의 매핑 모델 
![image]()
1. **매핑 모델의 필요성** 
  1. 유저 스레드와 커널 스레드가 어떤 관계를 갖는지 이해하는 것이 중요하다. 

2. **매핑 모델의 종류** 
  1. **Many-to-One 모델**: 하나의 커널 스레드가 여러 유저 스레드를 감당한다. 
  1. 커널 스레드 한 개가 코어에 직접 연결되어 유저 스레드의 서비스 요청(SBC)을 받아 동작한다. 
  2. 컨텍스트 스위치를 일으키며 동작한다. 
  3. 코어가 4개인 경우, 각 코어에 스레드 하나씩을 붙여 여러 스레드를 처리할 수 있다. 
  4. 수백, 수천 개의 유저 스레드를 하나의 커널 스레드로 감당하기 어렵다는 문제가 있다. 
  2. **One-to-One 모델**: 하나의 유저 스레드를 하나의 커널 스레드에 매핑한다. 
  1. 커널 스레드가 부족하면 여러 유저 스레드를 하나의 커널 스레드에 붙일 수 있다. 
  3. **Many-to-Many 모델**: 여러 유저 스레드가 여러 커널 스레드로부터 서비스를 받는다. 
  1. 안정된 커널 스레드에 유저 스레드들이 매핑되어 처리 후 반납하는 방식으로 동작한다. 
  4. 이 외에 Two-Level 모델도 존재한다. 


## 3. 스레드 라이브러리 및 Pthread 


### 3.1. 스레드 라이브러리 개요 
![image]()
1. **스레드 라이브러리의 역할** 
  1. 스레드를 사용하기 위해서는 POSIX 라이브러리처럼 스레드 라이브러리가 필요하다. 
  2. 스레드 라이브러리는 스레드 생성, 관리(종료, 블록 등) 기능을 제공한다. 

2. **주요 스레드 라이브러리** 
  1. **Pthread**: POSIX가 만든 스레드 라이브러리로, 주로 리눅스/유닉스 계열에서 사용된다. 
  2. **Windows Threads**: 윈도우즈 운영체제에서 사용된다. 
  3. **Grand Central Dispatch (GCD)**: 애플 운영체제(macOS, iOS)에서 사용된다. 
  4. **Java Threads**: 자바 가상 머신(JVM)에서 사용되며, JVM은 운영체제에 따라 Windows Threads나 Pthread를 이용한다. 


### 3.2. Pthread 사용법 및 예제 
![image]()
1. **Pthread 표준 및 구현** 
  1. Pthread는 IEEE 1003.1C 표준으로 스레드의 동작 방식을 정의한다. 
  2. 대부분의 리눅스/유닉스 시스템에서 Pthread 표준을 구현하여 사용한다. 

2. **Pthread 코드 구조** 
  1. pthread.h 헤더 파일을 포함해야 한다. 
  2. 스레드가 실행할 함수는 void <em>runner(void </em>param) 형태로 정의된다. 
  3. 이는 자바의 public void run() 메서드와 유사하다. 

3. **Pthread 스레드 생성 및 실행 예제** 
  1. **메인 함수에서 스레드 생성**: pthread_create() 함수를 사용하여 스레드를 생성한다. 
  1. pthread_create()는 자바의 new Thread()와 유사하다. 
  2. runner 함수를 지정하고 파라미터를 전달한다. 
  2. **스레드 대기**: pthread_join() 함수를 사용하여 스레드가 종료될 때까지 메인 스레드가 대기한다. 
  3. runner 함수 내부 동작: 
  1. void *param으로 전달된 파라미터를 atoi() 함수로 정수형으로 변환한다. 
  2. 0부터 파라미터 값까지의 합을 계산하여 sum 변수에 저장한다. 
  3. 예를 들어, 10을 넘기면 1부터 10까지의 합인 55가 계산된다. 
  4. **스레드 종료**: pthread_exit() 함수를 호출하여 스레드를 종료한다. 

4. **컴파일 및 실행** 
  1. 컴파일 시 -pthread 옵션을 주어야 스레드 기능을 지원한다. 
  2. 예제 코드는 argv로 받은 인자를 runner 스레드로 넘겨 1부터 해당 숫자까지의 합을 계산하고, 메인 스레드에서 sum을 출력한다. 
  3. gcc -pthread example.c -o a.out으로 컴파일하고, ./a.out 10과 같이 실행하면 55가 출력된다. 


### 3.3. Pthread와 Fork 혼합 예제 
![image]()
1. **프로세스와 스레드 개수 문제 (연습문제 4.17)** 
  1. **문제**: fork()와 pthread_create()가 혼합된 코드에서 생성되는 유니크한 프로세스와 스레드의 개수를 묻는 문제이다. 
  2. **코드 분석**: 
  1. p0 프로세스가 fork()를 호출하여 p1을 생성한다. 
  2. p1이 다시 fork()를 호출하여 p2를 생성한다. 
  3. p2가 다시 fork()를 호출하여 p3를 생성한다. 
  4. p0와 p1이 각각 pthread_create()를 호출하여 스레드를 생성한다. 
  5. 이후 p0, p1, p2가 다시 fork()를 호출하여 p4, p5, p6를 생성한다. 
  3. **결과**: 
  1. 유니크한 프로세스는 총 6개(p0, p1, p2, p3, p4, p5, p6)가 생성된다. 
  2. 명시적으로 pthread_create()에 의해 생성되는 스레드는 2개이다. 
  3. (참고: 모든 프로세스도 스레드로 볼 수 있으나, 여기서는 명시적으로 생성된 스레드만 계산한다.) 

2. **전역 변수 공유 문제 (연습문제 4.19)** 
  1. **문제**: fork()로 생성된 프로세스와 pthread_create()로 생성된 스레드 간의 전역 변수 공유 여부를 확인하는 문제이다. 
  2. **코드 분석**: 
  1. 메인 프로세스(p0)가 fork()를 호출하여 자식 프로세스(p1)를 생성한다. 
  2. p0는 wait()를 호출하여 p1이 종료될 때까지 대기한다. 
  3. p1은 pthread_create()를 호출하여 스레드를 생성하고 pthread_join()으로 대기한다. 
  4. 생성된 스레드는 runner 함수를 실행하며, 이 함수 내에서 전역 변수 value를 5로 변경한다. 
  5. p1의 메인 스레드는 value를 출력하며, 이 값은 5가 된다. 
  6. p1이 종료된 후 p0가 value를 출력하며, 이 값은 0이 된다. 
  3. **결과 분석**: 
  1. fork()로 생성된 프로세스(p0와 p1)는 전역 변수 value를 공유하지 않고 각자의 복사본을 가진다. 
  2. pthread_create()로 생성된 스레드들은 동일한 프로세스 내에서 전역 변수 value를 공유한다. 
  3. 이 예제를 통해 프로세스 간에는 전역 변수가 복제되고, 스레드 간에는 전역 변수가 공유됨을 알 수 있다. 

3. **복잡한 Fork와 Pthread 혼합 예제** 
  1. **코드 분석**: 
  1. 초기 PID를 출력한다. 
  2. fork() 호출 후 부모 프로세스는 wait()로 자식 프로세스를 기다린다. 
  3. 자식 프로세스에서 다시 fork()를 호출하고, 부모 프로세스는 wait()로 자식을 기다린다. 
  4. pthread_create()를 호출하여 스레드를 생성한다. 
  5. 다시 fork()를 호출하고, 부모 프로세스는 wait()로 자식을 기다린다. 
  6. runner 함수는 "I'm a thread"를 출력한다. 
  2. **실행 결과 분석**: 
  1. 메인 프로세스(예: 18937)에서 스레드가 실행되고 "I'm a thread"가 출력된다. 
  2. 여러 프로세스 ID(예: 18941, 18939, 18943 등)와 함께 "a b c d d d"와 같은 출력이 나타난다. 
  3. **프로세스 및 스레드 생성 과정**: 
  1. a 프로세스가 fork()로 b를 생성한다. 
  2. b 프로세스가 fork()로 c를 생성한다. 
  3. a와 b가 각각 pthread_create()를 호출하여 스레드를 생성한다. (2개의 스레드) 
  4. a, b, c가 다시 fork()를 호출하여 d 프로세스 3개를 생성한다. 
  5. 결과적으로 6개의 프로세스와 2개의 스레드가 생성된다. 


## 4. 암시적 스레딩 (Implicit Threading) 및 OpenMP 


### 4.1. 암시적 스레딩의 필요성 
![image]()
1. **명시적 스레딩의 어려움** 
  1. Pthread와 같은 명시적 스레딩은 복잡하고 개발자가 직접 스레드 관리에 신경 써야 한다. 
  2. 개발자가 스레드 관리에 매달리면 개발이 어려워진다. 

2. **암시적 스레딩의 목표** 
  1. 컴파일러나 라이브러리가 스레드 관리를 알아서 처리해 주기를 원한다. 
  2. 자바에서는 Executor Framework를 통해 암시적 스레딩을 지원한다. 
  3. 자바의 java.util.concurrent 패키지에서 대부분의 라이브러리를 제공한다. 
  4. C/C++에서는 **OpenMP**를 통해 컴파일러가 암시적 스레딩을 지원한다. 

3. **스레드 풀 (Thread Pool)** 
  1. **개념**: 여러 개의 스레드를 미리 생성하여 풀에 저장해 놓고, 필요할 때 풀에서 꺼내 사용하고 반납하는 방식이다. 
  2. **장점**: 
  1. 스레드 생성 및 소멸 오버헤드를 줄인다. 
  2. 초보 프로그래머가 실수로 너무 많은 스레드를 생성하여 시스템에 부하를 주는 것을 방지한다. 
  3. **구현**: Thread Pool.getThread()와 같은 인터페이스를 제공하여 개발자가 직접 스레드를 생성하지 않도록 한다. 
  4. **대기 메커니즘**: 풀에 스레드가 없으면 요청 스레드는 대기(블록)한다. 

4. **Fork-Join 모델** 
  1. Pthread의 pthread_create()나 자바의 new Thread()를 fork로, pthread_join()이나 wait()를 join으로 볼 수 있다. 
  2. 이러한 명시적 fork-join 메커니즘 외에 암시적 스레딩 방법도 존재한다. 


### 4.2. OpenMP 사용법 및 예제 
![image]()
1. **OpenMP 소개** 
  1. C, C++에서 컴파일러 지시자(compiler directive)를 통해 쉽게 병렬 처리를 지원한다. 
  2. 애플의 GCD(Grand Central Dispatch)와 유사한 개념이다. 

2. **OpenMP 동작 방식** 
  1. 개발자가 병렬로 실행될 영역(parallel region)을 지정하면, 컴파일러가 해당 코드를 병렬로 실행되도록 처리한다. 
  2. OpenMP 런타임 라이브러리가 스레드를 생성하여 병렬 처리를 수행한다. 

3. **OpenMP 코드 구조** 
  1. C 언어에서는 omp.h 헤더 파일을 포함한다. 
  2. #pragma omp parallel 지시자를 사용하여 병렬 영역을 지정한다. 
  3. 컴파일 시 -fopenmp 옵션을 주어야 한다. 

4. **OpenMP 기본 예제** 
  1. #pragma omp parallel 블록 내의 코드는 병렬로 실행된다. 
  2. 옵션 없이 컴파일하면 병렬 처리되지 않고, -fopenmp 옵션을 주면 여러 스레드에서 동시에 실행된다. 
  3. omp_set_num_threads(4) 함수로 스레드 개수를 4개로 지정할 수 있다. 
  4. omp_get_thread_num() 함수로 현재 스레드의 ID를 얻을 수 있다. 
  5. 실행 결과, 0, 1, 2, 3번 스레드가 비순차적으로 출력되는 것을 확인할 수 있다. 

5. **OpenMP 병렬 **for 루프 예제 
  1. **문제**: 천만 개의 배열 a와 b의 값을 더하여 배열 c에 저장하는 작업을 병렬 처리한다. 
  2. **코드**: #pragma omp parallel for 지시자를 for 루프 앞에 추가하면 해당 루프가 병렬로 처리된다. 
  3. **성능 비교**: 
  1. time ./a.out parallel (OpenMP 미적용) 실행 시, real 시간은 0.636초, user 시간은 0.338초, sys 시간은 0.25초가 소요된다. 
  2. time ./a.out with_openmp (OpenMP 적용) 실행 시, real 시간은 0.423초, user 시간은 1.163초, sys 시간은 0.428초가 소요된다. 
  3. **결론**: OpenMP를 적용한 병렬 처리가 실제 시간(real time) 기준으로 훨씬 빠르게 실행된다. 
  4. user 시간과 sys 시간은 스레드 대기 등 복잡한 요소로 인해 단순 비교가 어렵지만, real 시간은 실제 경과 시간을 나타내므로 병렬 처리의 효과를 명확히 보여준다. 


## 5. 멀티쓰레딩 학습 정리 
![image]()
1. **스레드 학습 완료** 
  1. 이번 강의를 통해 스레드에 대한 학습을 마쳤다. 

2. **전역 변수 공유의 중요성** 
  1. fork()(프로세스)와 Pthread(스레드)가 혼합될 때 전역 변수의 공유 여부가 달라진다. 
  2. 학생들은 실험을 통해 전역 변수 공유 여부를 직접 확인하고 학습해야 한다. 

3. **실습 권장** 
  1. 자바 스레드 프로그래밍 경험이 없거나 부족한 학생들은 자바 예제와 Pthread 예제를 직접 실행해 보며 학습하는 것이 중요하다. 

