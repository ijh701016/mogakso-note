
## 📌 운영체제의 개념과 구조는 무엇인가?
운영체제는 컴퓨터 하드웨어를 관리하는 소프트웨어로, <mark>하드웨어, 운영체제, 응용 프로그램, 사용자라는 네 가지 주요 구성 요소를 통해 컴퓨터 시스템의 매개 역할을 수행</mark><mark> </mark>합니다 
##### 💡 운영체제의 핵심적인 역할과 주요 개념은 무엇인가?
- **커널**: 운영체제의 핵심 부분으로, 시스템 프로그램과 애플리케이션 프로그램에 대한 인터페이스를 제공합니다. 
- **부트스트랩 프로그램**: 컴퓨터 전원 인가 시 가장 먼저 실행되어 운영체제를 메모리에 로딩하는 역할을 합니다. 
- **인터럽트**: CPU와 I/O 디바이스 간의 통신 방법으로, 하드웨어 장치가 CPU에 특정 이벤트를 알리는 데 사용됩니다. 
- **폰 노이만 아키텍처**: CPU가 메모리에서 명령어를 가져와 실행하는 '패치-실행' 사이클을 기반으로 하는 컴퓨터 구조입니다. 
- **멀티 프로그래밍**: 여러 프로그램을 동시에 메모리에 올려 CPU 활용 효율을 높이는 기법입니다. 
- **멀티태스킹/멀티 프로세싱**: 하나의 CPU가 여러 작업을 번갈아 처리하여 사용자에게 동시에 실행되는 것처럼 보이게 하는 시분할 방식입니다. 
- **가상화(Virtualization)**: 하나의 물리적 하드웨어에서 여러 운영체제를 동시에 실행할 수 있도록 하는 기술입니다. 


운영체제의 **핵심 개념과 구조**를 명확하게 이해할 수 있는 강의입니다. 컴퓨터 시스템의 기본적인 구성 요소부터 시작하여, **멀티 프로그래밍, 멀티태스킹, 가상화 기술** 등 현대 운영체제의 필수적인 작동 원리를 체계적으로 설명합니다. 특히, CPU 스케줄링, 인터럽트 처리, 시스템 콜과 같은 **실제 시스템 동작 방식**을 구체적인 예시와 함께 다루어, 복잡한 개념을 쉽게 파악하고 실제 시스템 개발 및 분석에 필요한 **실용적인 통찰**을 얻을 수 있습니다. 급변하는 컴퓨팅 환경 속에서 운영체제가 어떻게 진화하고 있는지 그 흐름을 파악하고 싶은 분들에게 강력히 추천합니다.
## 1. 운영체제의 개념과 구조 소개 
![image]()
1. **강의 목표**: 운영체제의 개념과 구조를 학습한다. 
2. **교재 범위**: 교재의 챕터 1장(Introduction)과 2장(Operating System Structures)을 다룬다. 
3. **학습 중요도**:
  1. 1장과 2장은 핵심 내용이 아니므로 가볍게 훑어본다. 
  2. 3장부터 10장까지가 핵심 내용이며, 특히 3장에서 8장까지는 꼼꼼하게 학습해야 한다. 
  3. 모든 내용을 알 필요는 없으며, 강의에서 다루는 내용을 위주로 확인한다. 


## 2. 운영체제의 정의 및 구성 요소 
![image]()
1. **운영체제(OS)의 정의**:
  1. 컴퓨터 하드웨어를 관리하고 운영하는 소프트웨어이다. 
  2. 애플리케이션 프로그램, 컴퓨터 사용자, 컴퓨터 하드웨어 사이에서 중간 매개(point mediator) 역할을 수행한다. 
  3. 저자는 운영체제를 "돈을 주고 사는 것" 또는 "다운로드받는 것"으로 정의한다. 
  4. **커널(Kernel)**:
  1. 항상 실행(always running)되는 핵심 프로그램이다. 
  2. 시스템 프로그램과 애플리케이션 프로그램에 대한 인터페이스를 제공한다. 
  3. 운영체제 전체에서 핵심적인 부분을 담당하며, 주로 커널의 중요한 핵심 개념만 다룬다. 

2. **컴퓨터 시스템의 4가지 주요 구성 요소**: 
  1. 하드웨어 
  2. 운영체제(Operating System) 
  3. 애플리케이션 프로그램(Application Program) 
  4. 사용자(User) 
3. **운영체제의 역할**:
  1. 하드웨어 위에 추상적인 레이어(운영체제)를 두어, 시스템 프로그래밍이나 애플리케이션 프로그래밍 시 하드웨어에 직접 접근하지 않고도 프로그래밍할 수 있도록 돕는다. 
  2. 컴파일러 같은 시스템 프로그램이나 워드프로세서, 데이터베이스 시스템 같은 응용 프로그램에 서비스를 제공한다. 
  3. 사용자는 응용 프로그램을 통해 시스템과 통신한다. 


## 3. 전통적인 컴퓨터 시스템 구조 및 부팅 과정 


### 3.1. 전통적인 컴퓨터 시스템 구조 
![image]()
1. **클래식 컴퓨터 시스템**:
  1. 과거의 모든 컴퓨터 시스템을 지칭하며, 요즘은 '클래식 컴퓨터 시스템' 또는 '전통적인 컴퓨터 시스템'이라고 부른다. 
  2. **현대 컴퓨터 시스템**: 신경망 컴퓨터, 네트워크 컴퓨터, 양자 컴퓨터 등 새로운 형태의 컴퓨터 시스템을 의미한다. 
2. **전통적인 컴퓨터 시스템의 구성**: 
  1. **CPU**: 중앙 처리 장치이다. 
  2. **디바이스 컨트롤러**: 여러 개의 디바이스 컨트롤러가 존재한다. 
  3. **공통 버스(Common Bus)**: CPU와 디바이스 컨트롤러들이 버스를 통해 연결된다. 
  4. **연결된 장치들**:
  1. **램 메모리**: 버스를 통해 CPU와 연결된다. 
  2. **디스크 컨트롤러**: HDD(하드 디스크 드라이브)나 SSD(솔리드 스테이트 드라이브)와 같은 스토리지 장치와 연결된다. 
  3. **USB 컨트롤러**: 마우스, 키보드, 프린터 등 USB 장치와 연결된다. 
  4. **그래픽 어댑터**: 모니터와 같은 IO 디바이스와 연결된다. 
  5. **무선 장치**: RF, 블루투스 등을 통해 블루투스 디바이스와 연결된다. 
  5. 운영체제는 이러한 형태의 컴퓨터 시스템을 제어해야 한다. 


### 3.2. 부트스트랩 프로그램과 부팅 과정 
![image]()
1. **부트스트랩 프로그램의 필요성**:
  1. 컴퓨터 전원을 켜면(부팅) CPU는 메모리에서 명령어를 가져와 실행해야 한다. 
  2. 메모리(RAM)는 휘발성 메모리이므로 전원을 켜면 아무것도 없다. 
  3. 따라서 CPU가 가장 먼저 로딩해야 할 명령어는 ROM(Read-Only Memory)에 저장되어 있어야 한다. 
2. **부트스트랩 프로그램의 역할**:
  1. ROM에 저장된 간단한 프로그램으로, 컴퓨터 전원이 켜지자마자 처음으로 실행된다. 
  2. 주요 임무는 하드디스크(HDD)에 있는 운영체제(특히 커널)를 메모리(RAM)에 로딩하는 것이다. 
  3. 운영체제가 메모리에 로딩되면, 그 다음부터는 운영체제가 다른 응용 프로그램들을 메모리에 로드하고 실행하는 일을 처리한다. 
  4. 이 과정을 '부트스트래핑(bootstrapping)' 또는 '부팅(booting)'이라고 한다. 


## 4. 인터럽트와 폰 노이만 아키텍처 


### 4.1. 인터럽트(Interrupt) 
![image]()
1. **개념**: CPU가 프로그램을 실행하는 도중, I/O 디바이스(주변 장치)가 CPU에게 어떤 사건이 발생했음을 알리는 방법이다. 
2. **작동 방식**:
  1. 예를 들어, 키보드에서 'A' 키를 누르면 키보드 컨트롤러가 CPU에게 'A'가 눌렸음을 알린다. 
  2. I/O 디바이스는 시스템 버스를 통해 CPU에 신호(인터럽트)를 보낸다. 
  3. CPU는 이 신호를 받아 해당 이벤트를 처리한다. 
3. **특징**:
  1. 하드웨어가 트리거(trigger)한다. 
  2. 언제든지 시스템 버스를 통해 인터럽트를 발생시킬 수 있다. 
  3. 키보드는 어떤 키가 눌렸는지, 마우스는 움직임 정보를 CPU에 보낸다. 


### 4.2. 폰 노이만 아키텍처(Von Neumann Architecture) 
![image]()
1. **개념**: 인스트럭션 사이클(Instruction Cycle)을 기반으로 하는 컴퓨터 구조이다. 
2. **작동 방식**:
  1. 컴퓨터에 내릴 수 있는 명령어를 '인스트럭션(Instruction)' 또는 '명령어 집합'으로 정의한다. 
  2. 이 명령어들로 구성된 컴퓨터 프로그램(인스트럭션즈)을 메모리에 로딩한다. 
  3. CPU는 메모리에 있는 명령어들을 하나씩 가져와(Fetch) 실행(Execute)한다. 
  4. 이 Fetch-Execute 사이클을 폰 노이만 아키텍처라고 한다. 
3. **관련 레지스터**:
  1. **인스트럭션 레지스터(IR, Instruction Register)**: 메모리에서 가져온 명령어를 저장하는 레지스터이다. 
  1. 예시: 'move'나 'add'와 같은 명령어를 저장한다. 
  2. **데이터 레지스터(Data Register)**: 명령어 실행에 필요한 데이터를 저장하는 레지스터이다 (예: R1, R2). 
  3. **ALU(Arithmetic Logic Unit)**: 산술 및 논리 연산을 수행하는 회로이다. 
  4. CPU는 IR의 명령어를 보고 데이터 레지스터의 값을 가져와 ALU에서 연산한 후, 결과를 메모리에 저장하는 과정을 반복한다. 
  5. 인스트럭션 레지스터의 개념은 프로세스 처리 시 중요하게 이해해야 한다. 


## 5. 스토리지 시스템 계층 구조 및 I/O 처리 


### 5.1. 스토리지 시스템의 계층 구조 
![image]()
1. **필요성**: 메모리(RAM)는 휘발성이므로, 비휘발성 저장 장치(스토리지 시스템)가 필요하다. 
2. **계층 구조의 기준**: 용량(Capacity)과 접근 시간(Access Time, 속도)에 따라 계층 구조를 이룬다. 
3. **계층별 저장 장치 (빠른 순서대로)**:
  1. **레지스터(Register)**: CPU 내부에 있는 가장 빠른 저장 공간으로, 회로로 구성되어 있다. 
  2. **캐시 메모리(Cache Memory)**: 레지스터 다음으로 빠르며, RAM보다 훨씬 빠르지만 비싸서 용량이 작다. 
  3. **RAM(Random Access Memory)**: 우리가 흔히 말하는 메인 메모리이다. 
  4. **SSD(Solid State Disk)**: 메모리 형태의 하드디스크 역할을 하는 저장 장치이다. 
  5. **HDD(Hard Disk Drive)**: 자기장을 이용한 하드디스크이다. 
  6. **광학 디스크(Optical Disk) 또는 자기 테이프(Magnetic Tape)**: HDD보다 많은 양을 저장하거나 백업 용도로 사용된다 (예: 은행의 장기 데이터 보존). 
4. 운영체제는 이러한 스토리지 디바이스의 계층 구조를 관리해야 한다. 


### 5.2. 복잡한 I/O 처리 구조 
![image]()
1. **실행 과정(Execution)**: CPU가 스레드(Thread) 또는 실행 중인 프로그램(Execution)을 처리하는 과정이다. 
2. **I/O 스트럭처**: CPU는 메모리에 접근하고, I/O 디바이스는 인터럽트를 발생시키며 데이터를 주고받는 복잡한 I/O 구조를 가진다. 
3. **DMA(Direct Memory Access)**:
  1. CPU가 직접 처리하지 않고, 디바이스 컨트롤러가 메모리에 직접 접근하여 데이터를 주고받는 방식이다. 
  2. 예시: 유튜브 동영상 재생 시, 네트워크 카드(디바이스)가 네트워크로부터 데이터를 받아 메모리에 직접 저장하고, LCD 디스플레이(디바이스)가 메모리에서 데이터를 가져와 화면에 표시한다. CPU는 주로 정지/재생 등 제어 기능만 담당한다. 
  3. 이러한 직접 메모리 접근 방식은 CPU의 부담을 줄여 효율성을 높인다. 
4. **운영체제 개발의 현재 동향**:
  1. OS 커널 자체는 안정화되어 개발이 많이 이루어지지 않는다. 
  2. 대부분의 운영체제 개발은 새로운 디바이스(예: 스마트폰의 카메라)가 추가될 때, 해당 디바이스를 제어하는 **디바이스 컨트롤러(드라이버)**를 만드는 일에 집중된다. 
  3. 이는 OS 개발의 90% 이상을 차지한다. 


## 6. 컴퓨터 시스템 컴포넌트의 진화: 멀티코어 및 멀티프로세서 
![image]()
1. **CPU 및 프로세서의 정의**:
  1. CPU는 명령어를 처리하는 프로세서이며, '코어(Core)'라고도 불린다. 
  2. 여러 개의 코어를 '멀티코어(Multi-core)', 여러 개의 프로세서를 '멀티프로세서(Multi-processor)'라고 한다. 
2. **멀티프로세서 시스템**:
  1. 과거에는 CPU 하나에 메모리 하나가 연결된 구조였으나, 요즘은 거의 사용되지 않는다. 
  2. **대칭형 멀티프로세싱(Symmetric Multi-Processing, SMP)**:
  1. 하나의 메모리에 여러 개의 CPU(프로세서)가 연결된 구조이다. 
  2. 각 CPU는 자체 레지스터와 캐시를 가진다. 
  3. 예시: 슈퍼컴퓨터는 수백만 개의 CPU가 연결될 수 있다. 
3. **멀티코어 시스템**:
  1. 여러 개의 CPU를 물리적으로 따로 두는 것은 비용이 많이 든다. 
  2. 하나의 CPU 칩 안에 여러 개의 코어(레지스터와 캐시를 가진 독립적인 처리 장치)를 회로로 구성하는 방식이다. 
  3. 예시: 쿼드코어(4코어), 옥타코어(8코어) 등 다양한 코어 수를 가진 CPU가 일반적이다. 
  4. 하나의 프로세서 칩에 여러 코어가 붙어있는 것을 멀티코어라고 한다. 
  5. 이러한 코어들이 또 여러 개 붙어있는 것을 멀티프로세서라고 부를 수도 있다. 


## 7. 멀티 프로그래밍, 멀티태스킹, CPU 스케줄링 


### 7.1. 멀티 프로그래밍(Multi-programming) 
![image]()
1. **개념**: 여러 개의 프로그램을 동시에 메모리에 로딩하여 실행하는 방식이다. 
2. **배경**: 과거에는 하나의 프로그램만 메모리에 로딩하여 실행하고, 끝나면 다른 프로그램을 로딩하는 방식이었다. 
3. **장점**: 여러 프로그램을 동시에 메모리에 올려놓음으로써 CPU 활용 효율을 높일 수 있다. 
4. **프로세스**: 실행 중인 프로그램을 '프로세스(Process)'라고 한다. 


### 7.2. 멀티태스킹(Multi-tasking) 및 멀티 프로세싱(Multi-processing) 
![image]()
1. **개념**: 하나의 CPU가 여러 프로세스를 시간을 나누어(Time Sharing, 시분할) 실행함으로써, 사용자 입장에서는 여러 작업이 동시에 실행되는 것처럼 보이게 하는 기술이다. 
2. **CPU 활용 효율**:
  1. CPU는 매우 빠르기 때문에, 사용자가 워드프로세서 같은 작업을 할 때 CPU는 대부분의 시간을 놀고 있다(예: 98% 유휴, 2% 작업). 
  2. 이 유휴 시간을 활용하여 다른 작업(예: 유튜브 동영상 재생)을 처리할 수 있다. 
3. **동시성(Concurrency)과 병렬성(Parallelism)**: 멀티태스킹은 동시성 개념에 해당하며, 병렬성 개념과 정확히 이해해야 한다. 


### 7.3. CPU 스케줄링(CPU Scheduling) 
![image]()
1. **문제 발생**: 메모리에 여러 프로세스가 동시에 존재하고 CPU는 한 개일 때, 어떤 프로세스를 다음에 실행할지 선택해야 하는 문제이다. 
2. **목표**: CPU 활용 효율을 최대로 높이는 프로세스 선택 방법을 찾는 것이다. 
3. **중요성**: CPU 스케줄링은 운영체제 5장에서 중요하게 다루는 내용이다. 


## 8. 유저 모드와 커널 모드 
![image]()
1. **모드 분리 필요성**:
  1. 운영체제(OS)의 핵심 부분은 커널이다. 
  2. 사용자 애플리케이션(유저 모드)에서 악성 프로그램(바이러스)을 실행하거나, 초보 프로그래머가 시스템에 해를 끼치는 작업을 할 경우 시스템이 충돌(크래시)될 수 있다. 
  3. 이를 방지하고 시스템의 안정성을 유지하기 위해 운영체제가 나쁜 행위를 막아주는 역할을 해야 한다. 
2. **유저 모드(User Mode)**:
  1. 애플리케이션 프로그램이 실행되는 모드이다. 
  2. 직접적으로 컴퓨터 하드웨어를 제어할 수 없다. 
3. **커널 모드(Kernel Mode)**:
  1. 운영체제 커널이 실행되는 모드이다. 
  2. 하드웨어를 직접 제어할 수 있는 권한을 가진다. 
4. **시스템 콜(System Call)**:
  1. 유저 모드의 프로세스가 운영체제(OS)에게 서비스를 요청하는 방법이다. 
  2. 시스템 콜이 발생하면, CPU는 커널 모드로 전환되어 시스템 콜을 처리한다. 
  3. 처리가 완료되면 다시 유저 모드로 돌아온다. 
  4. 이러한 모드 전환을 통해 OS는 시스템 자원을 보호하고 안정성을 유지한다. 
  5. 하지만 악의적인 사용자는 여전히 시스템 콜을 우회하는 방법을 찾으려 하며, OS는 이에 대응하여 패치(Patch)를 반복한다. 


## 9. 가상화 기술(Virtualization) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/fn2bUK_jL6U/1707.jpg)
1. **개념**: 하나의 물리적인 컴퓨터 시스템 위에 여러 개의 운영체제를 동시에 실행할 수 있도록 하는 기술이다. 
2. **배경**: 멀티 프로그래밍과 멀티태스킹을 통해 하나의 OS 위에서 여러 프로세스를 돌릴 수 있듯이, 하나의 하드웨어 위에서 여러 OS를 돌릴 수 있지 않을까 하는 아이디어에서 출발했다. 
3. **핵심 기술**: **VMM(Virtual Machine Monitor)** 또는 **VMM(Virtual Machine Manager)**이라는 소프트웨어를 사용한다. 
4. **작동 방식**:
  1. 하드웨어 위에 VMM을 설치한다. 
  2. VMM 위에 여러 개의 운영체제(Guest OS)를 설치하고 실행한다. 
  3. VMM은 CPU 스케줄링과 유사하게, 여러 OS를 스케줄링하여 동시에 실행되는 것처럼 보이게 한다. 
  4. 예시: 하나의 하드웨어에 젠 서버(Xen Server)나 VM웨어(VMware) 같은 VMM을 설치하고, 그 위에 리눅스, 윈도우즈, 맥 OS 등 다양한 OS를 동시에 실행할 수 있다. 
  5. 이러한 방식은 컨텍스트 스위칭(Context Switching)을 통해 여러 OS를 동시에 돌려준다. 


## 10. 컴퓨팅 환경의 변화와 운영체제의 역할 


### 10.1. 컴퓨팅 환경의 다양화 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/fn2bUK_jL6U/1883.jpg)
1. **전통적인 컴퓨팅(Traditional Computing)**: CPU 하나에 메모리 하나가 붙는 개인용 컴퓨터(PC) 시절의 환경이다. 
2. **모바일 컴퓨팅(Mobile Computing)**:
  1. 스마트폰이 대표적이며, 안드로이드나 iOS 같은 운영체제가 사용된다. 
  2. 현재 대부분의 컴퓨팅 환경을 차지한다. 
3. **클라이언트-서버 컴퓨팅(Client-Server Computing)**:
  1. 서버와 클라이언트가 네트워크를 통해 1대1로 통신하는 방식이다. 
  2. 클라이언트가 서버에 요청(Request)하고 서버가 응답(Response)하는 구조이다. 
  3. 대표적인 예시: 웹(Web) 환경 (웹 서버와 웹 브라우저). 
4. **P2P 컴퓨팅(Peer-to-Peer Computing)**:
  1. 서버 없이 클라이언트(피어)들끼리 직접 통신하며 자원을 공유하는 방식이다. 
  2. 초기 예시: 냅스터(Napster)와 같은 음악 파일 공유 서비스. 
  3. 발전된 예시: 비트토렌트(BitTorrent)와 같은 파일 공유 시스템 (파일 조각을 여러 피어에 분산 저장). 
  4. 최근 예시: 비트코인(Bitcoin)의 블록체인 기술은 P2P 컴퓨팅을 기반으로 한다. 
5. **클라우드 컴퓨팅(Cloud Computing)**:
  1. 사용자가 직접 서버를 구축하지 않고, 클라우드 서비스 제공업체(AWS, Azure, Google Cloud 등)의 컴퓨팅 자원을 네트워크를 통해 빌려 쓰는 방식이다. 
  2. **서비스 모델**: IaaS(Infrastructure as a Service), PaaS(Platform as a Service), SaaS(Software as a Service) 등이 있다. 
  3. 사용자는 터미널(UI)을 통해 클라우드가 제공하는 서비스를 조합하여 사용한다. 
  4. **엣지 컴퓨팅(Edge Computing)**: 클라우드 컴퓨팅의 확장 개념으로, 컴퓨팅 자원이 사용자 가까이에 분산되어 처리되는 방식이다. 
  5. 클라우드 환경에서는 서버, 가상 머신, 스토리지, 네트워크(CDN) 등 모든 컴퓨팅 자원이 하나의 '구름'처럼 통합되어 제공된다. 


### 10.2. 운영체제의 현재 이슈 
![image]()
1. 운영체제는 전체 컴퓨팅 환경(인바이어런먼트)의 일부분을 차지하게 되었다. 
2. 최근 운영체제의 핵심 이슈는 이러한 다양한 클라우드 서비스들을 어떻게 잘 반영해 줄 것인가이다. 
3. **실시간 임베디드 시스템(Real-Time Embedded System)**:
  1. 화성 탐사선과 같이 하드웨어를 실시간으로 직접 제어해야 하는 시스템에 사용된다. 
  2. 라즈베리파이(Raspberry Pi), VXWorks 등이 대표적인 RTOS(Real-Time Operating System)이다. 


## 11. 운영체제의 주요 서비스 및 학습 내용 


### 11.1. 운영체제가 제공하는 서비스 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/fn2bUK_jL6U/2262.jpg)
1. 사용자 인터페이스(User Interface) 
2. 프로그램 실행(Program Execution) 
3. I/O 연산(I/O Operation) 
4. 파일 시스템 통신(File System Communication) 
5. 오류 감지(Error Detection) 
6. 자원 할당(Resource Allocation) 
7. 로깅(Logging) 
8. 보호 및 보안(Protection and Security) 


### 11.2. 핵심 학습 주제 
![image]()
1. **프로세스(Process)와 스레드(Thread)**:
  1. 프로세스는 실행 중인 프로그램의 개념이며, 스레드는 프로세스의 하위 개념이다. 
  2. 하나의 프로세스/스레드만 돌리거나, 멀티태스킹/멀티 프로세싱을 통해 동시에 돌릴 수 있다. 
2. **동기화(Synchronization)**:
  1. 멀티 프로세싱을 할 때 반드시 발생하는 문제이다. 
  2. 동기화 문제를 해결하지 못하면 교착 상태(Deadlock)가 발생할 수 있다. 
3. **메모리 관리(Memory Management)**:
  1. 프로세스 및 스레드 처리를 위한 메모리 관리 방법을 학습한다. 
  2. **가상 메모리(Virtual Memory)**: 메모리 관리를 더 효율적으로 하기 위한 가상 메모리 관리 방법을 학습한다. 
4. **CPU 스케줄링(CPU Scheduling)**: 멀티 프로세싱을 위해 어떤 CPU 스케줄링 방법을 선택할지 학습한다. 
5. **학기 동안의 핵심 주제**: 프로세스, 스레드, 동기화, 메모리 관리, 가상 메모리, CPU 스케줄링이 주요 학습 내용이다. 


### 11.3. 운영체제 서비스의 구체적 내용 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/fn2bUK_jL6U/2354.jpg)
1. **프로그램 실행(Program Execution)**: 프로세스 관리(Process Management)에 해당하며, 학기 중 대부분의 시간을 할애하여 학습한다. 
2. **메모리 관리(Memory Management)**: 일부 내용을 학습한다. 
3. **파일 시스템(File System)**: 일부 내용을 학습한다. 
4. 나머지 서비스들은 이번 수업에서 다루기 어렵다. 


### 11.4. 시스템 콜(System Call)과 인터페이스 
![image]()
1. **운영체제 인터페이스 방법**:
  1. **CLI(Command Line Interface)**: 쉘(Shell)을 통해 명령어를 직접 입력하여 인터페이스하는 방식이다 (예: Bash, C Shell, ls 명령어). 
  2. **GUI(Graphical User Interface)**: 마우스로 아이콘을 클릭하는 등 그래픽 환경을 통해 인터페이스하는 방식이다 (예: macOS, Windows, Linux의 KDE/GNOME). 
  3. **터치 인터페이스**: 스마트폰(안드로이드, 아이폰) 등에서 사용되는 터치 기반 인터페이스이다. 
2. **응용 프로그램과 OS의 인터페이스**:
  1. 응용 프로그램은 **시스템 콜(System Call)**을 통해 운영체제와 인터페이스한다. 
  2. 시스템 콜은 OS가 제공하는 서비스들을 호출하는 방법이다. 
  3. 예시: read (장치에서 데이터를 읽음), write (장치에 데이터를 씀)와 같은 시스템 콜이 있다. 
3. **API(Application Programming Interface)**:
  1. 시스템 콜은 유닉스 스탠다드 헤더에 정의되어 있으며, 이러한 시스템 콜 함수를 호출하는 것을 API라고 부르기도 한다. 
  2. API는 운영체제뿐만 아니라 라이브러리 등에서도 사용되는 일반적인 용어이지만, OS의 API는 시스템 콜로 이해할 수 있다. 
4. **시스템 콜의 직접 호출의 어려움**:
  1. 사용자가 매번 open, read, write와 같은 시스템 콜을 직접 호출하는 것은 번거롭다. 
  2. 따라서 대부분의 응용 프로그램은 **라이브러리(Library)**를 통해 시스템 콜을 간접적으로 호출한다. 
  3. 예시: C 언어의 printf 함수는 스탠다드 C 라이브러리에 포함되어 있으며, 이 라이브러리 내부에서 필요한 시스템 콜(예: write)을 처리한다. 
5. **주요 시스템 콜 학습 내용**:
  1. **프로세스 제어**: fork, exec, wait 등. 
  2. **파일 조작**: open, read, write, close 등. 
  3. **장치 조작**: ioctl, read, write 등. 
  4. **정보 유지**: getpid, alarm, sleep 등. 
  5. **통신**: pipe, shmget, mmap 등. 
  6. **보호**: chmod, umask, chown 등. 
  7. 이러한 시스템 프로그래밍 관련 내용은 '시스템 프로그래밍' 교과목에서 자세히 다루며, 운영체제 개념 수업에서는 fork, exec, wait 등 핵심적인 시스템 콜의 개념만 이해하는 수준으로 다룬다. 


## 12. 마무리 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/fn2bUK_jL6U/2662.jpg)
1. 이번 시간에는 챕터 1(Introduction)과 챕터 2(OS Structures)의 개념과 용어를 살펴보았다. 
2. 교재를 다시 한번 훑어보며 개념을 확인하는 것이 좋다. 

