
## 📌 프로세스란 무엇이며, 운영체제는 프로세스를 어떻게 관리하는가?
프로세스는 <mark>'실행 중인 프로그램'</mark><mark> </mark>을 의미하며, 운영체제는 프로세스 제어 블록(PCB)이라는 구조체를 통해 프로세스의 상태, 프로그램 카운터, CPU 레지스터, 스케줄링 정보, 메모리 관리 정보, 계정 정보, I/O 상태 등 모든 정보를 저장하고 관리합니다 
##### 💡 프로세스의 생명주기(라이프 사이클) 5가지 상태는 무엇인가?
- New (생성): 프로세스가 생성된 상태 
- Running (실행): CPU를 점유하여 명령어를 실행하는 상태 
- Waiting (대기): I/O 완료 등 특정 이벤트 발생을 기다리는 상태 
- Ready (준비): CPU를 할당받을 준비가 완료되어 대기하는 상태 
- Terminated (종료): 모든 실행을 마치고 종료된 상태 


운영체제의 핵심인 **프로세스 관리**를 깊이 있게 이해할 수 있는 강의입니다. 프로그램이 단순한 파일에서 벗어나 **'실행 중인 프로그램'인 프로세스**로 전환되는 과정을 명확히 설명하며, CPU, 메모리, I/O 장치 등 프로세스 실행에 필요한 자원들이 어떻게 관리되는지 구체적으로 다룹니다. 특히, 프로세스의 **다섯 가지 생명 주기(Life Cycle)**와 운영체제가 프로세스를 효율적으로 제어하기 위해 사용하는 **PCB(Process Control Block)**의 역할, 그리고 **문맥 교환(Context Switch)**이 멀티태스킹 환경에서 어떻게 작동하는지 상세히 배울 수 있습니다. 이론적 설명과 함께 실제 코드 예시를 통해 **fork 시스템 콜**을 이용한 프로세스 생성과 종료 과정을 이해하고, 좀비 프로세스나 고아 프로세스와 같은 특수한 상황까지 다루어 운영체제 개발자 관점에서 프로세스를 바라보는 **실용적인 통찰**을 제공합니다.
## 1. 프로세스의 정의 및 필요 자원 
![image]()
1. **프로세스의 정의**:
  1. **실행 중인 프로그램**을 의미한다. 
  2. 운영체제(OS) 입장에서는 **작업의 단위**로 간주된다. 

2. **프로세스 실행에 필요한 자원**:
  1. **CPU**: 명령어를 실행하기 위해 CPU를 점유해야 한다. 
  2. **메모리**: 프로그램 코드가 메모리에 로드되어야 실행 가능하다. 
  3. **파일 및 I/O 디바이스**: 외부 장치(파일 시스템, 프린터, 모니터 등)를 통해 리소스를 관리할 수 있어야 한다. 

3. **프로그램의 프로세스 전환 과정**:
  1. 일반적으로 작성된 프로그램(예: a.out 실행 파일)은 하드디스크나 SSD 같은 스토리지 장치에 저장된다. 
  2. CPU는 스토리지에 있는 파일을 직접 실행할 수 없다. 
  3. 사용자가 프로그램을 실행(명령어 입력 또는 아이콘 더블클릭)하면, 스토리지에 저장된 프로그램이 **메모리에 로드**된다. 
  4. 메모리에 로드된 이 상태의 프로그램을 **프로세스**라고 한다. 
  5. 운영체제는 이러한 프로세스들을 관리하는 역할을 수행한다. 


## 2. 프로세스의 메모리 구조 
![image]()
1. **프로세스의 메모리 영역 구성**:
  1. **텍스트(Text) 섹션**: 실행 가능한 코드 명령어들이 저장되는 영역이다. 
  2. **데이터(Data) 섹션**: 전역 변수와 같은 초기화된 데이터가 저장되는 영역이다. 
  3. **힙(Heap) 영역**: 동적 메모리 할당(예: malloc, Java의 new)이 이루어지는 영역이다. 
  4. **스택(Stack) 섹션**: 함수 호출 시 파라미터, 리턴 주소, 지역 변수 등이 저장되는 영역이다. 

2. **메모리 구조의 논리적 배치**:
  1. 프로그램의 시작 영역을 0번지(논리적 주소)로 가정하고, 최대 메모리 영역을 Max로 설정한다. 
  2. **텍스트 섹션**이 가장 먼저 로드되고, 그 다음 **데이터 섹션**이 배치된다. 
  3. **힙 영역**은 아래에서 위로 확장되며, 필요시 추가 메모리 영역을 할당받아 늘어날 수 있다. 
  4. **스택 섹션**은 위에서 아래로 확장되며, 함수 호출 시 스택 프레임이 쌓인다. 

3. **실제 코드 예시를 통한 메모리 구조 확인**:
  1. main.c 파일을 gcc로 컴파일하여 a.out 실행 파일을 생성한다. 
  2. 이 a.out 파일이 메모리에 로드되면 프로세스가 된다. 
  3. a.out은 텍스트 섹션, 데이터 섹션(초기화된/초기화되지 않은), 힙 영역, 스택 영역을 가진다. 
  4. argc, argv와 같은 메인 함수의 파라미터는 스택 영역에 저장된다. 
  5. x와 같은 초기화되지 않은 변수는 데이터 섹션에, y=15와 같이 초기화된 변수는 데이터 섹션에 값이 저장된다. 
  6. malloc을 통해 할당된 메모리는 힙 영역에 위치하며, 해당 포인터는 스택 영역에 저장된다. 
  7. 프로그램 실행은 텍스트 섹션의 명령어를 순차적으로 실행하는 것이며, return 0으로 종료되면 운영체제에 제어권을 반환한다. 

4. size 명령어를 통한 섹션 크기 확인:
  1. gcc main.c 후 size a.out 명령어를 사용하면 텍스트, 데이터 섹션의 크기를 확인할 수 있다. 
  2. 예시로 텍스트 코드 영역은 1603, 데이터 섹션은 604 바이트로 표시될 수 있다. 


## 3. 프로세스의 생명 주기 (Life Cycle) 
![image]()
1. **다섯 가지 프로세스 상태**:
  1. **New (생성)**: 프로세스가 처음 생성된 상태이다. 
  2. **Running (실행)**: 프로세스가 CPU를 점유하여 명령어를 실행하고 있는 상태이다. 
  3. **Waiting (대기)**: 프로세스가 I/O 완료나 특정 이벤트 발생을 기다리며 CPU를 반납한 상태이다. 
  4. **Ready (준비)**: 프로세스가 CPU를 할당받을 준비가 완료되어 대기 큐에서 기다리는 상태이다. 
  5. **Terminated (종료)**: 프로세스의 모든 실행이 완료되어 종료된 상태이다. 

2. **상태 전이 다이어그램**:
  1. **New → Ready**: fork 시스템 콜 등으로 프로세스가 생성(New)된 후, 초기화 과정을 거쳐 CPU를 획득할 준비가 되면 Ready 상태가 되어 레디 큐에 들어간다. 
  2. **Ready → Running**: 운영체제의 CPU 스케줄링에 의해 CPU를 할당받으면 Running 상태로 전이된다. 이를 **디스패치(Dispatch)**라고 한다. 
  3. **Running → Ready**:
  1. 타임 쉐어링 환경에서 할당된 CPU 사용 시간이 만료되거나(타이머 인터럽트), 운영체제가 강제로 CPU를 회수하면 Ready 상태로 돌아가 다시 CPU 할당을 기다린다. 
  2. 이때는 기다릴 것이 없으므로 바로 레디 큐로 들어간다. 
  4. **Running → Waiting**:
  1. 프로세스가 I/O 작업(파일 읽기/쓰기, 프린팅 등)을 요청하거나 특정 이벤트를 기다려야 할 때, 자발적으로 CPU를 반납하고 Waiting 상태로 전이된다. 
  2. 이때는 I/O가 완료되지 않았으므로 레디 큐로 바로 갈 수 없으며, 웨이팅 큐로 이동한다. 
  5. **Waiting → Ready**: I/O 작업이 완료되거나 기다리던 이벤트가 발생하면, Waiting 상태에서 Ready 상태로 전이되어 다시 CPU 할당을 기다린다. 
  6. **Running → Terminated**: 프로세스가 명시적으로 종료 함수(예: exit, return 0)를 호출하거나, 메인 함수 실행이 완료되면 Terminated 상태로 전이된다. 
  1. 운영체제는 종료된 프로세스의 메모리 및 모든 자원을 회수한다. 


## 4. 프로세스 제어 블록 (PCB: Process Control Block) 
![image]()
1. **PCB의 정의 및 역할**:
  1. 운영체제가 프로세스를 관리하기 위해 사용하는 **데이터 구조체**이다. 
  2. 각 프로세스에 대한 모든 정보를 저장하며, 운영체제는 이 PCB를 통해 프로세스를 핸들링한다. 
  3. 리눅스에서는 **태스크 컨트롤 블록(Task Control Block)**이라고도 불린다. 

2. **PCB에 저장되는 주요 정보**:
  1. **프로세스 상태(Process State)**: 현재 프로세스가 New, Running, Waiting, Ready, Terminated 중 어떤 상태인지 나타낸다. 
  2. **프로그램 카운터(Program Counter, PC)**: 다음에 실행할 명령어의 메모리 주소를 가리킨다. 
  1. CPU가 다음에 어떤 명령어를 가져와야 할지 알려주는 중요한 정보이다. 
  2. 함수 호출, 점프, 반복문 등으로 인해 PC 값이 변경될 수 있다. 
  3. **CPU 레지스터 정보**: 프로그램 카운터를 포함하여, 인스트럭션 레지스터, 스택 포인터, 범용 레지스터 등 CPU 내 모든 레지스터의 값을 저장한다. 
  1. 이러한 CPU 레지스터 정보들을 통틀어 **문맥(Context)**이라고 이해할 수 있다. 
  4. **스케줄링 정보**: CPU 할당 및 해제에 필요한 우선순위, 스케줄링 큐 포인터 등의 정보이다. 
  5. **메모리 관리 정보**: 프로세스의 메모리 할당 정보(예: 힙 영역 크기)를 포함한다. 
  6. **계정 정보**: 프로세스를 생성한 사용자 ID 등 계정 관련 정보이다. 
  7. **I/O 상태 정보**: 프로세스가 오픈한 파일, 할당받은 I/O 버퍼, 락(lock) 상태 등 I/O 관련 정보이다. 

3. **PCB 관리 방식**:
  1. 운영체제는 시스템 내의 모든 프로세스(P0, P1, ..., Pn)에 대해 각각의 PCB를 생성하고 관리한다. 


## 5. 스레드와 멀티태스킹/멀티프로세싱 
![image]()
1. **싱글 스레드 프로세스**:
  1. 기본적인 프로세스는 **단일 실행 흐름(Single Thread of Execution)**을 가진다. 
  2. 명령어들이 한 줄로 순차적으로 실행되며, 조건문이나 반복문, 함수 호출에 따라 실행 흐름이 변경될 수 있다. 

2. **멀티태스킹 및 멀티프로세싱의 필요성**:
  1. 운영체제의 핵심 기능은 여러 프로세스를 동시에 실행하는 **멀티태스킹(Multitasking)** 또는 **멀티프로세싱(Multiprocessing)**을 제공하는 것이다. 
  2. 이는 CPU 활용률(CPU utilization)을 극대화하기 위함이다. 
  3. CPU가 매우 빠르기 때문에, 여러 프로세스 간에 CPU 코어를 빠르게 전환(스위칭)하여 사용자에게는 모든 프로그램이 동시에 실행되는 것처럼 보이게 한다. 
  4. 실제로는 특정 시점에는 하나의 프로세스만 CPU를 사용하지만, 짧은 시간 간격으로 전환되므로 동시성(Concurrency)을 제공한다. 

3. **스레드의 등장**:
  1. 프로그램이 복잡해지면서, 하나의 프로세스 내에서도 여러 개의 실행 흐름이 동시에 진행될 필요성이 생겼다. 
  2. 이를 **스레드(Thread)**라고 부르며, 스레드는 프로세스보다 **가벼운(Lightweight) 프로세스**로 간주된다. 
  3. 스레드는 프로세스 내에서 PCB와 유사한 구조를 이용해 관리될 수 있다. 
  4. 멀티 프로세싱보다 **멀티 스레딩**이 더 많은 장점을 가지며, 현대 프로그램은 대부분 멀티 스레드로 구현된다. 
  5. 병렬 처리가 필요할 때 주로 멀티 스레딩이 사용되지만, 특별한 경우 멀티 프로세싱이 사용되기도 한다. 
  6. 멀티 스레딩을 이해하기 위해서는 먼저 멀티 프로세스 개념을 알아야 한다. 


## 6. CPU 스케줄링 큐와 문맥 교환 (Context Switch) 
![image]()
1. **CPU 스케줄링 큐**:
  1. **레디 큐(Ready Queue)**: CPU를 할당받을 준비가 된 프로세스들이 대기하는 큐이다. 
  1. 일반적으로 FIFO(First-In, First-Out) 방식으로 구현되며, 링크드 리스트로 구현될 수 있다. 
  2. CPU 사용이 끝난 프로세스는 다시 레디 큐의 맨 뒤로 들어간다. 
  2. **웨이팅 큐(Waiting Queue)**: I/O 완료나 특정 이벤트 발생을 기다리는 프로세스들이 대기하는 큐이다. 
  1. I/O 디바이스별로 여러 개의 웨이팅 큐가 존재할 수 있다 (예: 디스크 I/O 큐, 터미널 I/O 큐). 
  2. 웨이팅 큐에서 대기하던 프로세스는 I/O가 완료되면 **레디 큐**로 이동한다. 

2. **문맥 교환 (Context Switch)**:
  1. **정의**: CPU 코어를 한 프로세스에서 다른 프로세스로 넘겨주는 작업이다. 
  2. **문맥(Context)**: 프로세스가 CPU를 사용하고 있는 상태를 의미하며, PCB에 저장된 정보(특히 CPU 레지스터 값, 프로그램 카운터)를 포함한다. 
  3. **작동 과정**:
  1. **현재 프로세스의 문맥 저장**: 현재 실행 중인 프로세스(예: P0)의 CPU 레지스터 값, 프로그램 카운터 등 문맥 정보를 해당 PCB(PCB0)에 저장한다. 
  2. **새로운 프로세스의 문맥 로드**: 다음에 실행될 프로세스(예: P1)의 PCB(PCB1)에 저장된 문맥 정보를 CPU 레지스터로 로드한다. 
  3. 이러한 과정은 타이머 인터럽트나 I/O 요청 등 특정 이벤트 발생 시 운영체제에 의해 이루어진다. 
  4. **목적**: 멀티태스킹 환경에서 여러 프로세스가 CPU를 공유하며 동시에 실행되는 것처럼 보이게 한다. 


## 7. 프로세스 생성 및 종료 
![image]()
1. **프로세스 생성 (Process Creation)**:
  1. **부모-자식 프로세스 관계**: 새로운 프로세스를 생성하는 프로세스를 **부모 프로세스(Parent Process)**, 생성된 프로세스를 **자식 프로세스(Child Process)**라고 한다. 
  2. fork() 시스템 콜: 유닉스/리눅스 시스템에서 fork() 시스템 콜을 이용하여 자식 프로세스를 생성한다. 
  1. fork()는 운영체제 서비스를 요청하는 시스템 콜이다. 
  2. fork() 호출 시, 부모 프로세스의 주소 공간(텍스트, 데이터, 힙, 스택)이 자식 프로세스로 **복제**된다. 
  3. fork()는 부모 프로세스에게는 자식 프로세스의 PID를 반환하고, 자식 프로세스에게는 0을 반환한다. 
  3. **프로세스 실행 방식**:
  1. **동시 실행(Concurrent Execution)**: 부모 프로세스가 자식 프로세스를 생성한 후, 부모와 자식 모두 각자의 작업을 계속 동시에 실행한다. 
  2. **대기 실행(Waiting Execution)**: 부모 프로세스가 자식 프로세스를 생성한 후, 자식 프로세스가 종료될 때까지 부모 프로세스는 대기(wait)한다. 자식 종료 후 부모가 실행을 재개한다. 
  4. **주소 공간 관리**:
  1. **주소 공간 복제**: fork()를 통해 부모 프로세스의 주소 공간을 그대로 복제하여 자식 프로세스를 생성한다. 
  2. **새로운 프로그램 로딩**: 자식 프로세스가 exec() 계열의 시스템 콜을 호출하면, 자신의 주소 공간에 새로운 프로그램을 로드하여 실행한다. 
  1. 이 경우, 자식 프로세스의 텍스트 섹션이 새로운 프로그램의 코드로 교체된다. 
  5. **프로세스 트리**: 운영체제는 최초의 프로세스(PID 1)로부터 로그인 프로세스, 쉘, GUI 등 다양한 프로세스들을 생성하며 트리 구조를 형성한다. 

2. **프로세스 종료 (Process Termination)**:
  1. **정상 종료**:
  1. 프로세스의 마지막 문장 실행 후 return되거나, exit() 시스템 콜을 명시적으로 호출하여 종료한다. 
  2. 운영체제는 종료된 프로세스의 모든 자원(메모리, 파일, I/O 버퍼 등)을 회수한다. 
  2. **비정상 종료 (특수 상황)**:
  1. **고아 프로세스(Orphan Process)**: 부모 프로세스가 자식 프로세스의 종료를 기다리지 않고 먼저 종료되어 버린 경우, 자식 프로세스는 고아가 된다. 
  2. **좀비 프로세스(Zombie Process)**: 자식 프로세스가 종료되었지만, 부모 프로세스가 wait() 시스템 콜을 호출하여 자식의 종료 상태를 회수하지 않아 자식 프로세스의 PCB 정보가 남아있는 상태이다. 
  1. 부모가 자식의 종료에 신경 쓰지 않고 자신의 일을 계속하는 경우 발생한다. 
  2. 주로 백그라운드 프로세스를 만들 때 활용될 수 있다. 

