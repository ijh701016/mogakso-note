
## 📌 데드락 회피(Deadlock Avoidance)를 위한 뱅커 알고리즘은 무엇인가요?
뱅커 알고리즘은 시스템이 항상 <mark>안전한 상태(Safe State)에만 머무르도록 하여 데드락 발생을 원천적으로 방지하는 알고리즘</mark>으로, 각 스레드가 요청할 최대 리소스 개수 등의 선행 지식을 바탕으로 리소스 할당 여부를 결정합니다.
##### 💡 뱅커 알고리즘의 주요 구성 요소는 무엇인가요?
- **Available**: 현재 사용 가능한 각 리소스 타입의 개수를 나타내는 벡터입니다.
- **Max**: 각 스레드가 요청할 각 리소스 타입의 최대 개수를 나타내는 행렬입니다.
- **Allocation**: 각 스레드에 현재 할당된 각 리소스 타입의 개수를 나타내는 행렬입니다.
- **Need**: 각 스레드가 앞으로 요청할 각 리소스 타입의 남은 개수를 나타내는 행렬입니다. (Max - Allocation) 


운영체제에서 발생하는 **교착상태(데드락)**를 효과적으로 관리하는 방법을 깊이 있게 다룹니다. 특히, 시스템이 안전한 상태를 유지하며 데드락을 회피하는 **뱅커 알고리즘**의 복잡한 원리와 실제 적용 과정을 상세한 예시를 통해 설명합니다. 단순히 이론을 나열하는 것을 넘어, **세이프티 알고리즘**과 **리소스 요청 알고리즘**이 어떻게 상호작용하여 시스템의 안정성을 보장하는지 구체적인 계산 과정을 통해 직접 따라 해 볼 수 있도록 안내합니다. 이 콘텐츠를 통해 데드락 방지, 회피, 탐지 및 복구 전략의 장단점을 명확히 이해하고, 실제 시스템 설계 시 **최적의 데드락 관리 전략**을 선택하는 데 필요한 실용적인 통찰을 얻을 수 있습니다.
## 1. 데드락 회피 (Deadlock Avoidance) 


### 1.1. 데드락 회피의 기본 개념 및 필요성 
![image]()
1. **데드락 방지(Deadlock Prevention)의 한계**: 
  1. 지난 시간에 살펴본 데드락 방지 알고리즘은 단점이 많았다. 
  2. 홀드 앤 웨이트(Hold and Wait)를 제외하고는 효과가 미미했다. 
  3. 데드락 발생 4가지 조건(상호 배제, 점유 대기, 비선점, 순환 대기) 중 한 가지를 막으려 했으나, 부작용이 많았다. 
  4. 많은 오버헤드와 낮은 장치 활용률(Device Utilization)로 시스템 성능이 저하되었다. 
  5. 멀티 스레딩을 통해 얻은 장점들이 데드락 방지 때문에 상쇄되는 문제가 발생했다. 
2. **데드락 회피(Deadlock Avoidance)의 등장**: 
  1. 데드락 회피는 어떤 자원 요청(Request)이 왔을 때, 이를 받아주기 전에 미래에 데드락이 발생할 가능성을 미리 예측하는 방법이다. 
  2. 만약 미래에 데드락이 발생할 가능성이 있다면, 해당 요청을 즉시 받아주지 않고 잠시 기다리게 한다. 
3. **추가 정보의 필요성**: 
  1. 데드락 회피를 위해서는 리소스가 어떻게 요청될지에 대한 추가 정보가 필요하다. 
  2. 예를 들어, P1이 R1을 점유한 상태에서 R2를 요구하고, P2가 R2를 점유한 상태에서 R1을 요구하면 즉시 데드락이 발생한다. 
  3. 요청 시 데드락 발생 여부를 확인하여, 발생하지 않으면 요청을 수락하고, 발생할 것 같으면 대기시킨다. 
  4. 이를 위해서는 프로세스/스레드가 요구할 **최대 자원 개수(Maximum Number of Resources)**와 같은 선행 지식(A Priori Information)이 주어져야 한다. 
  5. 시스템의 자원 할당 상태(Available 리소스 개수, Allocated 리소스 개수, Max Demand)를 알고 있다면 데드락 회피에 활용할 수 있다. 


### 1.2. 안전 상태 (Safe State) 개념 
![image]()
1. **안전 상태의 정의**: 
  1. 안전 상태(Safe State)란 시스템이 데드락이 발생하지 않는 안전한 상태에 있음을 의미한다. 
  2. 이는 각 스레드에 최대 자원까지 할당해 줄 수 있는 **특정 스레드 실행 순서(Safe Sequence)**가 존재한다는 것을 의미한다. 
  3. 이러한 순서대로 실행되면 모든 자원을 할당할 수 있으므로 데드락을 회피할 수 있다. 
  4. 안전 순서(Safe Sequence)를 찾아내는 것이 데드락 회피 알고리즘의 핵심이다. 
2. **안전 상태와 데드락의 관계**: 
  1. 시스템이 안전 상태에 있다면 데드락이 발생할 일이 없다. 
  2. 리소스 할당 그래프(Resource Allocation Graph, RAG)에서 사이클이 존재하면 불안전 상태(Unsafe State)로 갈 수 있다. 
  3. 하지만 불안전 상태라고 해서 항상 데드락이 발생하는 것은 아니다. 
  4. 안전 상태는 데드락이 발생할 수 없는 상태이며, 데드락은 오직 불안전 상태에서만 발생할 수 있다. 
  5. 모든 불안전 상태가 데드락을 발생시키지는 않지만, 데드락을 발생시킬 가능성이 있으므로 시스템이 항상 안전 상태에만 머무르도록 해야 한다. 


### 1.3. 데드락 회피 알고리즘의 종류 
![image]()
1. **단일 인스턴스 자원(Single Instance Resource)의 경우**: 
  1. **리소스 할당 그래프(RAG) 알고리즘**: 인스턴스가 하나일 경우 효과적으로 작동한다. 
  2. **클레임 엣지(Claim Edge) 추가**: 
  1. 프로세스 Pi가 자원 Rj를 미래에 요청할 수 있음을 나타내는 점선 엣지(Pi -> Rj)를 추가한다. 
  2. 이 클레임 엣지를 RAG에 추가한 후 사이클을 탐지하여 데드락 발생 가능성을 확인한다. 
  3. **사이클 탐지 및 처리**: 
  1. 사이클이 없으면 안전 상태이므로 요청을 즉시 승인(Grant)한다. 
  2. 사이클이 존재하면 불안전 상태로 진입할 수 있으므로 요청을 거부하고 대기시킨다. 
2. **다중 인스턴스 자원(Multiple Instance Resource)의 경우**: 
  1. **RAG 알고리즘의 한계**: 
  1. 자원 인스턴스가 여러 개일 경우, RAG를 이용한 사이클 탐지 방법은 정확하지 않다. 
  2. 예를 들어, 자원이 2개 할당되어도 데드락에 빠지지 않을 수 있다. 
  2. **뱅커 알고리즘(Banker's Algorithm) 적용**: 
  1. 다중 인스턴스 자원 환경에서는 뱅커 알고리즘을 적용한다. 
  2. 뱅커 알고리즘은 RAG 사이클 탐지보다 훨씬 복잡하고 무겁지만, 효율적이다. 
  3. 은행이 고객의 대출 요청을 처리하듯이, 시스템이 절대로 데드락 상태에 빠지지 않도록 관리한다. 


## 2. 뱅커 알고리즘 (Banker's Algorithm) 


### 2.1. 뱅커 알고리즘의 기본 개념 및 데이터 구조 
![image]()
1. **뱅커 알고리즘의 복잡성**: 
  1. 뱅커 알고리즘은 복잡하여 직접 문제를 풀어보지 않으면 이해하기 어렵다. 
  2. 먼저 개념을 설명하고, 실제 문제 풀이를 통해 이해를 돕는다. 
2. **기본 가정**: 
  1. 스레드의 개수를 n개, 리소스 타입의 개수를 m개라고 가정한다. 
3. **데이터 구조**: 
  1. **Available (가용 자원)**: 
  1. 길이가 m인 벡터로, 각 리소스 타입별로 현재 가용한 인스턴스 개수를 나타낸다. 
  2. Available[j] = k는 리소스 타입 j의 k개 인스턴스가 가용함을 의미한다. 
  2. **Max (최대 요구량)**: 
  1. n x m 행렬로, 각 스레드가 앞으로 요청할 리소스의 최대 개수를 나타낸다. 
  2. Max[i][j] = k는 스레드 i가 리소스 타입 j의 최대 k개 인스턴스를 요청할 수 있음을 의미한다. 
  3. **Allocation (현재 할당량)**: 
  1. n x m 행렬로, 각 스레드에 현재 할당된 리소스 인스턴스 개수를 나타낸다. 
  2. Allocation[i][j] = k는 스레드 i가 리소스 타입 j의 k개 인스턴스를 현재 점유하고 있음을 의미한다. 
  4. **Need (남은 요구량)**: 
  1. n x m 행렬로, 각 스레드가 앞으로 추가로 요청할 리소스 인스턴스 개수를 나타낸다. 
  2. Need[i][j] = k는 스레드 i가 리소스 타입 j의 k개 인스턴스를 앞으로 더 요청할 것임을 의미한다. 
  3. Need[i][j] = Max[i][j] - Allocation[i][j]로 계산된다. 


### 2.2. 뱅커 알고리즘의 두 가지 핵심 알고리즘 
![image]()
1. **Safety Algorithm (안전성 알고리즘)**: 
  1. 현재 시스템 상태가 안전한지 여부를 판단한다. 
  2. 자세한 동작 방식은 예제 풀이를 통해 이해해야 한다. 
2. **Resource-Request Algorithm (자원 요청 알고리즘)**: 
  1. 스레드의 자원 요청이 들어왔을 때, 이를 승인할지 거부할지 결정한다. 
  2. 이 알고리즘 또한 예제 풀이를 통해 이해해야 한다. 


### 2.3. 뱅커 알고리즘 예제 풀이: 안전성 알고리즘 
![image]()
1. **예제 시나리오 설정**: 
  1. **스레드**: P0부터 P4까지 5개. 
  2. **리소스 타입**: A, B, C 3개. 
  3. **총 리소스 인스턴스 개수**: A=10개, B=5개, C=7개. 
2. **현재 시스템 스냅샷 (Current State)**: 
  1. **Allocation (할당량)**:
  - P0: A=0, B=1, C=0
  - P1: A=2, B=0, C=0
  - P2: A=3, B=0, C=2
  - P3: A=2, B=1, C=1
  - P4: A=0, B=0, C=2
  2. **Max (최대 요구량)**:
  - P0: A=7, B=5, C=3
  - P1: A=3, B=2, C=2
  - P2: A=9, B=0, C=2
  - P3: A=2, B=2, C=2
  - P4: A=4, B=3, C=3
  3. **Available (가용 자원)**:
  - 총 A=10개 중 할당된 A는 0+2+3+2+0 = 7개이므로, 가용 A는 <mark>3개</mark>이다. 
  - 총 B=5개 중 할당된 B는 1+0+0+1+0 = 2개이므로, 가용 B는 <mark>3개</mark>이다. 
  - 총 C=7개 중 할당된 C는 0+0+2+1+2 = 5개이므로, 가용 C는 <mark>2개</mark>이다. 
  - 따라서 초기 Available = (3, 3, 2)이다. 
3. **Need (남은 요구량) 계산**: 
  1. Need = Max - Allocation으로 계산한다. 
  2. **Need 행렬**:
  - P0: (7-0, 5-1, 3-0) = <mark>(7, 4, 3)</mark>
  - P1: (3-2, 2-0, 2-0) = <mark>(1, 2, 2)</mark>
  - P2: (9-3, 0-0, 2-2) = <mark>(6, 0, 0)</mark>
  - P3: (2-2, 2-1, 2-1) = <mark>(0, 1, 1)</mark>
  - P4: (4-0, 3-0, 3-2) = <mark>(4, 3, 1)</mark>
4. **Safety Algorithm 실행**: 
  1. **초기화 (1단계)**: 
  1. Work 벡터를 Available과 동일하게 초기화: Work = (3, 3, 2). 
  2. Finish 벡터를 모든 스레드에 대해 false로 초기화: Finish = [false, false, false, false, false]. 
  2. **반복 (2단계)**: Finish[i]가 false이고 Need[i] <= Work인 스레드 i를 찾는다. 
  1. **P0 (i=0)**: Need = (7, 4, 3). Work = (3, 3, 2).
  - Need이 Work보다 크므로 (7 > 3, 4 > 3), P0는 현재 실행 불가. 
  2. **P1 (i=1)**: Need = (1, 2, 2). Work = (3, 3, 2).
  - Need <= Work 조건을 만족한다 (1 <= 3, 2 <= 3, 2 <= 2). P1 실행 가능. 
  - **Work 업데이트**: Work = Work + Allocation = (3, 3, 2) + (2, 0, 0) = (5, 3, 2). 
  - **Finish 업데이트**: Finish = true. 
  3. **P2 (i=2)**: Need = (6, 0, 0). Work = (5, 3, 2).
  - Need이 Work보다 크므로 (6 > 5), P2는 현재 실행 불가. 
  4. **P3 (i=3)**: Need = (0, 1, 1). Work = (5, 3, 2).
  - Need <= Work 조건을 만족한다 (0 <= 5, 1 <= 3, 1 <= 2). P3 실행 가능. 
  - **Work 업데이트**: Work = Work + Allocation = (5, 3, 2) + (2, 1, 1) = (7, 4, 3). 
  - **Finish 업데이트**: Finish = true. 
  5. **P4 (i=4)**: Need = (4, 3, 1). Work = (7, 4, 3).
  - Need <= Work 조건을 만족한다 (4 <= 7, 3 <= 4, 1 <= 3). P4 실행 가능. 
  - **Work 업데이트**: Work = Work + Allocation = (7, 4, 3) + (0, 0, 2) = (7, 4, 5). 
  - **Finish 업데이트**: Finish = true. 
  3. **반복 재개 (2단계)**: 아직 Finish가 false인 스레드가 남아있으므로 다시 처음부터 스캔한다. 
  1. **P0 (i=0)**: Need = (7, 4, 3). Work = (7, 4, 5).
  - Need <= Work 조건을 만족한다 (7 <= 7, 4 <= 4, 3 <= 5). P0 실행 가능. 
  - **Work 업데이트**: Work = Work + Allocation = (7, 4, 5) + (0, 1, 0) = (7, 5, 5). 
  - **Finish 업데이트**: Finish = true. 
  2. **P2 (i=2)**: Need = (6, 0, 0). Work = (7, 5, 5).
  - Need <= Work 조건을 만족한다 (6 <= 7, 0 <= 5, 0 <= 5). P2 실행 가능. 
  - **Work 업데이트**: Work = Work + Allocation = (7, 5, 5) + (3, 0, 2) = (10, 5, 7). 
  - **Finish 업데이트**: Finish = true. 
  4. **결과 (4단계)**: 모든 Finish[i]가 true가 되었으므로, 현재 시스템 상태는 **안전 상태(Safe State)**이다. 
  1. 발견된 안전 순서(Safe Sequence)는 <P1, P3, P4, P0, P2>이다. 
  2. 이러한 순서가 존재하기만 하면 되므로, 순서가 약간 달라져도 무방하다. 


### 2.4. 뱅커 알고리즘 예제 풀이: 자원 요청 알고리즘 
![image]()
1. **자원 요청 시나리오**: 
  1. 현재 시스템은 안전 상태이다. 
  2. P1이 Request = (1, 0, 2) (A 1개, C 2개)를 요청했다고 가정한다. 
2. **Resource-Request Algorithm 실행**: 
  1. **1단계**: Request[i] <= Need[i] 확인. 
  1. P1의 Request = (1, 0, 2). P1의 Need = (1, 2, 2). 
  2. Request <= Need (1 <= 1, 0 <= 2, 2 <= 2) 조건을 만족한다. 
  2. **2단계**: Request[i] <= Available 확인. 
  1. P1의 Request = (1, 0, 2). 현재 Available = (3, 3, 2). 
  2. Request <= Available (1 <= 3, 0 <= 3, 2 <= 2) 조건을 만족한다. 
  3. 만약 이 조건이 만족되지 않으면 요청은 즉시 거부된다. 
  3. **3단계**: 요청을 임시로 승인한 후 시스템 상태를 업데이트한다. 
  1. Available = Available - Request = (3, 3, 2) - (1, 0, 2) = (2, 3, 0). 
  2. Allocation = Allocation + Request = (2, 0, 0) + (1, 0, 2) = (3, 0, 2). 
  3. Need = Need - Request = (1, 2, 2) - (1, 0, 2) = (0, 2, 0). 
3. **Safety Algorithm 재실행**: 
  1. 임시로 업데이트된 시스템 상태에서 Safety Algorithm을 다시 돌려 안전한지 확인한다. 
  2. 이 예제에서는 Safety Algorithm을 돌리면 <P1, P3, P4, P0, P2>와 같은 안전 순서가 다시 발견된다. 
  3. 따라서 P1의 요청 (1, 0, 2)는 **승인(Accept)**된다. 
4. **다른 자원 요청 시나리오**: 
  1. **P4의 요청 **(3, 3, 0): 
  1. Request = (3, 3, 0). P4의 Need = (4, 3, 1). Request <= Need 만족. 
  2. 현재 Available = (2, 3, 0). Request = (3, 3, 0).
  3. Request가 Available보다 크므로 (3 > 2), 이 요청은 즉시 **거부(Reject)**된다. 
  2. **P0의 요청 **(0, 2, 0): 
  1. Request = (0, 2, 0). P0의 Need = (7, 4, 3). Request <= Need 만족. 
  2. 현재 Available = (2, 3, 0). Request = (0, 2, 0). Request <= Available 만족. 
  3. 임시로 요청을 승인한 후 Safety Algorithm을 돌리면, 모든 스레드가 true가 되지 않고 일부 스레드만 true가 되고 나머지는 false로 남게 된다. 
  4. 이는 이 요청을 받아주면 시스템이 불안전 상태에 진입할 가능성이 높다는 의미이므로, 요청은 **거부(Reject)**된다. 


### 2.5. 뱅커 알고리즘 요약 
![image]()
1. **Safety Algorithm (안전성 알고리즘)**: 
  1. **목적**: 현재 시스템 스냅샷이 안전한지 여부를 판단한다. 
  2. **단계**:
  1. Work 벡터를 Available로, Finish 벡터를 모두 false로 초기화한다. 
  2. Finish[i]가 false이고 Need[i] <= Work인 스레드 i를 찾는다. 
  3. 해당 스레드 i가 존재하면 Work = Work + Allocation[i]로 업데이트하고, Finish[i] = true로 설정한다. 
  4. 모든 Finish[i]가 true가 될 때까지 2, 3단계를 반복한다. 
  5. 모든 Finish[i]가 true가 되면 시스템은 안전 상태이며, 이때의 스레드 실행 순서가 안전 순서이다. 
2. **Resource-Request Algorithm (자원 요청 알고리즘)**: 
  1. **목적**: 스레드 i의 자원 요청 Request[i]를 승인할지 결정한다. 
  2. **단계**:
  1. Request[i] <= Need[i]인지 확인한다. (필요한 것보다 더 많이 요청하지 않는지) 
  2. Request[i] <= Available인지 확인한다. (가용한 자원보다 더 많이 요청하지 않는지) 
  3. 위 두 조건을 모두 만족하면, 요청을 임시로 승인한 것처럼 시스템 상태를 업데이트한다. 
  - Available = Available - Request[i]
  - Allocation[i] = Allocation[i] + Request[i]
  - Need[i] = Need[i] - Request[i]
  4. 업데이트된 시스템 상태에서 Safety Algorithm을 다시 실행한다. 
  5. Safety Algorithm 결과 시스템이 안전하면 요청을 최종 승인하고, 불안전하면 요청을 거부하고 이전 상태로 롤백한다. 


## 3. 데드락 탐지 (Deadlock Detection) 및 복구 (Recovery) 


### 3.1. 데드락 탐지의 필요성 및 장단점 
![image]()
1. **데드락 방지/회피의 한계**: 
  1. 데드락 방지나 회피는 시스템에 큰 부담을 준다. 
  2. 뱅커 알고리즘은 자원 요청 시마다 Safety Algorithm을 실행해야 하므로 오버헤드가 크다. 
  3. 매우 중요한 시스템(예: 수천억 손실이 발생하는 시스템)이 아니라면 이러한 부담스러운 기능을 제공할 이유가 적다. 
2. **데드락 탐지 및 복구 전략**: 
  1. 데드락 발생을 허용하고, 시스템이 데드락에 빠졌는지 감시한다. 
  2. 데드락이 감지되면 복구(Recovery) 절차를 수행한다. 


### 3.2. 데드락 탐지 알고리즘 
![image]()
1. **단일 인스턴스 자원(Single Instance Resource)의 경우**: 
  1. **Wait-for Graph (대기 그래프)**를 유지한다. 
  2. Wait-for Graph는 Resource Allocation Graph에서 자원 노드를 제거하고, 스레드 간의 의존성(dependency)을 직접 연결한 그래프이다. 
  3. 주기적으로 Wait-for Graph에서 **사이클을 탐지**하여 데드락 발생 여부를 확인한다. 
  4. 사이클이 있다고 해서 반드시 데드락은 아니지만, 데드락을 감지할 수 있는 유효한 수단이 된다. 
2. **다중 인스턴스 자원(Multiple Instance Resource)의 경우**: 
  1. Wait-for Graph는 다중 인스턴스 자원에는 적용하기 어렵다. 
  2. **뱅커 알고리즘과 유사한 데드락 탐지 알고리즘**을 적용한다. 
  3. **차이점**:
  1. 뱅커 알고리즘은 미래의 요청(Need)을 기반으로 하지만, 데드락 탐지 알고리즘은 현재의 요청(Request)을 기반으로 한다. 
  2. **초기화**: Allocation이 0이 아닌 스레드만 Finish를 false로 초기화하고, Allocation이 0인 스레드는 Finish를 true로 초기화하여 조사 대상에서 제외한다. (자원을 점유하지 않은 스레드는 데드락을 일으킬 가능성이 없기 때문) 
  3. **판단**: 뱅커 알고리즘은 모든 Finish가 true여야 안전 상태로 판단하지만, 데드락 탐지 알고리즘은 Finish가 false로 남아있는 스레드가 있다면 해당 스레드들이 데드락에 걸렸다고 판단한다. 
3. **데드락 탐지 알고리즘 예제**: 
  1. **시나리오 1**: Request 행렬이 주어졌을 때, 데드락 탐지 알고리즘을 돌리면 모든 스레드에 대해 Finish가 true가 되어 안전 순서가 존재한다. 이는 데드락이 없는 상태이다. 
  2. **시나리오 2**: P2가 C 자원 1개를 요청하자마자 데드락이 발생한다. 데드락 탐지 알고리즘을 돌리면 P0만 true가 되고 P1, P2, P3, P4는 false로 남아 데드락이 감지된다. 


### 3.3. 데드락 탐지 주기 및 복구 전략 
![image]()
1. **데드락 탐지 주기**: 
  1. 데드락 탐지 알고리즘은 데드락 회피보다 효율적이다. 
  2. 데드락 발생 빈도에 따라 탐지 주기를 조절한다. 
  3. 데드락이 자주 발생하지 않는 시스템(예: 1년에 1~2회)에서는 탐지 주기를 길게 가져갈 수 있다. 
  4. 스레드 수가 많을수록(예: 50만 개) 데드락 발생 가능성이 높아진다. 
  5. 자원 요청 시마다 데드락 회피 알고리즘을 돌리는 것은 불가능하므로, 탐지 알고리즘도 특정 간격(interval)을 두고 실행하는 것이 좋다. 
  6. 탐지 주기가 너무 길면 사이클이 너무 많이 존재하여 어떤 사이클이 데드락을 일으켰는지 알기 어려워진다. 
  7. 예를 들어, 1년에 한 번 발생한다면 1~2개월에 한 번 또는 하루에 한 번 정도 탐지 알고리즘을 돌려야 한다. 
2. **데드락 복구 (Deadlock Recovery)**: 
  1. 데드락이 발견되면 대부분 알람을 띄우는 것으로 끝나지만, 중요한 시스템에서는 복구 절차를 수행해야 한다. 
  2. **복구 방법 1: 프로세스/스레드 종료 (Process/Thread Termination)**: 
  1. 데드락에 관련된 모든 스레드를 정지(Terminate)시키고 재시작한다. 
  2. 이는 너무 부담스러울 수 있다. 
  3. 데드락 사이클에 있는 스레드 중 하나만 종료시켜도 연쇄적으로 데드락이 해소될 수 있다. 
  4. 가장 의심스러운 스레드 하나를 종료시키고 데드락 해소 여부를 확인하는 과정을 반복한다. 
  3. **복구 방법 2: 자원 선점 (Resource Preemption)**: 
  1. 희생양(Victim)을 선정하여 자원을 선점한다. 
  2. 가장 적은 비용(예: 가장 최근에 시작된 스레드)을 발생시키는 스레드를 희생양으로 선택한다. 
  3. 희생양 스레드로부터 자원을 빼앗아 요청하는 스레드에게 할당하고, 희생양 스레드는 롤백(Rollback) 후 재시작한다. 
  4. 이 방법은 특정 스레드가 계속 희생양이 되어 **기아 상태(Starvation)**에 빠질 수 있다. 
  5. 이를 방지하기 위해 희생양 횟수를 기록하여, 너무 많이 희생된 스레드는 제외하는 등의 조치가 필요하다. 


## 4. 데드락 관리 전략 요약 
![image]()
1. **데드락 방지 (Deadlock Prevention)**: 
  1. 데드락 발생 4가지 조건(상호 배제, 점유 대기, 비선점, 순환 대기) 중 하나를 막는 방법이다. 
  2. 하지만 효율성이 낮고 부작용이 많아 영양가가 적다. 
2. **데드락 회피 (Deadlock Avoidance)**: 
  1. **단일 인스턴스**: RAG(Resource Allocation Graph)를 이용한 Wait-for Graph를 만들어 사이클을 탐지한다. 
  2. **다중 인스턴스**: 뱅커 알고리즘을 사용하여 은행이 자원을 관리하듯이 데드락을 회피한다. 
3. **데드락 탐지 및 복구 (Deadlock Detection and Recovery)**: 
  1. 방지나 회피는 비용이 많이 들기 때문에, 데드락 발생을 허용하고 감시한다. 
  2. 데드락이 탐지되면 복구 절차를 수행한다. 
  3. 탐지 알고리즘도 뱅커 알고리즘을 활용하여 적용할 수 있다. 

