
## 📌 데드락(교착 상태)이란 무엇인가?
데드락은 <mark>어떤 프로세스 집합 내의 프로세스들이 다른 프로세스가 야기할 수 있는 이벤트를 기다리며 모두 웨이팅 상태에 있어 더 이상 진행하지 못하는 상황</mark><mark> </mark>을 의미합니다. 
##### 💡 데드락 발생의 4가지 필수 조건은?
- **상호 배제(Mutual Exclusion)**: 적어도 하나의 리소스가 공유 불가능해야 합니다. 
- **점유 대기(Hold and Wait)**: 프로세스가 하나 이상의 리소스를 점유한 채 다른 리소스를 기다려야 합니다. 
- **비선점(No Preemption)**: 리소스가 강제로 빼앗길 수 없어야 합니다. 
- **순환 대기(Circular Wait)**: 프로세스들이 순환 형태로 서로의 리소스를 기다려야 합니다. 


운영체제에서 가장 난해한 개념 중 하나인 **데드락(교착 상태)**을 명확하게 이해하고 실질적인 해결책을 모색하는 콘텐츠입니다. 데드락이 발생하는 **네 가지 필수 조건(상호 배제, 점유 대기, 비선점, 순환 대기)**을 구체적인 사례와 함께 설명하며, 각 조건이 왜 데드락을 유발하는지 깊이 있게 분석합니다. 특히, **자원 할당 그래프(RAG)**를 통해 데드락 발생 여부를 시각적으로 판단하는 방법을 제시하여 복잡한 시스템에서도 문제의 본질을 파악할 수 있도록 돕습니다. 단순한 이론 설명에 그치지 않고, 데드락을 **예방(Prevention)하려는 시도가 왜 어려운지** 현실적인 한계를 짚어주며, 다음 단계인 **회피(Avoidance)** 전략으로 나아갈 필요성을 설득력 있게 제시합니다. 이 콘텐츠를 통해 데드락의 근본 원리를 파악하고, 실제 시스템 설계 및 문제 해결에 적용할 수 있는 **실용적인 통찰**을 얻을 수 있습니다.
## 1. 데드락(교착 상태)의 개념 및 발생 조건 


### 1.1. 데드락의 정의 및 시스템 환경 
![image]()
1. **데드락의 정의**:
  1. 어떤 프로세스 집합 내의 프로세스들이 다른 프로세스가 야기할 이벤트를 기다리며 모두 웨이팅 상태에 있어, 다시는 자신의 상태를 바꿀 수 없는 상황을 의미한다. 
  2. 이는 요청한 리소스가 다른 웨이팅 스레드에 의해 점유되어 있기 때문에 발생한다. 

2. **데드락을 공부할 시스템 환경**:
  1. **유한한 자원(Finite number of resources)**: 시스템은 유한한 수의 자원을 가지고 있다. 
  2. **자원 공유**: 이 자원들은 여러 경쟁 스레드(competing threads) 또는 동기화(synchronize)가 필요한 스레드들에 의해 공유된다. 
  3. **자원의 종류 및 인스턴스**:
  - 자원은 여러 타입으로 구분될 수 있다. 
  - 각 자원 타입은 여러 개의 동일한 인스턴스(identical instances)를 가질 수 있다. 
  - **예시**:
  - CPU 사이클: 코어가 여러 개 있으면 4개까지 동시 할당 가능하며, 그 이상은 대기해야 한다. 
  - 파일: 여러 스레드가 파일을 공유할 수 있다. 
  - I/O 디바이스: 프린터, DVD/HDD/SSD 드라이브 등 동일한 리소스 타입은 어떤 인스턴스를 할당해도 만족한다. 
  - **중요성**: 리소스 타입의 개수보다는 리소스 타입 안에 들어가 있는 인스턴스의 개수가 중요하다. 

3. **스레드의 리소스 사용 절차**:
  1. **요청(Request)**: 리소스를 요청한다. 
  2. **사용(Use)**: 리소스를 사용한다. 
  3. **반납(Release)**: 사용 후 리소스를 반납한다. 
  4. **크리티컬 섹션**: Use 상태는 크리티컬 섹션으로 볼 수 있으며, 여러 자원 인스턴스가 들어갈 수 있다. 


### 1.2. 데드락 발생 예시: 뮤텍스 락 
![image]()
1. **두 개의 뮤텍스 락 사용 시 데드락 발생 가능성**:
  1. **스레드 1**: first_mutex 획득 → second_mutex 획득 → 크리티컬 섹션 진입 → second_mutex 릴리즈 → first_mutex 릴리즈. 
  2. **스레드 2**: second_mutex 획득 → first_mutex 획득 → 크리티컬 섹션 진입 → first_mutex 릴리즈 → second_mutex 릴리즈. 
  3. **문제 발생**:
  - 스레드 1이 first_mutex를 점유하고 second_mutex를 점유하려 할 때, 스레드 2가 이미 second_mutex를 점유하고 있다면 스레드 1은 대기한다. 
  - 동시에 스레드 2는 first_mutex를 점유하려 하지만, 스레드 1이 이미 first_mutex를 점유하고 있으므로 스레드 2도 대기한다. 
  - 이처럼 서로가 서로의 자원을 기다리는 **순환 대기** 상태가 되어 데드락이 발생한다. 


### 1.3. 데드락의 4가지 필수 발생 조건 
![image]()
1. **데드락 발생 조건의 중요성**:
  1. 데드락은 다음 4가지 조건이 **모두 만족**될 때만 발생한다. 
  2. 이 중 하나라도 만족하지 못하면 데드락은 발생하지 않는다. 

2. **상호 배제(Mutual Exclusion)**:
  1. **정의**: 적어도 한 개의 리소스는 **비공유 가능(non-shareable)**해야 한다. 
  2. **설명**:
  - 모든 프로세스가 읽기만 하는 파일처럼 리소스가 공유 가능하다면 데드락은 발생하지 않는다. 
  - 쓰기 작업이 필요한 경우 상호 배제가 필요하며, 이 조건이 없으면 데드락 걱정을 할 필요가 없다. 

3. **점유 대기(Hold and Wait)**:
  1. **정의**: 어떤 스레드가 적어도 한 개의 리소스를 점유(hold)한 상태에서 다른 리소스를 요청하며 대기(wait)해야 한다. 
  2. **설명**:
  - 스레드가 아무것도 점유하지 않은 상태에서 다른 리소스를 요청하는 것은 데드락을 일으킬 가능성이 없다. 
  - 자신이 뭔가를 쥐고 있으면서 다른 것을 요청해야 다른 스레드가 그 자원을 받지 못해 문제가 발생한다. 

4. **비선점(No Preemption)**:
  1. **정의**: 어떤 리소스도 강제로 선점(preempt)될 수 없어야 한다. 
  2. **설명**:
  - CPU처럼 자원을 강제로 뺏을 수 있다면 데드락은 발생하지 않는다. 
  - 파일, 프린터, 드라이브 등 어떤 자원이 선점 불가능할 때만 데드락이 발생한다. 

5. **순환 대기(Circular Wait)**:
  1. **정의**: 두 개 이상의 스레드가 서로의 자원을 기다리는 순환적인 대기 상태를 형성해야 한다. 
  2. **설명**:
  - 스레드 A가 B를 기다리고, B가 C를 기다리고, C가 A를 기다리는 형태의 순환 고리가 형성된다. 
  - 데드락에 걸린 스레드 집합은 의존성 그래프(dependency graph)를 그렸을 때 반드시 순환(circular)한다. 

6. **결론**: 이 4가지 조건이 동시에 만족되는 경우는 드물기 때문에, 억지로 예제를 만들지 않으면 데드락 예제를 만들기가 쉽지 않다. 


## 2. 자원 할당 그래프(Resource Allocation Graph, RAG)를 통한 데드락 분석 


### 2.1. RAG의 개념 및 구성 요소 
![image]()
1. **RAG의 목적**: 데드락을 정확하고 쉽게 이해하기 위해 만들어진 방향 그래프(directed graph)이다. 
2. **RAG의 구성**:
  1. **정점 집합(V)**: 두 가지 타입의 노드로 구성된다. 
  - **스레드 노드(T)**: 스레드 집합을 나타낸다 (예: P1, P2, P3). 
  - **리소스 타입 노드(R)**: 리소스 타입 집합을 나타낸다 (예: R1, R2, R3). 
  2. **간선 집합(E)**: 두 가지 타입의 방향 간선으로 구성된다. 
  - **요청 간선(Request Edge)**: 스레드 노드에서 리소스 타입 노드로 향하는 간선 (Ti → Rj). 
  - **의미**: 스레드 Ti가 리소스 Rj를 요청했음을 의미한다. 
  - **할당 간선(Assignment Edge)**: 리소스 타입 노드에서 스레드 노드로 향하는 간선 (Rj → Ti). 
  - **의미**: 리소스 Rj가 스레드 Ti에 할당되어 있음을 의미한다. 


### 2.2. RAG를 이용한 데드락 예시 분석 
![image]()
1. **뮤텍스 락 예시를 RAG로 표현**:
  1. first_mutex를 R_first, second_mutex를 R_second라고 하자. 
  2. **스레드 1 (T1)**:
  - R_first를 획득 (R_first → T1 할당 간선). 
  - R_second를 요청 (T1 → R_second 요청 간선). 
  3. **스레드 2 (T2)**:
  - R_second를 획득 (R_second → T2 할당 간선). 
  - R_first를 요청 (T2 → R_first 요청 간선). 
  4. **결과**: T1은 R_second를 기다리고, R_second는 T2에 할당되어 있으며, T2는 R_first를 기다리고, R_first는 T1에 할당되어 있어 **사이클(Cycle)**이 형성된다. 
  5. **데드락 발생**: 이러한 사이클은 데드락의 전형적인 모습이며, RAG를 통해 데드락 발생 여부를 쉽게 파악할 수 있다. 


### 2.3. RAG 사이클과 데드락 발생 여부 
![image]()
1. **RAG에 사이클이 없는 경우**:
  1. **결론**: RAG에 사이클이 없으면 데드락은 절대로 발생하지 않는다. 

2. **RAG에 사이클이 있는 경우**:
  1. **결론**: 사이클이 있더라도 데드락이 발생하지 않을 수도 있다. 
  2. **예시 (데드락 미발생)**:
  - R2 자원이 인스턴스를 2개 가지고 있고, T1, T2, T3 스레드가 존재한다. 
  - T1이 R1을 요청하고 R1은 T2에 할당, T2는 R3를 요청하고 R3는 T3에 할당, T3는 R2를 요청하고 R2는 T1에 할당되는 사이클이 존재한다. 
  - 하지만 R2의 인스턴스가 2개이므로, T1이 R2를 할당받아 작업을 처리하고 반납하면 T3가 R2를 받을 수 있게 되어 데드락이 발생하지 않는다. 
  3. **예시 (데드락 발생)**:
  - R2 자원이 인스턴스를 2개 가지고 있고, T1, T2, T3, T4 스레드가 존재한다. 
  - T1은 R2를 할당받고 R1을 요청, R1은 T3에 할당, T3는 R2를 요청한다. 
  - 동시에 T4는 R2를 할당받고 R3를 요청, R3는 T2에 할당, T2는 R2를 요청한다. 
  - 이 경우 T1과 T3, T2와 T4 사이에 각각 사이클이 형성되며, R2의 인스턴스가 2개임에도 불구하고 서로 필요한 자원을 점유하고 있어 데드락이 발생한다. 

3. **사이클 감지 활용**: RAG 사이클 감지(detection)는 데드락 회피(avoidance) 전략에서 다시 다루어질 예정이다. 


## 3. 데드락 처리 전략 
![image]()
1. **데드락의 4가지 조건**: 상호 배제, 점유 대기, 비선점, 순환 대기. 이 4가지 조건을 모두 만족할 때만 데드락이 발생한다. 

2. **데드락 처리 방법**:
  1. **무시(Ignoring)**:
  - 데드락이 발생하지 않을 것이라고 가정하고 무시하는 방법이다. 
  - 실제로 데드락이 자주 발생하지 않기 때문에 많은 시스템에서 이 방법을 사용한다. 
  - 발생하면 시스템을 재부팅하거나 복구(recovery)하는 방식으로 처리한다. 
  2. **예방(Prevention)**:
  - 데드락이 절대 일어나지 않도록 시스템을 설계하는 방법이다. 
  - 8.5절에서 다루며, 현실적으로는 거의 불가능하다. 
  - 매우 비싼 시스템(위성 제어, 이동통신 요금 시스템 등)에만 적용 가능하며, 일반적인 웹 서버 등에는 적용하기 부담스럽다. 
  3. **회피(Avoidance)**:
  - 데드락을 완전히 방지하지는 못하지만, 발생할 가능성을 피하는 방법이다. 
  - 8.6절에서 뱅커스 알고리즘(Banker's Algorithm)으로 다루며, 비교적 비싼 시스템에 적용된다. 
  4. **탐지(Detection) 및 복구(Recovery)**:
  - 데드락이 발생하면 이를 탐지하고 복구하는 방법이다. 
  - 실제 시스템에서 가장 많이 사용되는 방법이다. 
  - 알람을 통해 데드락 발생을 인지하고, 시스템을 껐다 켜지 않고도 복구할 수 있는 방법을 적용한다. 


## 4. 데드락 예방(Prevention) 전략의 한계 


### 4.1. 데드락 예방의 기본 원칙 
![image]()
1. **예방 원칙**: 데드락의 4가지 필수 조건 중 적어도 한 가지가 발생하지 않도록 막는 것이다. 


### 4.2. 각 조건별 예방 시도 및 한계 
![image]()
1. **상호 배제(Mutual Exclusion) 조건 방지**:
  1. **시도**: 모든 리소스를 공유 가능하게 만든다면 데드락이 발생하지 않을 것이다. 
  2. **한계**:
  - 현실적으로 불가능하다. 
  - 뮤텍스 락처럼 본질적으로 비공유 가능한(non-shareable) 리소스가 존재한다. 
  - 상호 배제 조건이 없으면 데드락 문제 자체가 발생하지 않으므로, 이 조건을 막는 것은 의미가 없다. 

2. **점유 대기(Hold and Wait) 조건 방지**:
  1. **시도**: 스레드가 새로운 리소스를 요청할 때는 현재 점유하고 있는 모든 리소스를 내려놓고 요청하도록 한다. 
  2. **한계**:
  - 매우 비실용적(impractical)이다. 
  - 예를 들어, 10개의 파일을 열어놓고 새로운 파일을 열 때마다 기존 파일들을 모두 닫고 다시 여는 것은 현실적인 프로그래밍 방식이 아니다. 

3. **비선점(No Preemption) 조건 방지**:
  1. **시도**: 어떤 스레드가 리소스를 점유하고 있을 때, 다른 스레드가 요청한 리소스가 이미 점유되어 있다면 강제로 빼앗을 수 있도록 프로토콜을 적용한다. 
  2. **한계**:
  - 이 또한 비실용적인 방법이다. 
  - 강제로 빼앗긴 리소스는 다시 요청해야 하며, 이는 복잡한 문제를 야기한다. 
  - 결국 점유 대기 조건 방지와 유사하게, 리소스를 내려놓거나 빼앗기는 방식은 일반적으로 적용하기 어렵다. 


### 4.3. 순환 대기(Circular Wait) 조건 방지 
![image]()
1. **시도**:
  1. 모든 리소스 타입에 **전체 순서(total ordering)**를 부여한다 (예: 1번 파일, 2번 메모리, 3번 하드 디스크 등). 
  2. 스레드는 자신이 점유하고 있는 리소스보다 **더 높은 번호의 리소스만 요청**하도록 한다. 
  3. 만약 요청한 리소스가 이미 점유되어 있다면, 현재 점유하고 있는 리소스를 모두 내려놓고 다시 요청한다. 
2. **효과**:
  1. 이 방법을 사용하면 순환 대기 조건이 발생할 수 없음을 증명할 수 있다. 
  2. 데드락 발생을 막을 수 있다. 
3. **한계**:
  1. **기아(Starvation) 위험 증가**: 특정 스레드가 계속해서 리소스를 얻지 못하고 대기하는 기아 상태에 빠질 위험이 높아진다. 
  2. 이 방법조차도 데드락 예방을 완전히 보장하지는 못한다. 


### 4.4. 트랜잭션(Transaction) 예시를 통한 데드락 예방의 어려움 
![image]()
1. **트랜잭션의 정의**: 쪼갤 수 없는(atomic) 작업 단위로, 대표적으로 계좌 이체가 있다. 
2. **계좌 이체 트랜잭션 예시**:
  1. **과정**: 아빠 계좌에서 아들 계좌로 만 원을 이체하는 트랜잭션. 
  2. **락 획득**: 아빠 계좌에 락(lock)을 걸고, 아들 계좌에 락을 건다. 
  3. **작업**: 아빠 계좌에서 출금하고 아들 계좌에 입금한다. 
  4. **필수 조건**: 출금과 입금은 두 계좌의 락을 모두 획득한 상태에서만 실행되어야 한다. 
3. **데드락 발생 상황**:
  1. 아빠가 아들 계좌로 50만 원을 보내고, 동시에 아들이 아빠 계좌로 25만 원을 보내는 두 개의 트랜잭션(T1, T2)이 동시에 실행될 경우. 
  2. T1이 아빠 계좌 락을 획득하고 아들 계좌 락을 요청하며, T2가 아들 계좌 락을 획득하고 아빠 계좌 락을 요청하면 데드락이 발생한다. 
4. **해결 방안 (예방의 어려움)**:
  1. 이러한 데드락을 막기 위해 추가적인 락을 사용하거나 모니터 락(monitor lock)을 이용한 wait/notify 방식을 사용할 수 있지만, 이는 복잡성을 증가시킨다. 
  2. 결론적으로, 데드락의 4가지 조건 중 상호 배제, 점유 대기, 비선점은 본질적으로 방지하기 어렵고, 순환 대기 방지는 그나마 가능성이 있지만 완벽하지 않다. 
5. **결론**: 데드락 예방은 현실적으로 어렵기 때문에, 다음 단계인 **데드락 회피(Avoidance)** 전략을 고려해야 한다. 

