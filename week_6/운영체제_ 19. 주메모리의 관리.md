
## 📌 주메모리 관리의 핵심은 무엇인가?
주메모리 관리의 핵심은 <mark>프로세스를 메모리에 어떻게 저장하고 관리할 것인지</mark>에 대한 방법을 다루는 것입니다.
##### 💡 주메모리 관리에서 다루는 주요 개념들은 무엇인가?
- **메모리 보호**: 베이스 레지스터와 리미트 레지스터를 사용하여 프로세스가 할당된 메모리 영역만 접근하도록 제한합니다.
- **주소 바인딩**: 소스 코드의 심볼릭 주소가 컴파일, 링크, 로딩 단계를 거쳐 실제 물리적 주소로 변환되는 과정입니다.
- **MMU (Memory Management Unit)**: CPU가 사용하는 논리적 주소를 물리적 주소로 변환해주는 하드웨어 장치입니다.
- **동적 로딩 (Dynamic Loading)**: 모든 루틴을 한꺼번에 로딩하지 않고, 필요할 때만 메모리에 로딩하여 메모리 공간을 효율적으로 사용합니다.
- **동적 링킹 (Dynamic Linking)**: 프로그램 실행 중에 라이브러리 함수를 링킹하여 메모리 사용을 최적화하며, 주로 공유 라이브러리(DLL, SO) 형태로 사용됩니다.
- **연속 메모리 할당**: 프로세스를 메모리에 통째로 로딩하는 방식으로, First Fit, Best Fit, Worst Fit 등의 전략이 있습니다.
- **단편화**: 메모리 할당 후 남는 작은 조각들로, 외부 단편화(메모리 조각화)와 내부 단편화(할당된 블록 내 남는 공간)가 있습니다.
- **세그멘테이션**: 메모리를 코드, 데이터, 스택 등 논리적 단위의 세그먼트로 나누어 관리하는 방식입니다.


운영체제에서 **주메모리 관리**의 핵심 원리를 깊이 있게 이해할 수 있는 강의입니다. 프로그램이 메모리에 로드되어 프로세스가 되는 과정부터, CPU가 메모리에 접근하는 방식, 그리고 **논리적 주소**가 **물리적 주소**로 변환되는 복잡한 과정을 명확하게 설명합니다. 특히, **MMU(메모리 관리 장치)**와 베이스/리미트 레지스터를 활용한 메모리 보호 메커니즘을 통해 멀티 프로그래밍 환경에서 각 프로세스가 안전하게 메모리를 사용하는 방법을 배울 수 있습니다. 또한, 다이내믹 로딩 및 링킹, 그리고 **연속 메모리 할당** 방식의 장단점과 **외부 단편화** 문제 해결 전략(First-fit, Best-fit, Worst-fit)까지 다루어, 메모리 관리의 실질적인 고민과 해결책을 제시합니다.
## 1. 주메모리 관리의 기본 개념 및 필요성 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/0BQwhwlz5qs/1.jpg)
1. **프로세스의 정의와 메모리 로딩** 
  1. 프로세스는 '실행 중인 프로그램'을 의미하며, 이는 프로그램이 메인 메모리에 로드된 상태를 말한다. 

2. **메모리의 구성** 
  1. 메모리는 바이트 단위로 구성되어 정보를 저장하며, 각 바이트에는 고유한 주소가 부여된다. 

3. **CPU의 메모리 접근 방식** 
  1. CPU는 메모리에서 명령(instruction)을 가져와 실행하며, 이 과정에서 로드(load) 및 스토어(store) 명령을 통해 메모리에 접근한다. 

4. **메모리 관리의 중요성** 
  1. 운영체제는 CPU가 아닌 메모리에 프로세스를 어떻게 저장하고 관리할 것인지에 중점을 둔다. 
  2. 멀티 프로그래밍 환경에서는 각 프로세스가 독립적인 메모리 주소 공간을 관리할 수 있어야 한다. 


## 2. 메모리 보호 메커니즘: 베이스/리미트 레지스터 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/0BQwhwlz5qs/160.jpg)
1. **메모리 보호의 필요성** 
  1. 멀티 프로그래밍 환경에서 여러 프로세스가 메모리를 공유할 때, 각 프로세스는 할당된 자신의 메모리 영역만 접근해야 하며, 다른 프로세스의 메모리를 침범해서는 안 된다. 
  2. 이를 위해 합법적인 주소 접근을 제한하는 메커니즘이 필요하다. 

2. **베이스/리미트 레지스터를 이용한 보호** 
  1. **하드웨어적 제어**: 베이스 레지스터와 리미트 레지스터를 사용하여 메모리 접근을 하드웨어적으로 제어한다. 
  2. **작동 방식**:
  1. CPU가 특정 주소에 접근하려 할 때, 해당 주소가 **베이스 레지스터 값보다 크거나 같고**, **(베이스 + 리미트) 값보다 작을 경우**에만 메모리 접근을 허락한다. 
  2. 만약 이 범위를 벗어나는 불법적인 접근이 발생하면, 트랩(trap)을 일으켜 인터럽트를 발생시키고 운영체제(OS)에 알린다. 
  3. OS는 해당 프로세스를 중단시켜 메모리 공간을 보호한다. 


## 3. 주소 바인딩: 논리적 주소와 물리적 주소 
![image]()
1. **주소 다루는 방식의 다양성** 
  1. 프로그램 내에서 주소를 다루는 방식은 개발 단계별로 다르다. 

2. **소스 코드 단계의 주소** 
  1. int a; a = 10;과 같이 변수 이름을 사용할 때, 컴파일러가 해당 변수에 대한 메모리 주소 공간을 지정한다. 
  2. 이때 개발자는 특정 메모리 번지를 직접 지정하지 않고, 컴파일러가 알아서 처리한다. 

3. **컴파일 단계의 주소** 
  1. 컴파일러는 .exe나 .obj와 같은 바이너리 파일을 생성하지만, 이 파일이 메모리의 몇 번지에 로드될지는 알 수 없다. 
  2. 컴파일러는 **재배치 가능(relocatable)한 논리적 주소**를 생성한다. 

4. **로딩 및 링킹 단계의 주소** 
  1. **프로세스 생성**: 프로그램이 메모리에 로드될 때 비로소 프로세스가 된다. 
  2. **OS의 시작 번지 결정**: 운영체제(OS)가 프로세스의 메모리 시작 번지를 결정하므로, 프로세스의 주소는 항상 0번지부터 실행되는 것이 아니다. 
  3. **링커의 역할**: 여러 오브젝트 파일(예: a.obj, b.obj)을 묶어 하나의 실행 가능한 코드(예: a.out)를 만들 때, 링커(linker)가 **논리적 주소(logical address)**를 생성한다. 
  1. 이 논리적 주소는 프로그램의 시작 번지(예: 0번지)로부터의 **옵셋(offset)** 형태로 표현된다. 
  4. **로더의 역할**: 로더(loader)는 프로그램을 메모리에 로딩하면서 **재배치 가능한 논리적 주소**를 실제 **물리적 주소(physical address)**로 변환(바인딩)한다. 
  5. **다양한 바인딩 주체**: 이처럼 주소 바인딩은 소스 코드, 컴파일, 링킹, 로딩 등 단계별로 다르며, 바인딩을 수행하는 주체도 다르다. 

5. **논리적 주소와 물리적 주소의 분리** 
  1. **논리적 주소(Logical Address)**: CPU가 사용하는 주소로, 사용자 프로세스 관점에서 본 주소이다. 실제 물리적 메모리 주소와는 독립적이어야 한다. 
  2. **물리적 주소(Physical Address)**: 실제 하드웨어 메모리에 존재하는 주소이다. 
  3. 운영체제는 논리적 주소를 물리적 주소로 매핑(mapping)하는 작업을 수행해야 한다. 


## 4. MMU(Memory Management Unit)를 이용한 주소 변환 
![image]()
1. **MMU의 필요성** 
  1. 메모리 접근은 빈번하게 발생하므로, 논리적 주소와 물리적 주소의 분리 및 변환은 소프트웨어로 처리하기 어렵다. 
  2. 이를 효율적으로 처리하기 위해 **MMU(Memory Management Unit)**라는 하드웨어 장치를 사용한다. 

2. **MMU의 역할** 
  1. MMU는 하드웨어 장치로, 사용자 프로세스가 사용하는 **논리적 주소**를 **물리적 주소**로 변환하는 역할을 한다. 
  2. CPU가 논리적 주소를 MMU에 전달하면, MMU가 자동으로 물리적 주소로 변환하여 메모리에 접근한다. 

3. **릴로케이션 레지스터(Relocation Register) 활용** 
  1. MMU는 **릴로케이션 레지스터(베이스 레지스터와 동일)**를 사용하여 주소 변환을 수행한다. 
  2. **변환 과정**:
  1. CPU가 논리적 주소(예: 346번지)를 요청한다. 
  2. 릴로케이션 레지스터에 저장된 시작 물리 주소(예: 14000번지)를 논리적 주소에 더한다. 
  3. 결과적으로 실제 물리 주소(예: 14346번지)에 접근하게 된다. 
  4. 이 과정을 통해 프로세스는 항상 0번지부터 시작하는 논리적 주소를 사용하지만, 실제 메모리에서는 다른 물리적 위치에 로드될 수 있다. 


## 5. 다이내믹 로딩 및 링킹 


### 5.1. 다이내믹 로딩 (Dynamic Loading) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/0BQwhwlz5qs/885.jpg)
1. **다이내믹 로딩의 개념** 
  1. 프로그램(프로세스)을 메모리에 로딩할 때, 프로그램 전체를 한꺼번에 로딩하지 않고 필요한 부분만 로딩하는 방식이다. 

2. **필요성** 
  1. 최신 게임이나 오피스 프로그램처럼 실행 파일의 크기가 매우 큰 경우, 전체를 한꺼번에 로딩하면 시스템 메모리가 부족해질 수 있다. 
  2. 메모리 주소 공간을 효율적으로 사용하기 위해 모든 루틴을 한꺼번에 로딩할 필요가 없다. 

3. **작동 방식** 
  1. 필요할 때만 해당 루틴을 호출하여 메모리에 로딩한다. 
  2. 링킹 로더(linking loader)는 필요한 루틴이 호출될 때 해당 루틴의 위치를 테이블에 반영하여 로딩을 처리한다. 


### 5.2. 다이내믹 링킹 (Dynamic Linking) 
![image]()
1. **다이내믹 링킹의 개념** 
  1. 프로그램 실행 시까지 링킹 작업을 연기하는 방식이다. 
  2. 대표적인 예시로 **DLL(Dynamic Link Library)** 파일이 있다. 

2. **정적 링킹(Static Linking)과의 비교** 
  1. **정적 링킹**: 시스템 라이브러리 코드를 다른 오브젝트 모듈처럼 프로그램 코드에 포함시켜 로더가 링킹하고 로딩하는 방식이다. 
  2. **문제점**: printf와 같은 표준 라이브러리 함수나 fork, wait 같은 시스템 호출 코드를 모든 실행 파일에 포함시키면 파일 크기가 커지고 메모리 낭비가 발생한다. 
  1. 특히 시스템 호출 코드는 운영체제에 이미 존재하므로, 각 프로세스에 포함될 필요가 없다. 

3. **다이내믹 링킹의 장점 및 작동 방식** 
  1. **실행 시 링킹**: 프로그램 실행 중에 DLL 파일(또는 리눅스의 .so 파일)을 액세스하여 링킹한다. 
  2. **공유 라이브러리**: 주로 **공유 라이브러리(shared library)** 형태로 사용되어 여러 프로그램이 동일한 라이브러리 코드를 공유할 수 있게 한다. 
  3. **효율성**: 메모리 사용을 효율적으로 만들고, 프로그램 파일 크기를 줄일 수 있다. 


## 6. 연속 메모리 할당 (Contiguous Memory Allocation) 
![image]()
1. **연속 메모리 할당의 개념** 
  1. 프로세스에 메모리를 할당하는 가장 간단한 방법으로, 프로그램 전체를 메모리의 **연속된 한 섹션**에 통째로 로딩하는 방식이다. 
  2. 운영체제 영역과 여러 프로세스 영역이 메모리에 동시에 존재할 수 있어야 한다. 

2. **장점** 
  1. 매우 간단하게 구현할 수 있다. 
  2. 통째로 로딩되므로 **연속적인 접근**이 가능하다. 
  3. 베이스/리미트 레지스터를 사용하여 메모리 시작 주소와 사용 범위를 쉽게 관리할 수 있다. 

3. **한계점**: 뒤에 나올 페이징 방식에서는 이처럼 통째로 할당되지 않는다. 


## 7. 가변 파티션 할당 및 외부 단편화 문제 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/0BQwhwlz5qs/1258.jpg)
1. **가변 파티션 할당의 필요성** 
  1. 프로세스마다 크기가 다르므로, 메모리 할당 파티션도 가변적이어야 한다. 
  2. 가변 파티션 할당 시 어떤 프로세스를 어떻게 배치할 것인지 문제가 발생한다. 

2. **외부 단편화(External Fragmentation) 발생** 
  1. **문제 발생 과정**:
  1. 메모리에서 프로세스들이 실행되고 종료되면서 메모리를 반납한다. 
  2. 이때 빈 공간(free hole)이 생기는데, 이 빈 공간들이 여러 개의 작은 조각으로 흩어지게 된다. 
  3. 새로운 프로세스가 들어올 때, 전체 빈 공간의 합은 충분하지만, **연속된 하나의 큰 공간이 없어** 프로세스를 할당할 수 없는 상황이 발생한다. 
  2. **정의**: 외부 단편화는 메모리 페이지가 여러 개의 작은 구멍들로 연결되어 남아돌지만, 실제로는 사용할 수 없는 상태를 의미한다. 
  3. **관리의 어려움**: 이러한 빈 공간(free hole)들을 효율적으로 관리하는 것이 중요한 이슈가 된다. 


## 8. 동적 저장 공간 할당 전략 (Dynamic Storage-Allocation Strategies) 
![image]()
1. **할당 전략의 필요성** 
  1. 프로세스가 종료되거나 새로운 프로세스가 요청될 때, 가변적인 크기의 메모리 요청(n-size)을 어떻게 할당할 것인지 결정해야 한다. 
  2. 이를 위해 **세 가지 주요 전략**이 존재한다. 

2. **프리 홀(Free Hole) 리스트 관리** 
  1. 메모리에는 사용 중인 공간과 비어 있는 공간(프리 홀)이 존재한다. 
  2. 이 프리 홀들을 리스트 형태로 관리하며, 새로운 요청이 들어왔을 때 이 리스트에서 적절한 공간을 찾아 할당한다. 

3. **세 가지 할당 전략** 
  1. **First-fit (최초 적합)** 
  1. 프리 홀 리스트를 처음부터 탐색하여, 요청된 크기를 수용할 수 있는 **첫 번째 공간**에 할당한다. 
  2. 남은 공간은 새로운 프리 홀로 추가한다. 
  2. **Best-fit (최적 적합)** 
  1. 프리 홀 리스트 전체를 탐색하여, 요청된 크기를 수용할 수 있는 공간 중 **가장 작은 공간**에 할당한다. 
  2. 이 전략은 가장 작은 조각의 외부 단편화를 남긴다. 
  3. **Worst-fit (최악 적합)** 
  1. 프리 홀 리스트 전체를 탐색하여, 요청된 크기를 수용할 수 있는 공간 중 **가장 큰 공간**에 할당한다. 
  2. 이 전략은 남은 공간을 최대한 크게 유지하여, 이후의 큰 요청을 처리할 가능성을 높이려 한다. 

4. **예시 문제 풀이 (100MB 요청 시)** 
  1. **초기 프리 블록**: 40MB, 300MB, 185MB, 170MB, 40MB, 205MB (순서대로 링크드 리스트) 
  2. **First-fit**:
  1. 100MB 요청 시, 300MB 블록에 할당 (40MB는 작아서 불가). 
  2. 300MB 블록에서 100MB 사용 후 200MB가 남는다. 
  3. **Best-fit**:
  1. 프리 블록을 크기 순으로 정렬(힙 큐 또는 트라이브 큐)하여 가장 작은 것부터 찾는다. 
  2. 100MB 요청 시, 170MB 블록에 할당 (40MB는 작고, 185MB, 205MB, 300MB는 더 크므로 170MB가 최적). 
  3. 170MB 블록에서 100MB 사용 후 70MB가 남는다. 
  4. **Worst-fit**:
  1. 프리 블록을 크기 순으로 정렬하여 가장 큰 것부터 찾는다. 
  2. 100MB 요청 시, 300MB 블록에 할당. 
  3. 300MB 블록에서 100MB 사용 후 200MB가 남는다. 

5. **성능 및 개념적 이해** 
  1. 어떤 전략이 가장 좋은지는 성능 테스트를 통해 결정해야 하며, 일반적으로 Best-fit이 가장 좋다고 알려져 있지만, 상황에 따라 다르다. 
  2. 이러한 전략들은 개념적으로 이해하는 것이 중요하다. 


## 9. 단편화 문제 해결 및 세그멘테이션 
![image]()
1. **단편화 문제의 심화** 
  1. 메모리 공간이 계속 쪼개지고 할당/해제가 반복되면, 전체적으로 사용 가능한 메모리는 많지만, 연속된 큰 공간이 없어 할당할 수 없는 **외부 단편화(External Fragmentation)** 문제가 심화된다. 
  2. 이는 마치 100MB의 총 공간이 남아있어도 15MB, 3MB 등 작은 조각들로 흩어져 있어 20MB 요청을 처리할 수 없는 상황과 같다. 
  3. 가비지 컬렉션처럼 메모리를 옮겨 묶는 것은 프로그램 실행 중에는 비효율적이다. 

2. **내부 단편화(Internal Fragmentation)** 
  1. **발생 원인**: 페이징(paging)과 같은 고정 크기 할당 방식에서 발생한다. 
  2. **개념**: 프로세스에 할당된 메모리 공간 내에서 실제로 사용되지 않고 남는 작은 공간을 의미한다. 
  3. **연속 메모리 할당과의 관계**: 연속 메모리 할당(contiguous memory allocation) 방식에서는 외부 단편화가 발생한다. 

3. **세그멘테이션(Segmentation)** 
  1. **개념**: 메모리를 통째로 올리는 연속 메모리 할당 방식과 달리, 프로그램을 **논리적인 단위(세그먼트)**로 쪼개서 메모리에 올리는 방식이다. 
  2. **세그먼트의 예시**: 서브루틴, 라이브러리 함수, 스택 영역, 메인 함수 영역, 심볼 테이블, 힙 영역 등 프로그램의 논리적 구성 요소별로 나눈다. 
  3. **장점**: 통째로 올리는 것보다 여러 장점이 있다. 
  4. **단점**: 세그먼트의 크기가 가변적(variable size)이므로, 외부 단편화 문제가 더 심각해질 수 있다. 
  5. **현재 사용**: 세그멘테이션 자체는 현대 운영체제에서 직접적인 메모리 할당 방식으로 잘 사용되지 않지만, 세그멘테이션 폴트(Segmentation Fault)와 같은 용어 때문에 개념을 알아두는 것이 중요하다. 


## 10. 주메모리 관리 요약 및 다음 강의 예고 
![image]()
1. **이번 강의 요약** 
  1. 메모리 주소 바인딩(논리적 주소 -> 물리적 주소) 방법. 
  2. MMU 하드웨어 사용법 및 소프트웨어적 처리. 
  3. 연속 메모리 할당 방법. 

2. **다음 강의 예고** 
  1. 다음 시간에는 **페이징(Paging)** 방법에 대해 다룰 예정이다. 

