
## 📌 철학자들의 저녁 식사 문제를 자바(Java)로 구현할 때 사용되는 주요 기능은 무엇인가요?
자바에서는 java.util.concurrent.locks 패키지의 Condition 변수와 ReentrantLock을 사용하여 철학자들의 저녁 식사 문제를 해결합니다.
##### 💡 ReentrantLock의 '재진입 가능'이라는 용어는 무엇을 의미하나요?
재진입 가능은 CPU에서 컨텍스트 스위치가 발생하여 프로세스가 레디 큐로 이동했다가 다시 CPU로 돌아와 실행되는 것을 의미합니다.


이 강의는 **'철학자들의 저녁 식사 문제'**를 자바(Java) 언어로 구현하는 과정을 상세히 설명합니다. 운영체제에서 **동기화 문제 해결**의 핵심인 **모니터 개념**을 자바의 ReentrantLock과 Condition 변수를 활용하여 어떻게 적용하는지 구체적인 코드와 함께 배울 수 있습니다. 특히, wait와 notify 대신 await와 signal을 사용하는 **컨디션 변수의 작동 방식**을 명확히 이해하고, 실제 멀티스레드 환경에서 발생할 수 있는 **교착 상태(Deadlock) 방지**를 위한 실용적인 해결책을 얻을 수 있습니다. 복잡한 동시성 프로그래밍 문제를 자바로 해결하는 **실질적인 노하우**를 얻고 싶은 개발자에게 강력히 추천합니다.
## 1. 철학자들의 저녁 식사 문제: Java 버전 구현 개요 
![image]()
1. **강의 소개 및 자료 안내** 
  1. 본 강의는 '철학자들의 저녁 식사 문제'를 자바(Java) 버전으로 구현하는 내용을 다룬다. 
  2. 강의 자료는 다시 업데이트되었으므로, 이전에 다운로드한 경우 새로 다운로드해야 한다. 

2. **Java를 활용한 문제 해결** 
  1. 이전 강의에서 C++로 문제를 해결했으며, 이번에는 Java로 해결하는 방법을 다룬다. 


## 2. Java 동기화 메커니즘: ReentrantLock과 Condition Variable 
![image]()
1. **Java 동시성 유틸리티 활용** 
  1. Java의 java.util.concurrent.locks 패키지에 있는 Condition 변수와 ReentrantLock을 사용한다. 

2. **ReentrantLock의 개념** 
  1. ReentrantLock은 '재진입 가능한 락(lock)'을 의미한다. 
  2. **재진입 가능성**: CPU에서 컨텍스트 스위치가 발생하여 스레드가 레디 큐(Ready Queue)로 갔다가 다시 CPU에 진입하는 것을 의미한다. 
  3. ReentrantLock은 이러한 재진입을 가능하게 해주는 락(lock)이다. 


## 3. 철학자들의 저녁 식사 문제 Java 구현 구조 
![image]()
1. **상태(State) 정의** 
  1. 철학자의 상태는 THINKING, HUNGRY, EATING으로 정의하며, Java의 enum 타입으로 선언한다. 

2. **메인 클래스: DiningPhilosophers** 
  1. DiningPhilosophers 클래스의 main 함수에서 5명의 철학자(Philosopher) 객체를 배열로 생성한다. 
  2. DiningPhilosophersMonitor는 문제 해결을 위한 **모니터(Monitor)** 역할을 하며, 5개의 객체를 생성자에 넘겨주어 초기화한다. 
  3. 각 철학자 ID에 해당하는 스레드를 생성하고 start() 메서드를 호출하여 실행한다. 

3. **철학자 스레드 클래스: Philosopher** 
  1. Philosopher 클래스는 Runnable 인터페이스를 구현한다. 
  2. run() 메서드 내에서 while(true) 루프를 통해 철학자가 **생각하고(thinking)**, **젓가락을 들고(pickup)**, **식사하고(eating)**, **젓가락을 내려놓는(putdown)** 과정을 무한히 반복한다. 
  3. 젓가락을 들고 내려놓는 과정은 DiningPhilosophersMonitor 클래스의 pickup()과 putdown() 메서드를 호출하여 처리한다. 
  4. 생성자에서는 철학자의 id와 동기화 모니터인 DiningPhilosophersMonitor 객체를 파라미터로 받아 멤버 변수에 저장한다. 
  5. **생각하는 시간**: System.out.println으로 "I'm thinking" 메시지를 출력하고, <mark>0.05초에서 0.10초</mark> 사이의 랜덤한 시간 동안 Thread.sleep()을 호출하여 대기한다. 
  6. **식사하는 시간**: 생각하는 시간보다 짧게 설정하여, 생각은 오래 하고 밥은 조금만 먹도록 한다. 


## 4. 모니터 구현: DiningPhilosophersMonitor 
![image]()
1. **모니터의 상태 및 변수 선언** 
  1. 철학자의 상태를 저장하는 state 배열 (enum State 타입)을 선언한다. 
  2. 각 철학자마다 하나의 Condition 변수를 제공하는 self 배열을 선언한다. 
  3. ReentrantLock 타입의 lock 객체를 선언하고, Condition 변수들을 lock.newCondition()을 통해 생성하여 self 배열에 저장한다. 
  4. 초기 상태는 모든 철학자가 THINKING 상태로 설정된다. 

2. **젓가락 위치 정의** 
  1. leftOf(i) 함수는 (i + numPhilosophers - 1) % numPhilosophers로 왼쪽 젓가락을, rightOf(i) 함수는 (i + 1) % numPhilosophers로 오른쪽 젓가락을 지정한다. 

3. **젓가락 획득 로직: pickup() 메서드** 
  1. pickup() 메서드 진입 시 lock.lock()을 호출하여 락을 획득한다. 
  2. try-finally 블록을 사용하여 예외 발생 여부와 관계없이 lock.unlock()이 호출되도록 보장한다. 
  3. **내부 로직**:
  1. 현재 철학자의 상태를 HUNGRY로 변경한다. 
  2. test(id) 메서드를 호출하여 젓가락을 획득할 수 있는지 확인한다. 
  3. 만약 젓가락을 획득할 수 없는 상태(state[id]가 EATING이 아닌 상태)라면, self[id].await()를 호출하여 대기한다. 

4. **젓가락 반납 로직: putdown() 메서드** 
  1. putdown() 메서드 진입 시 lock.lock()을 호출하여 락을 획득하고, finally 블록에서 lock.unlock()을 호출한다. 
  2. **내부 로직**:
  1. 현재 철학자의 상태를 THINKING으로 변경한다. 
  2. 왼쪽 철학자와 오른쪽 철학자에 대해 test() 메서드를 호출하여, 이들이 젓가락을 획득할 수 있는지 확인하고 필요한 경우 signal()을 보낸다. 

5. **젓가락 획득 가능 여부 확인: test() 메서드** 
  1. test(id) 메서드는 현재 철학자(id)가 HUNGRY 상태이고, 왼쪽 철학자(leftOf(id))와 오른쪽 철학자(rightOf(id))가 모두 EATING 상태가 아닐 때만 젓가락을 획득할 수 있다고 판단한다. 
  2. 조건이 충족되면 현재 철학자의 상태를 EATING으로 변경하고, self[id].signal()을 호출하여 대기 중인 해당 철학자 스레드를 깨운다. 

6. **Condition 변수의 **await()와 signal() 
  1. Java의 Condition 변수는 C++의 wait()와 notify() 대신 await()와 signal() 메서드를 사용한다. 
  2. 이 두 메서드는 스레드 모니터 락(synchronized 블록)에서 사용하는 wait()와 notify()와 용도는 비슷하지만, ReentrantLock과 함께 사용되는 Condition 변수에서 사용된다는 차이점이 있다. 


## 5. 강의 자료 오류 및 보충 안내 
![image]()
1. 강의 자료에 오류가 있어, 영상과 함께 보충 자료를 제공할 예정이다. 

