
## 📌 가상 메모리와 디맨드 페이징은 무엇인가요?
가상 메모리는 프로세스의 전체 메모리를 물리 메모리에 완전히 올리지 않아도 프로그램이 실행될 수 있도록 하는 기술이며, 디맨드 페이징은 <mark>요청이 있을 때만 필요한 페이지를 메모리에 로딩하는 방식</mark>입니다
##### 💡 디맨드 페이징의 장점과 단점은 무엇인가요?
- 장점: 메모리 효율성을 높이고, 파일 및 라이브러리 공유를 용이하게 하며, 프로세스 생성 시 유연성을 제공합니다.
- 단점: 페이지 폴트가 자주 발생할 수 있어 시스템 성능 저하를 초래할 수 있습니다.


운영체제의 핵심 개념인 **가상 메모리(Virtual Memory)**와 **디맨드 페이징(Demand Paging)**을 깊이 있게 이해할 수 있는 강의입니다. 프로그램이 물리 메모리보다 커도 실행될 수 있는 원리부터, 필요한 페이지만 메모리에 로드하는 **요구 페이징**의 작동 방식까지 상세히 설명합니다. 특히, 페이지 폴트 발생 시 시스템이 어떻게 효율적으로 대응하는지, 그리고 **참조 국부성(Locality of Reference)**이 디맨드 페이징 성능에 미치는 영향 등 실질적인 인사이트를 얻을 수 있습니다. 복잡한 운영체제 개념을 명확하게 이해하고 싶은 분들에게 이 강의는 **시스템 성능 최적화**의 기반 지식을 제공할 것입니다.
## 1. 가상 메모리(Virtual Memory)와 디맨드 페이징(Demand Paging) 소개 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/wJYo9K0QN2k/2.jpg)
1. **가상 메모리(Virtual Memory)의 개념** 
  1. 프로세스의 전체 메모리를 물리 메모리에 완전히 올리지 않아도 프로그램이 실행될 수 있도록 하는 기술이다. 
  2. 논리적 메모리와 물리적 메모리를 분리하여 효율적인 메모리 활용이 가능하다. 
  3. 파일 및 라이브러리 공유, 프로세스 생성 시 유용하게 활용된다. 

2. **가상 메모리 구조의 시각화** 
  1. 매우 큰 가상의 메모리 구조(로지컬 메모리)를 가정한다. 
  2. 실제 물리 메모리(피지컬 메모리)에는 필요할 때마다 페이지를 매핑하여 실행한다. 
  3. 메모리에 로딩되지 않은 나머지 페이지들은 하드 디스크와 같은 보조 저장장치(페이지 스토어)에 저장된다. 
  4. 이를 통해 메인 메모리를 효율적으로 활용할 수 있다. 

3. **가상 주소 공간(Virtual Address Space)** 
  1. 프로세스의 메모리 구조를 나타내는 논리적 주소 공간이다. 
  2. 논리적 주소는 0부터 시작하며, 텍스트(코드), 데이터, 힙, 스택 영역 등으로 구성된다. 
  3. 연속적인 메모리 공간에 프로그램을 작성하는 것처럼 보이지만, 실제로는 그렇지 않다. 

4. **가상 메모리를 통한 파일 및 메모리 공유** 
  1. 가상 메모리를 사용하면 파일과 메모리 공유가 쉬워진다. 
  2. 예를 들어, 텍스트 코드 영역, 데이터 영역, 힙 영역, 스택 영역 외에 공유 라이브러리(Shared Library)를 사용할 수 있다. 
  3. 공유 라이브러리는 여러 프로세스가 공유하는 페이지에 접근할 수 있도록 하여 메모리 효율성을 높인다. 
  4. 페이징 기법을 통해 프로그램을 동일한 크기로 잘라 사용하며, 그중 하나의 페이지를 공유하면 공유 메모리가 된다. 


## 2. 디맨드 페이징(Demand Paging)의 작동 원리 
![image]()
1. **프로그램 로딩 방식의 변화** 
  1. 실행 파일(예: a.out 파일)이 보조 저장장치(하드 디스크, SSD)에 저장되어 있을 때, 이를 메모리에 로딩하는 방식에 대한 고민이 필요하다. 
  2. 과거에는 전체 프로그램을 물리 메모리에 한꺼번에 로딩하는 방식(인타이어 프로그램 로딩)을 사용했으나, 현대 컴퓨터에서는 비효율적이다. 
  3. 대신, 프로그램을 페이지 단위로 잘라 필요한 페이지만 메모리에 로딩하는 방식이 효율적이다. 
  4. 이때, 각 페이지를 '언제' 로딩할 것인지가 중요하며, 이는 요청(Demand)이 있을 때만 로딩하는 방식으로 해결된다. 

2. **가상 메모리 시스템의 페이지 관리 문제** 
  1. 가상 메모리 시스템에서 페이지의 가상 매핑을 어떻게 관리할 것인지가 문제로 발생한다. 
  2. 실행 중에 요청(Demand)이 있을 때 페이지를 로딩하는 것이 기본적인 개념이다. 
  3. **Valid-Invalid 비트**를 사용하여 페이지의 상태를 표시한다. 
  1. **Valid 비트**: 페이지가 유효하며 물리 메모리에 로딩되어 있음을 의미한다. 
  2. **Invalid 비트**: 다음 두 가지 중 하나를 의미한다. 
  - 메모리 영역을 벗어나 참조하여 세그멘테이션 폴트(Segmentation Fault)가 발생했음을 의미한다.
  - 페이지가 보조 저장장치에 저장되어 있음을 의미한다.
  3. 혹은 Dirty 비트 등을 추가로 사용하여 상태를 구분할 수도 있다. 

3. **페이지 폴트(Page Fault) 처리 과정** 
  1. 총 8개의 페이지(0번부터 7번까지)로 구성된 프로세스를 메모리에 로딩하는 두 가지 방법이 있다. 
  2. 하드 디스크에 페이지들이 순서대로 저장되어 있지 않아도 상관없다. 
  3. **페이지 폴트 발생 시 처리 절차** 
  1. **인터럽트 발생**: 메모리에 로딩되지 않은 페이지에 접근하면 페이지 폴트 예외(트랩)가 발생한다. 
  2. **페이지 테이블 확인**: 운영체제는 내부 페이지 테이블을 확인하여 해당 페이지가 유효한지(Valid) 또는 유효하지 않은지(Invalid)를 확인한다. 
  3. **프리 프레임(Free Frame) 탐색**: 페이지 폴트가 발생하면, 운영체제는 메모리에서 비어있는 페이지 프레임을 찾는다. 
  4. **페이지 로딩**: 보조 저장장치(세컨더리 스토리지)에서 해당 페이지를 읽어와 찾은 프리 프레임에 할당한다. 
  5. **페이지 테이블 업데이트**: 페이지 테이블의 해당 엔트리를 업데이트하여 Invalid 비트를 Valid 비트로 변경한다. 
  6. **프로세스 재시작**: 인터럽트가 발생했던 명령어를 다시 실행하여 프로세스를 재개한다. 
  4. 이러한 과정은 시험에 자주 출제되는 중요한 개념이다. 

4. **퓨어 디맨드 페이징(Pure Demand Paging)** 
  1. 순수한 디맨드 페이징으로, **요청이 없으면 절대로 페이지를 가져오지 않는 방식**이다. 
  2. 프로그램 시작 시에도 메모리에 아무 페이지도 로딩하지 않는다. 
  3. 첫 번째 명령어가 실행될 때 페이지 폴트가 발생하고, 그때 해당 페이지를 로딩한다. 
  4. 이후 필요한 페이지가 발생할 때마다 페이지 폴트를 통해 로딩한다. 


## 3. 디맨드 페이징의 효율성 및 참조 국부성 
![image]()
1. **디맨드 페이징의 장단점** 
  1. **단점**: 페이지 폴트가 자주 발생할 수 있어 그때마다 페이지를 로딩해야 한다. 
  2. **개선 방안**: 만약 코드 영역의 페이지가 여러 개로 구성되어 있다면, 페이지 폴트가 한 번 일어났을 때 여러 페이지를 한꺼번에 로딩하여 페이지 폴트 횟수를 줄일 수 있다. 
  3. **주의점**: 너무 많은 페이지를 미리 로딩하면 시스템 효율이 떨어질 수 있다. 

2. **참조 국부성(Locality of Reference)** 
  1. 대부분의 프로그램은 **참조 국부성**을 가지고 있다. 
  2. 이는 프로그램이 실행될 때 특정 페이지를 계속해서 액세스하는 경향이 있다는 의미이다. 
  3. 만약 하나의 명령어를 실행하기 위해 여러 페이지에 걸쳐 있는 데이터에 접근해야 한다면 여러 번의 페이지 폴트가 발생할 수 있다. 
  4. 하지만 실제 실행 중인 프로세스에서는 이러한 다중 페이지 폴트가 한 명령어에서 한꺼번에 발생하는 경우는 드물다. 
  5. 참조 국부성 덕분에 디맨드 페이징은 합리적인 성능(Reasonable Performance)을 낼 수 있다. 

3. **참조 국부성 예시: 2차원 배열 액세스 패턴** 
  1. 페이지 크기가 128인 2차원 배열 int table이 있다고 가정한다. 
  2. 배열은 메모리에 연속적으로 저장되며, 한 페이지는 128개의 원소를 담을 수 있다. 
  3. **비효율적인 액세스 패턴 (행 우선 접근)** 
  1. for (j=0; j<128; j<large>) { for (i=0; i<128; i</large>) { data[i][j]를 액세스 } } 와 같이 코드를 작성하면, data, data, data... 순으로 접근하게 된다. 
  2. 이 경우, 한 페이지에 128개의 원소가 저장되므로, data에 접근할 때 페이지 폴트가 발생하여 첫 번째 페이지가 로딩된다. 
  3. 하지만 data에 접근하려면 다음 페이지를 로딩해야 하므로, 거의 모든 접근마다 페이지 폴트가 발생할 수 있다. 
  4. **효율적인 액세스 패턴 (열 우선 접근)** 
  1. for (i=0; i<128; i<large>) { for (j=0; j<128; j</large>) { data[i][j]를 액세스 } } 와 같이 코드를 작성하면, data, data, data... 순으로 접근하게 된다. 
  2. 이 경우, data에 접근할 때 페이지 폴트가 발생하여 첫 번째 페이지가 로딩되면, 그 페이지 내의 모든 원소(data부터 data)는 이미 메모리에 로딩되어 있으므로, 128번의 접근 동안 추가 페이지 폴트가 발생하지 않는다. 
  3. 결과적으로, 비효율적인 패턴은 128번의 페이지 폴트를 유발할 수 있지만, 효율적인 패턴은 단 한 번의 페이지 폴트만으로 해당 행의 모든 데이터를 처리할 수 있다. 
  5. **현대 시스템에서의 고려사항** 
  1. 최신 컴파일러는 이러한 비효율적인 코드 패턴을 자동으로 최적화(Optimization)하여 페이지 폴트 발생을 줄일 수 있다. 
  2. 페이지 프레임의 개수가 충분히 많으면, 한 번 로딩된 페이지가 스왑 아웃(Swap Out)되지 않고 계속 사용될 수 있어 페이지 폴트 문제가 크게 부각되지 않을 수 있다. 
  3. 따라서 이 개념은 개념적으로 이해하는 것이 중요하며, 실제 시스템에서 직접 실험하여 시간 차이를 확인하기는 어려울 수 있다. 
  6. **참조 국부성의 중요성** 
  1. 어떤 함수가 자주 호출되거나 반복적으로 실행된다면, 해당 함수가 포함된 페이지는 한 번 로딩되면 계속 사용될 가능성이 높다. 
  2. 특정 데이터 타입의 메모리 영역에 할당된 데이터가 계속 액세스된다면, 해당 페이지도 계속 사용된다. 
  3. 이러한 참조 국부성 덕분에 디맨드 페이징을 사용하더라도 페이지 폴트가 예상보다 많이 일어나지 않으며, 특히 데이터를 잘 나누고 프로그래밍 구조를 잘 만들면 더욱 효율적이다. 


## 4. 디맨드 페이징을 위한 하드웨어 지원 및 성능 분석 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/wJYo9K0QN2k/1360.jpg)
1. **디맨드 페이징을 위한 하드웨어 지원** 
  1. **페이지 테이블 관리**: 가상 페이지 테이블은 매우 커질 수 있으므로, 이를 효율적으로 관리하기 위한 하드웨어 지원이 필수적이다. 
  1. 페이지 테이블은 가상 페이지 번호와 실제 물리 메모리 주소(프레임 번호)를 매핑한다. 
  2. Valid-Invalid 비트 등을 사용하여 페이지의 상태(메모리 로딩 여부, 접근 권한 등)를 표시하고 관리한다. 
  2. **스왑 공간(Swap Space)**: 물리 메모리가 부족할 때 페이지를 임시로 저장할 디스크 영역인 스왑 공간이 필요하다. 
  1. 운영체제는 디스크의 특정 영역을 스왑 공간으로 사용한다. 
  2. SSD(Solid State Drive)와 같은 빠른 저장장치를 스왑 공간으로 사용하면 페이지 스왑인/스왑아웃 성능이 크게 향상된다. 

2. **SSD 사용 시 성능 향상** 
  1. 노트북이나 PC에서 C 드라이브를 SSD로 사용하는 경우가 많다. 
  2. SSD를 사용하면 페이지 스왑 작업 시 하드 디스크(HDD)보다 훨씬 빠른 액세스 속도를 제공한다. 
  3. 프로그램들이 HDD와 SSD 사이를 오가며 작업할 때, SSD의 빠른 속도가 전체적인 로딩 및 실행 성능을 향상시킨다. 

3. **명령어 재시작(Instruction Restart) 문제** 
  1. 페이지 폴트가 발생했을 때, 해당 명령어를 어떻게 재시작할 것인지가 중요하다. 
  2. 페이지 폴트 발생 시 운영체제는 트랩을 발생시키고, 해당 프로세스의 컨텍스트(레지스터 정보, 코드 관련 정보 등)를 저장한 후 페이지 스왑 작업을 수행한다. 
  3. 페이지 스왑 작업이 완료되면, 운영체제는 해당 프로세스에 시그널을 보내고, 프로세스는 저장된 컨텍스트를 로드하여 정확히 페이지 폴트가 발생했던 지점부터 다시 실행되어야 한다. 
  4. 이 과정에서 다른 프로세스들이 페이지 테이블을 변경할 수 있으므로, 각 프로세스별로 페이지 테이블을 잘 관리하는 것이 중요하다. 
  5. 페이지 테이블이 매우 커질 수 있다는 점도 관리의 복잡성을 더한다. 

4. **페이지 폴트 처리 과정의 세부 단계** 
  1. 메모리 액세스(읽기 또는 쓰기) 중 페이지 폴트가 발생하면, 페이지 프레임을 할당해야 한다. 
  2. 페이지 폴트가 발생한 명령어가 저장된 공간이 페이징되어 있는지 확인해야 한다. 
  3. **프리 프레임 리스트(Free Frame List)**를 운영체제가 관리해야 한다. 
  1. 사용 가능한 빈 페이지 프레임들의 목록을 유지한다. 
  2. 페이지 폴트 발생 시 이 리스트에서 빈 프레임을 가져와 페이지를 로딩한다. 
  3. 프리 프레임들은 스택이나 세그먼트 형태로 관리될 수 있다. 

5. **유효 접근 시간(Effective Access Time) 계산** 
  1. 디맨드 페이징 시스템의 성능을 평가하는 중요한 지표이다. 
  2. **변수 정의**: 
  - 메모리 액세스 시간(Memory Access Time): men (예: 200 나노초)
  - 페이지 폴트 발생 확률(Page Fault Rate): P
  3. **TLB(Translation Lookaside Buffer) 고려**: TLB 히트 여부에 따라 액세스 시간이 달라진다. 
  1. TLB 히트 시 시간이 절약된다. 
  2. TLB 미스 시 페이지 폴트가 발생할 수 있다. 
  4. **페이지 폴트 처리 시간**: 페이지 폴트가 발생했을 때 페이지를 로딩하고 프로세스를 재시작하는 데 걸리는 시간이다. 
  1. 하드웨어 액세스, 컨텍스트 스위치, 스와핑, 트랩 복귀 등 매우 긴 시간이 소요될 수 있다. 
  2. 일반적인 메모리 액세스 시간과는 비교할 수 없을 정도로 길다. 
  5. **유효 접근 시간 공식**: (1 - P) × 메모리 액세스 시간 + P × 페이지 폴트 처리 시간 
  - P는 페이지 폴트 발생 확률이다.
  - 페이지 폴트 처리 시간은 페이지 폴트 서비스 시간(Page Fault Service Time)을 의미한다.

6. **페이지 폴트 처리 시간의 구성 요소** 
  1. 페이지 폴트 처리 시간은 주로 다음 세 가지 중요한 시간으로 구성된다. 
  1. 인터럽트(트랩) 발생 및 처리 시간 
  2. 페이지를 보조 저장장치에서 읽어 들이는 시간 
  3. 프로세스를 재시작하는 시간 
  2. 이 중 **페이지를 읽어 들이는 시간**이 대부분을 차지한다. 

7. **유효 접근 시간 계산 예시** 
  1. **가정**: 
  - 평균 페이지 폴트 서비스 시간(Average Page Fault Service Time): 8 밀리초 (8,000,000 나노초)
  - 메모리 액세스 시간(Memory Access Time): 200 나노초
  2. **계산**: (1 - P) × 200 나노초 + P × 8,000,000 나노초 
  3. **예시**: 페이지 폴트 확률 P = 0.0001 (10,000번 액세스 중 1번 페이지 폴트 발생)일 경우 
  - 200 + 0.0001 × (8,000,000 - 200) = 200 + 0.0001 × 7,999,800 = 200 + 799.98 = 999.98 나노초
  - 이는 약 1 마이크로초에 해당하며, 책에서는 8.2 마이크로초로 표기되어 있을 수 있다. 


## 5. 카피 온 라이트(Copy-on-Write) 
![image]()
1. **카피 온 라이트(Copy-on-Write) 개념** 
  1. "쓸 때 복사한다"는 의미로, 공유 페이지가 있을 때 쓰기 작업이 발생할 때만 복사하는 기법이다. 
  2. 읽기 작업만 이루어지는 동안에는 여러 프로세스가 동일한 페이지를 공유해도 문제가 없다. 
  3. 하지만 공유 페이지에 쓰기(Write) 작업이 발생하면, 그때 해당 페이지를 복사하여 별도의 물리적 페이지를 할당한다. 

2. **fork() 시스템 호출과의 연관성** 
  1. fork() 시스템 호출은 부모 프로세스의 메모리 공간을 자식 프로세스에 그대로 복사하여 새로운 프로세스를 생성한다. 
  2. 카피 온 라이트가 없다면, fork() 시 부모 프로세스의 모든 메모리 영역을 물리적으로 복사해야 하므로 비효율적이다. 
  3. 카피 온 라이트를 사용하면, fork() 시 부모와 자식 프로세스가 동일한 물리적 페이지를 공유한다. 
  4. 만약 자식 프로세스나 부모 프로세스가 공유 페이지에 쓰기 작업을 시도하면, 해당 페이지에 대해서만 복사가 발생하여 별도의 물리적 페이지를 할당한다. 
  5. 이때, 복사된 페이지는 새로운 물리적 페이지에 저장되고, 해당 프로세스의 페이지 테이블만 업데이트되어 새로운 페이지를 가리키도록 한다. 

3. **execl() 시스템 호출과의 연관성** 
  1. fork() 이후 execl() 시스템 호출을 통해 새로운 프로그램을 실행할 때, 모든 페이지를 새로 복사할 필요 없이 쓰기 작업이 발생하는 페이지에 대해서만 복사하면 된다. 


## 6. 다음 학습 내용: 페이지 교체(Page Replacement) 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/wJYo9K0QN2k/2220.jpg)
1. **페이지 교체 문제의 발생** 
  1. 디맨드 페이징은 필요할 때만 페이지를 불러들이는 방식이다. 
  2. 하지만 물리 메모리 공간이 모두 차서 더 이상 빈 프레임이 없을 경우 문제가 발생한다. 
  3. 이때는 기존에 메모리에 있던 페이지 중 하나를 선택하여 내보내야(쫓아내야) 한다. 

2. **페이지 교체 알고리즘** 
  1. 어떤 페이지를 내보낼 것인지 결정하는 규칙이 필요하며, 이를 **페이지 교체(Page Replacement)** 문제라고 한다. 
  2. 다음 시간에는 이 페이지 교체 알고리즘에 대해 학습할 예정이다. 

