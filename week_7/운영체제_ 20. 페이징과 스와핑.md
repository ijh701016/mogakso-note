
## 📌 페이징과 스와핑은 무엇인가요?
페이징은 프로세스의 물리적 주소 공간을 연속적이지 않게 나누어 외부 단편화 문제를 완화하고, 스와핑은 물리적 메모리보다 큰 프로그램을 실행하기 위해 필요한 페이지를 메모리에 올리고 필요 없는 페이지를 디스크로 내리는 <mark>메모리 관리 기법</mark>입니다.
##### 💡 페이징의 주요 특징은 무엇인가요?
- 물리적 메모리를 고정된 크기의 '프레임'으로 나누고, 논리적 메모리를 동일한 크기의 '페이지'로 나눕니다.
- 프로그램의 논리적 주소 공간과 물리적 주소 공간의 바인딩을 완전히 분리하여, 페이지를 물리적 메모리의 어떤 프레임에도 자유롭게 로드할 수 있습니다.
- 페이지 테이블을 통해 논리적 주소를 물리적 주소로 변환하며, TLB(Translation Lookaside Buffer) 캐시를 사용하여 메모리 접근 시간을 단축합니다.
- 보호 비트(Protection Bit)를 사용하여 각 페이지의 유효성을 검사하고, 공유 페이지를 통해 공통 코드를 여러 프로세스가 효율적으로 공유할 수 있습니다.


운영체제의 핵심 개념인 **페이징(Paging)**과 **스와핑(Swapping)**을 깊이 있게 다루는 콘텐츠입니다. 이 콘텐츠는 메모리 관리의 비효율성을 해결하고, 물리 메모리보다 큰 프로그램을 실행할 수 있게 하는 **가상 메모리(Virtual Memory)**의 기반 기술을 명확히 설명합니다. 특히, 연속적이지 않은 메모리 할당을 통해 **외부 단편화 문제를 해소**하고, 페이지 테이블, TLB(Translation Lookaside Buffer)와 같은 하드웨어 지원을 통해 **메모리 접근 속도를 최적화**하는 방법을 구체적인 예시와 함께 제시합니다. 복잡한 운영체제 개념을 실제 시스템 동작 원리와 연결하여 이해하고 싶은 분들에게 실질적인 통찰을 제공할 것입니다.
## 1. 페이징(Paging)과 스와핑(Swapping) 개요 


### 1.1. 기존 메모리 할당 방식의 문제점 
![image]()
1. **연속적인 메모리 할당의 비효율성**: 프로세스에 메모리를 연속적으로 할당하는 방식은 간단하고 관리하기 쉽지만, 프로그램의 크기가 커질수록 문제가 발생한다. 
2. **외부 단편화(External Fragmentation) 문제**: 연속적인 할당 방식은 외부 단편화 문제를 야기하여 메모리 공간이 충분해도 연속된 공간이 없어 할당하지 못하는 경우가 발생한다. 


### 1.2. 페이징(Paging)의 개념 및 장점 
![image]()
1. **메모리 관리 방식**: 페이징은 물리적 주소 공간을 연속적이지 않게 쪼개어 관리하는 메모리 관리 기법이다. 
2. **외부 단편화 완화**: 연속적이지 않은 할당을 통해 외부 단편화 문제를 완화하거나 거의 없앨 수 있다. 
3. **압축 불필요**: 쪼개진 메모리 조각들을 압축하여 하나의 큰 메모리 덩어리로 만들 필요가 없다. 
4. **작은 크기 단위 관리**: 메모리 단위를 작게 쪼개어 관리하므로 효율성이 증대된다. 
5. **하드웨어 지원 필수**: 메모리 접근 시 하드웨어의 도움이 필수적이다. 


### 1.3. 페이징의 기본 동작 원리 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/2Kvp_Lozlcs/121.jpg)
1. **물리 메모리 분할 (프레임)**:
  1. 물리 메모리를 고정된 크기의 블록으로 쪼개며, 이를 **프레임(Frame)**이라고 부른다. 
  2. 예시: 1GB 메모리를 1KB 프레임으로 쪼개면 1메가바이트당 1024개의 프레임을 만들 수 있다. 
2. **논리 메모리 분할 (페이지)**:
  1. 프로그램(논리 메모리)도 프레임과 동일한 크기로 쪼개며, 이를 **페이지(Page)**라고 부른다. 
  2. 예시: 64KB 프로그램은 1KB 페이지 64개로 구성된다. 
3. **비연속적 매핑**:
  1. 페이지들을 물리 메모리의 프레임에 올릴 때 순서대로 올릴 필요가 없다. 
  2. 프로그램의 논리적 주소 공간과 물리적 주소 공간의 바인딩을 완전히 분리한다. 
  3. 컴파일러는 논리적 주소를 유지하고, 운영체제가 실제 물리적 주소로의 매핑을 담당한다. 


### 1.4. 논리 주소와 물리 주소 변환 
![image]()
1. **주소 구성**: 논리 주소는 **페이지 번호(p)**와 **오프셋(d)**으로 구성된다. 
  1. CPU는 물리 주소(예: 0xFFFFF000) 대신 "2번 페이지의 34번째 주소"와 같이 논리 주소를 사용한다. 
  2. 페이지 번호는 0부터 시작하며, 페이지 오프셋은 페이지 내에서의 상대적 위치를 나타낸다. 
2. **페이지 테이블(Page Table)**:
  1. 각 프로세스별로 페이지 테이블이 존재하며, 페이지 번호와 해당 페이지가 로드된 물리 프레임 번호를 매핑하여 관리한다. 
  2. CPU가 생성한 논리 주소(페이지 번호, 오프셋)에서 페이지 번호를 통해 페이지 테이블에서 실제 물리 프레임 번호를 찾는다. 
  3. 찾아낸 물리 프레임 번호에 논리 주소의 오프셋을 더하여 실제 물리 주소를 얻는다. 
3. **주소 변환 과정 요약**: 페이지 번호를 통해 페이지 프레임을 찾고, 해당 프레임의 오프셋을 사용하여 메모리에 접근한다. 


### 1.5. 페이징 예시 및 장점 
![image](https://resource-release.s3.ap-northeast-2.amazonaws.com/thumbnails/2Kvp_Lozlcs/484.jpg)
1. **매핑 예시**: 4개의 페이지(0, 1, 2, 3)를 가진 프로그램이 8개의 물리 프레임(0~7)에 로드될 때, 0번 페이지는 1번 프레임, 1번 페이지는 4번 프레임 등으로 비연속적으로 매핑될 수 있다. 
2. **장점**:
  1. 물리 메모리에 프로그램이 논리적으로 로드되므로 유연성이 높다. 
  2. 프레임 크기가 동일하므로 외부 단편화가 발생하지 않는다. 


### 1.6. 내부 단편화(Internal Fragmentation) 
![image]()
1. **발생 원인**: 프로그램의 실제 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지의 남는 공간은 사용되지 않아 내부 단편화가 발생한다. 
2. **예시**: 프로그램 크기가 페이지 4개가 필요한데, 실제로는 1만큼만 필요할 경우 남는 공간은 낭비된다. 


## 2. 페이징 관련 이슈 및 최적화 


### 2.1. 페이지 사이즈 결정 
![image]()
1. **프레임 사이즈와 동일**: 페이지 사이즈는 프레임 사이즈와 동일하게 정해진다. 
2. **적절한 크기**: 1바이트 단위로 프레임 사이즈를 정하는 것은 비효율적이다. 
3. **하드웨어 의존성**: 페이지 사이즈는 하드웨어에 따라 달라지며, 과거에는 4KB가 일반적이었으나 요즘은 3MB, 1MB 등 다양하다. 
4. **개념적 이해**: 페이지 사이즈는 2의 n승 배수로 정해져야 한다. 
5. **주소 공간 계산**: 논리 주소 공간(2^N)과 페이지 사이즈(2^X)가 주어지면, 페이지 번호에 필요한 비트 수(N-X)와 오프셋에 필요한 비트 수(X)를 계산할 수 있어야 한다. 


### 2.2. 새로운 프로세스 도착 시 메모리 할당 
![image]()
1. **프리 프레임 리스트 관리**: 운영체제는 사용 가능한 물리 프레임(프리 프레임) 리스트를 관리한다. 
2. **페이지 테이블 채우기**: 새로운 프로세스가 도착하면, 프리 프레임 리스트에서 프레임을 할당받아 프로세스의 페이지들을 로드하고, 해당 매핑 정보를 페이지 테이블에 채워 넣는다. 


### 2.3. 컨텍스트 스위치와 페이지 테이블 
![image]()
1. **페이지 테이블의 포함**: CPU 스케줄러가 새로운 프로세스를 실행하기 위해 컨텍스트 스위치가 발생할 때, 페이지 테이블도 컨텍스트 스위치에 포함되어야 한다. 
2. **일관성 유지**: 프로세스가 다시 재진입했을 때, 페이지 테이블의 내용이 그대로 보장되어야 하기 때문이다. 


### 2.4. 대규모 페이지 테이블 관리 문제 
![image]()
1. **페이지 테이블의 크기**: MS 오피스나 구글 크롬과 같은 대규모 프로그램은 페이지 수가 매우 많아 페이지 테이블 자체의 크기가 엄청나게 커진다. 
2. **관리의 어려움**: 이렇게 커진 페이지 테이블을 관리하는 것 자체가 큰 부담이 된다. 


### 2.5. 페이지 테이블 베이스 레지스터(PTBR) 
![image]()
1. **개념**: 페이지 테이블 자체를 메모리에 저장하고, CPU 내의 PTBR 레지스터가 페이지 테이블의 시작 주소를 가리키도록 한다. 
2. **컨텍스트 스위치 효율**: 컨텍스트 스위치 시 PTBR 값만 변경하면 되므로 빠르다. 
3. **단점**: 메모리 접근 시간이 느려진다. 


### 2.6. 메모리 접근 횟수 증가 문제 
![image]()
1. **두 번의 메모리 접근**: 페이지 테이블이 메모리에 있을 경우, 논리 주소를 물리 주소로 변환하기 위해 두 번의 메모리 접근이 필요하다. 
  1. 페이지 테이블에 접근하여 프레임 번호를 얻는 메모리 접근. 
  2. 실제 데이터가 있는 물리 메모리에 접근하는 메모리 접근. 
2. **성능 저하**: 이로 인해 메모리 접근 시간이 두 배로 늘어나 성능 저하가 발생한다. 


### 2.7. TLB(Translation Lookaside Buffer)를 이용한 최적화 
![image]()
1. **TLB의 역할**: 페이지 테이블 접근으로 인한 성능 저하를 해결하기 위해 **TLB(Translation Lookaside Buffer)**라는 캐시 메모리를 사용한다. 
2. **작동 방식**:
  1. TLB는 작고 빠른 하드웨어 캐시로, 페이지 번호와 프레임 번호의 매핑 정보를 저장한다. 
  2. CPU가 논리 주소를 생성하면 먼저 TLB를 확인한다. 
  3. **TLB 히트(Hit)**: TLB에 해당 페이지 정보가 있으면(히트), 바로 물리 프레임에 접근하여 메모리 접근 시간을 단축한다. (페이지 테이블 접근 시간 절약) 
  4. **TLB 미스(Miss)**: TLB에 해당 페이지 정보가 없으면(미스), 메모리에 있는 페이지 테이블에 접근하여 정보를 가져온 후 TLB에 저장하고, 다시 물리 프레임에 접근한다. 
3. **유효 메모리 접근 시간(Effective Memory Access Time) 계산**:
  1. TLB 히트율(Hit Rate)과 미스율(Miss Rate)에 따라 실제 메모리 접근 시간이 달라진다. 
  2. **계산 예시**:
  1. 메모리 접근 시간: 10 나노초(ns) 
  2. TLB 히트율: 80% (0.8), TLB 미스율: 20% (0.2) 
  3. TLB 히트 시: 0.8 * 10ns = 8ns 
  4. TLB 미스 시: 페이지 테이블 접근(10ns) + 실제 데이터 접근(10ns) = 20ns. 따라서 0.2 * 20ns = 4ns 
  5. 총 유효 메모리 접근 시간: 8ns + 4ns = <mark>12ns</mark> 
  3. 히트율이 99%일 경우: 0.99 <em> 10ns + 0.01 </em> 20ns = <mark>10.1ns</mark> 


### 2.8. 메모리 보호(Memory Protection) 
![image]()
1. **기존 방식의 한계**: 연속 할당 방식에서는 베이스 레지스터와 리미트 레지스터로 유효/무효 영역을 판단했으나, 페이징에서는 불가능하다. 
2. **보호 비트(Protection Bit) 사용**:
  1. 각 페이지 프레임별로 **유효(Valid)/무효(Invalid)**를 나타내는 1비트의 보호 비트를 추가한다. 
  2. **유효 비트**: 해당 페이지가 논리 주소 공간에 포함되어 있어 합법적인 접근임을 나타낸다. 
  3. **무효 비트**: 해당 페이지가 논리 주소 공간에 포함되어 있지 않아 불법적인 접근임을 나타낸다. 
  4. 불법적인 접근(무효 주소)이 발생하면 트랩(Trap)을 발생시켜 운영체제에 알린다. 


### 2.9. 공유 페이지(Shared Pages) 
![image]()
1. **공통 코드 공유**: 페이징을 통해 공통으로 사용되는 코드(예: DLL, 표준 C 라이브러리)를 여러 프로세스가 공유할 수 있다. 
2. **비효율성 해결**: 모든 프로세스가 공통 라이브러리의 복사본을 각자 가지고 있는 것은 매우 비효율적이다. 
3. **재진입 가능 코드(Reentrant Code)**:
  1. 실행 중에 자기 코드를 변경하지 않는 코드(Self-modifying code가 아닌 코드)를 의미한다. 
  2. 표준 C 라이브러리(libc)가 대표적인 예시이다. 
4. **공유 방식**:
  1. 각 프로세스는 자신의 논리 주소 공간에 공유 코드의 페이지를 가지고 있다. 
  2. 하지만 이 페이지들이 가리키는 페이지 테이블 엔트리는 동일한 물리 프레임을 가리킨다. 
  3. 즉, 물리 메모리에는 공유 코드가 한 번만 로드되어 있고, 여러 프로세스가 논리적으로 이를 공유하여 사용한다. 
5. **장점**: 동기화 문제가 발생하지 않으며, 메모리 사용 효율이 높아진다. 


### 2.10. 대규모 페이지 테이블 해결 방안 
![image]()
1. **문제점**: 논리 주소 공간 자체가 너무 커져 페이지 테이블도 너무 커지는 문제가 발생한다. 
2. **해결 방안**:
  1. **계층적 페이징(Hierarchical Paging)**:
  1. 페이지 테이블이 너무 커지면, 이 페이지 테이블 자체를 다시 쪼개어 또 다른 페이지 테이블(외부 페이지 테이블)을 만든다. 
  2. 이를 **2단계 페이지 테이블(Two-level Page Table)**이라고 하며, 여러 단계로 확장될 수 있다. 
  2. **해시 페이지 테이블(Hashed Page Table)**:
  1. 데이터를 효율적으로 저장하고 검색하는 해싱 기법을 페이지 테이블에 적용한다. 
  2. 논리 주소의 페이지 번호를 해시 함수를 통해 해시 테이블의 값으로 변환하여 물리 프레임 번호를 얻는다. 
  3. 32비트보다 큰 주소 공간을 다룰 때 유용하다. 
  3. **역 페이지 테이블(Inverted Page Table)**:
  1. 기존 방식은 프로세스별로 논리 페이지 번호를 물리 프레임 번호에 매핑하지만, 역 페이지 테이블은 반대로 관리한다. 
  2. 물리 프레임 번호에 어떤 프로세스의 어떤 페이지가 로드되어 있는지를 저장한다. 
  3. PID(프로세스 ID)를 추가하여 관리하며, 페이지 테이블 자체가 너무 클 때 가장 유용하다. 


## 3. 스와핑(Swapping)의 개념 및 페이징과의 연관성 


### 3.1. 스와핑의 필요성 
![image]()
1. **가상 메모리의 기반**: 페이징은 물리 메모리보다 훨씬 큰 프로그램을 실행할 수 있는 **가상 메모리(Virtual Memory)**의 핵심 기반 기술이다. 
2. **메모리 분할 활용**: 프로그램 전체가 물리 메모리에 로드될 필요 없이, 필요한 부분(페이지)만 로드하여 사용하다가 필요 없으면 내리고, 필요한 부분을 다시 올리는 방식이다. 
3. **물리 메모리보다 큰 프로그램 실행**: 실제 물리 메모리 크기보다 큰 논리 메모리(프로그램)를 사용할 수 있게 된다. 


### 3.2. 스와핑의 정의 및 장점 
![image]()
1. **개념**: 현재 당장 필요한 페이지(명령어, 데이터)만 메모리에 올려놓고, 필요 없는 페이지는 보조 저장장치(하드디스크)로 내보내는(Swap Out) 방식이다. 
2. **멀티 프로그래밍 증가**: 한 프로세스가 물리 메모리의 작은 부분(한 페이지 또는 몇 페이지)만 사용하므로, 동시에 실행할 수 있는 프로세스의 수(Degree of Multiprogramming)가 훨씬 증가한다. 


### 3.3. 스와핑의 종류 
![image]()
1. **표준 스와핑(Standard Swapping)**: 프로세스 전체를 메모리에서 하드디스크로 내보내거나(Swap Out), 하드디스크에서 메모리로 가져오는(Swap In) 방식이다. 
2. **페이지 스와핑(Page Swapping)**: 메모리 영역을 페이지 단위로 스왑 인/아웃하는 방식이다. 


### 3.4. 페이징과 스와핑의 결합 
![image]()
1. **표준 스와핑의 부담**: 프로세스 전체를 스왑 인/아웃하는 것은 매우 비효율적이고 부담이 크다. 
2. **페이징의 활용**: 페이징을 통해 페이지 단위로 스와핑이 가능해지면서, 작은 크기의 페이지를 빠르게 스왑 인/아웃할 수 있게 되었다. 
3. **용어 변화**: 오늘날에는 페이징과 결합된 스와핑을 단순히 **페이징(Paging)**이라고 부르며, 스왑 인/아웃 대신 **페이지 인(Page In)**, **페이지 아웃(Page Out)**이라는 용어를 사용한다. 
4. **정의**: 한 페이지를 메모리에서 보조 저장장치로 옮기거나(페이지 아웃), 보조 저장장치에서 메모리로 옮기는(페이지 인) 것을 의미한다. 


### 3.5. 페이지 인/아웃 예시 
![image]()
1. **페이지 아웃**: 프로세스 A가 사용하던 페이지(B, C, E)가 더 이상 필요 없으면 디스크의 블록 단위로 페이지 아웃시킨다. 
2. **페이지 인**: 프로세스 B가 필요한 페이지(F, H, J)를 디스크에서 메모리로 로딩하는 작업을 페이지 인이라고 한다. 


### 3.6. 페이징 학습의 중요성 
![image]()
1. **가상 메모리 이해의 핵심**: 페이징은 다음 시간에 배울 **가상 메모리(Virtual Memory)**의 핵심 개념인 **요구 페이징(Demand Paging)**이 어떻게 동작하는지 이해하기 위한 필수적인 학습 내용이다. 

